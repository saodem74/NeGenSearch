Unit testing From Wikipedia, the free encyclopedia Jump to navigation Jump to search Software testing method by which individual units of source code are tested to determine whether they are fit for use This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources   Unit testing     news    newspapers    books    scholar    JSTOR  November 2007   Learn how and when to remove this template message  Software development Core activities Processes Requirements Design Engineering Construction Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DevOps DAD DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TSP UP XP Supporting disciplines Configuration management Documentation Software quality assurance SQA Project management User experience Practices ATDD BDD CCO CI CD DDD PP SBE Stand-up TDD Tools Compiler Debugger Profiler GUI designer Modeling IDE Build automation Release automation Infrastructure as code Testing Standards and Bodies of Knowledge BABOK CMMI IEEE standards ISO 9001 ISOIEC standards PMBOK SWEBOK ITIL Glossaries Artificial intelligence Computer science Electrical and electronics engineering v t e In computer programming , unit testing is a software testing method by which individual units of source code , sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use. 1  Contents 1 Description 2 Advantages 3 Limitations and disadvantages 4 Example 5 As executable specifications 6 Applications 6.1 Extreme programming 6.2 Unit testing frameworks 6.3 Language-level unit testing support 7 See also 8 Notes 9 External links Description  edit  Unit tests are typically automated tests written and run by software developers to ensure that a section of an application known as the unit meets its design and behaves as intended. 2  In procedural programming , a unit could be an entire module, but it is more commonly an individual function or procedure. In object-oriented programming , a unit is often an entire interface, such as a class, but could be an individual method. 3  By writing tests first for the smallest testable units, then the compound behaviors between those, one can build up comprehensive tests for complex applications. 2  To isolate issues that may arise, each test case should be tested independently. Substitutes such as method stubs , mock objects , 4  fakes , and test harnesses can be used to assist testing a module in isolation. During development, a software developer may code criteria, or result that is known to be good, into the test to verify the units correctness. During test case execution, frameworks log tests that fail any criterion and report them in a summary. Writing and maintaining unit tests can be made faster by using Parameterized Tests PUTs. These allow the execution of one test multiple times with different input sets, thus reducing test code duplication. Unlike traditional unit tests, which are usually closed methods and test invariant conditions, PUTs take any set of parameters. PUTs have been supported by TestNG , JUnit and its .Net counterpart, XUnit . Suitable parameters for the unit tests may be supplied manually or in some cases are automatically generated by the test framework. In recent years support was added for writing more powerful unit tests, leveraging the concept of Theory. A parameterized test uses same execution steps with multiple input sets that are pre-defined. A theory is a test case that executes the sa me steps still, but inputs can be provided by a data generating method at run time. 5  6  7  Advantages  edit  The goal of unit testing is to isolate each part of the program and show that the individual parts are correct. 1  A unit test provides a strict, written contract that the piece of code must satisfy. As a result, it affords several benefits. Unit testing finds problems early in the development cycle . This includes both bugs in the programmers implementation and flaws or missing parts of the specification for the unit. The process of writing a thorough set of tests forces the author to think through inputs, outputs, and error conditions, and thus more crisply define the units desired behavior. The cost of finding a bug before coding begins or when the code is first writt en is considerably lower than the cost of detecting, identifying, and correcting the bug later. Bugs in released code may also cause costly problems for the end-users of the software. 8  9  10  Code can be impossible or difficult to unit test if poorly written, thus unit testing can force developers to structure functions and objects in better ways. In test-driven development TDD, which is frequently used in both extreme programming and scrum , unit tests are created before the code itself is written. When the tests pass, that code is considered complete. The same unit tests are run against that function frequently as the larger code base is developed either as the code is changed or via an automated process with the build. If the unit tests fail, it is considered to be a bug either in the changed code or the tests themselves. The unit tests then allow the location of the fault or failure to be easily traced. Since the unit tests alert the development team of the problem before handing the code off to testers or clients, potential problems are caught early in the development process. Unit testing allows the programmer to refactor code or upgrade system libraries at a later date, and make sure the module still works correctly e.g., in regression testing . The procedure is to write test cases for all functions and methods so that whenever a change causes a fault, it can be quickly identified. Unit tests detect changes which may break a design contract . Unit testing may reduce uncertainty in the units themselves and can be used in a bottom-up testing style approach. By testing the parts of a program first and then testing the sum of its parts, integration testing becomes much easier.  citation needed  Unit testing provides a sort of living documentation of the system. Developers looking to learn what functionality is provided by a unit, and how to use it, can look at the unit tests to gain a basic understanding of the units interface  API . Unit test cases embody characteristics that are critical to the success of the unit. These characteristics can indicate appropriateinappropriate use of a unit as well as negative behaviors that are to be trapped by the unit. A unit test case, in and of itself, documents these critical characteristics, although many software development environments do not rely solely upon code to document th e product in development. When software is developed using a test-driven approach, the combination of writing the unit test to specify the interface plus the refactoring activities performed after the test has passed, may take the place of formal design. Each unit test can be seen as a design element specifying classes, methods, and observable behaviour. Limitations and disadvantages  edit  Testing will not catch every error in the program, because it cannot evaluate every execution path in any but the most trivial programs. This problem is a superset of the halting problem , which is undecidable . The same is true for unit testing. Additionally, unit testing by definition only tests the functionality of the units themselves. Therefore, it will not catch integration errors or broader system-level errors such as functions performed across multiple units, or non-functional test areas such as performance . Unit testing should be done in conjunction with other software testing activities, as they can only show the presence or absence of particular errors they cannot prove a complete absence of errors. To guarantee correct behavior for every execution path and every possible input, and ensure the absence of errors, other techniques are required, namely the application of formal methods to proving that a software component has no unexpected behavior. An elaborate hierarchy of unit tests does not equal integration testing. Integration with peripheral units should be included in integration tests, but not in unit tests.  citation needed  Integration testing typically still relies heavily on humans testing manually  high-level or global-scope testing can be difficult to automate, such that manual testing often appears faster and cheaper.  citation needed  Software testing is a combinatorial problem. For example, every Boolean decision statement requires at least two tests one with an outcome of true and one with an outcome of false. As a result, for every line of code written, programmers often need 3 to 5 lines of test code. 11  This obviously takes time and its investment may not be worth the effort. There are problems that cannot easily be tested at all  for example those that are nondeterministic or involve multiple threads . In addition, code for a unit test is likely to be at least as buggy as the code it is testing. Fred Brooks in The Mythical Man-Month quotes Never go to sea with two chronometers take one or three. 12  Meaning, if two chronometers contradict, how do you know which one is correct Another challenge related to writing the unit tests is the difficulty of setting up realistic and useful tests. It is necessary to create relevant initial conditions so the part of the application being tested behaves like part of the complete system. If these initial conditions are not set correctly, the test will not be exercising the code in a realistic context, which dimini shes the value and accuracy of unit test results. 13  To obtain the intended benefits from unit testing, rigorous discipline is needed throughout the software development process. It is essential to keep careful records not only of the tests that have been performed, but also of all changes that have been made to the source code of this or any other unit in the software. Use of a version control system is essential. If a later version of the unit fails a particular test that it had previously passed, the version-control software can provide a list of the source code changes if any that have been applied to the unit since that time. It is also essential to implement a sustainable process for ensuring that test case failures are reviewed regularly and addressed immediately. 14  If such a process is not implemented and ingrained into the teams workflow, the application will evolve out of sync with the unit test suite, increasing false positives and reducing the effectiveness of the test suite. Unit testing embedded system software presents a unique challenge Because the software is being developed on a different platform than the one it will eventually run on, you cannot readily run a test program in the actual deployment environment, as is possible with desktop programs. 15  Unit tests tend to be easiest when a method has input parameters and some output. It is not as easy to create unit tests when a major function of the method is to interact with something external to the application. For example, a method that will work with a database might require a mock up of database interactions to be created, which probably wont be as comprehensive as the real database interactions. 16   better  source  needed  Example  edit  Here is a set of test cases in Java that specify a number of elements of the implementation. First, that there must be an interface called Adder, and an implementing class with a zero-argument constructor called AdderImpl. It goes on to assert that the Adder interface should have a method called add, with two integer parameters, which returns another integer. It also specifies the behaviour of this method for a small range of values over a number of test methods. import static org.junit.Assert.  import org.junit.Test  public class TestAdder  Test public void testSumPositiveNumbersOneAndOne   Adder adder  new AdderImpl  assert  adder . add  1 , 1   2    can it add the positive numbers 1 and 2 Test public void testSumPositiveNumbersOneAndTwo   Adder adder  new AdderImpl  assert  adder . add  1 , 2   3    can it add the positive numbers 2 and 2 Test public void testSumPositiveNumbersTwoAndTwo   Adder adder  new AdderImpl  assert  adder . add  2 , 2   4    is zero neutral Test public void testSumZeroNeutral   Adder adder  new AdderImpl  assert  adder . add  0 , 0   0    can it add the negative numbers -1 and -2 Test public void testSumNegativeNumbers   Adder adder  new AdderImpl  assert  adder . add - 1 , - 2   - 3    can it add a positive and a negative Test public void testSumPositiveAndNegative   Adder adder  new AdderImpl  assert  adder . add - 1 , 1   0    how about larger numbers Test public void testSumLargeNumbers   Adder adder  new AdderImpl  assert  adder . add  1234 , 988   2222    In this case the unit tests, having been written first, act as a design document specifying the form and behaviour of a desired solution, but not the implementation details, which are left for the programmer. Following the do the simplest thing that could possibly work practice, the easiest solution that will make the test pass is shown below. interface Adder  int add  int a , int b   class AdderImpl implements Adder  public int add  int a , int b   return a  b    As executable specifications  edit  Using unit-tests as a design specification has one significant advantage over other design methods The design document the unit-tests themselves can itself be used to verify the implementation. The tests will never pass unless the developer implements a solution according to the design. Unit testing lacks some of the accessibility of a diagrammatic specification such as a UML diagram, but they may be generated from the unit test using automated tools. Most modern languages have free tools usually available as extensions to IDEs . Free tools, like those based on the xUnit framework, outsource to another system the graphical rendering of a view for human consumption. Applications  edit  Extreme programming  edit  Unit testing is the cornerstone of extreme programming , which relies on an automated unit testing framework . This automated unit testing framework can be either third party, e.g., xUnit , or created within the development group. Extreme programming uses the creation of unit tests for test-driven development . The developer writes a unit test that exposes either a software requirement or a defect. This test will fail because either the requirement isnt implemented yet, or because it intentionally exposes a defect in the existing code. Then, the developer writes the simplest code to make the test, along with other tests, pass. Most code in a system is unit tested, but not necessarily all paths through the code. Extreme programming mandates a test everything that can possibly break strategy, over the traditional test every execution path method. This leads developers to develop fewer tests than classical methods, but this isnt really a problem, more a restatement of fact, as classical methods hav e rarely ever been followed methodically enough for all execution paths to have been thoroughly tested.  citation needed  Extreme programming simply recognizes that testing is rarely exhaustive because it is often too expensive and time-consuming to be economically viable and provides guidance on how to effectively focus limited resources. Crucially, the test code is considered a first class project artifact in that it is maintained at the same quality as the implementation code, with all duplication removed. Developers release unit testing code to the code repository in conjunction with the code it tests. Extreme programmings thorough unit testing allows the benefits mentioned above, such as simpler and more co nfident code development and refactoring , simplified code integration, accurate documentation, and more modular designs. These unit tests are also constantly run as a form of regression test . Unit testing is also critical to the concept of Emergent Design . As emergent design is heavily dependent upon refactoring, unit tests are an integral component. 17  Unit testing frameworks  edit  See also List of unit testing frameworks Unit testing frameworks are most often third-party products that are not distributed as part of the compiler suite. They help simplify the process of unit testing, having been developed for a wide variety of languages . Examples of testing frameworks include open source solutions such as the various code-driven testing frameworks known collectively as xUnit , and proprietarycommercial solutions such as Cantata for CCTypemock Isolator.NETIsolator, TBrun , JustMock , Parasoft Development Testing  Jtest , Parasoft CCtest , dotTEST, Testwell CTA and VectorCASTC. It is generally possible to perform unit testing without the support of a specific framework by writing client code that exercises the units under test and uses assertions , exception handling , or other control flow mechanisms to signal failure. Unit testing without a framework is valuable in that there is a barrier to entry for the adoption of unit testing having scant unit tests is hardly better than having none at all, whereas once a framework is in place, adding unit tests becomes relatively easy. 18  In some frameworks many advanced unit test features are missing or must be hand-coded. Language-level unit testing support  edit  Some programming languages directly support unit testing. Their grammar allows the direct declaration of unit tests without importing a library whether third party or standard. Additionally, the boolean conditions of the unit tests can be expressed in the same syntax as boolean expressions used in non-unit test code, such as what is used for if and while statements. Languages with built-in unit testing support include Apex Cobra Crystal 19  D 20  Go 21  LabVIEW MATLAB Python 22  Racket 23  24  Ruby 25  Rust 26  Some languages without built-in unit-testing support have very good unit testing librariesframeworks. Those languages include ABAP C Clojure 27  Elixir Java JavaScript Objective-C Perl PHP PowerShell 28  Scala tcl Visual Basic .NET Xojo with XojoUnit See also  edit  Acceptance testing Characterization test Component-based usability testing Design predicates Design by contract Extreme programming Functional testing Integration testing List of unit testing frameworks Regression testing Software archaeology Software testing Test case Test-driven development xUnit  a family of unit testing frameworks. Notes  edit   a b Kolawa, Adam Huizinga, Dorota 2007. Automated Defect Prevention Best Practices in Software Management . Wiley-IEEE Computer Society Press. p.  75. ISBN   978-0-470-04212-0 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  a b Hamill, Paul 2004. Unit Test Frameworks Tools for High-Quality Software Development . OReilly Media, Inc.. ISBN   9780596552817 . Retrieved 3 June 2019 .  Xie, Tao . Towards a Framework for Differential Unit Testing of Object-Oriented Programs PDF . Retrieved 23 July 2012 .  Fowler, Martin 2 January 2007. Mocks arent Stubs . Retrieved 1 April 2008 .  Getting Started with xUnit.net desktop .  Theories .  Parameterized tests .  Boehm, Barry W.  Papaccio, Philip N. October 1988. Understanding and Controlling Software Costs PDF . IEEE Transactions on Software Engineering . 14 10 14621477. doi  10.110932.6191 . Retrieved 13 May 2016 .  Test Early and Often . Microsoft.  Prove It Works Using the Unit Test Framework for Software Testing and Validation . National Instruments . 21 August 2017.  Cramblitt, Bob 20 September 2007. Alberto Savoia sings the praises of software testing . Retrieved 29 November 2007 .  Brooks, Frederick J. 1995 1975. The Mythical Man-Month . Addison-Wesley. p.  64. ISBN   978-0-201-83595-3 .  Kolawa, Adam 1 July 2009. Unit Testing Best Practices . Retrieved 23 July 2012 .  daVeiga, Nada 6 February 2008. Change Code Without Fear Utilize a regression safety net . Retrieved 8 February 2008 .  Kucharski, Marek 23 November 2011. Making Unit Testing Practical for Embedded Development . Retrieved 8 May 2012 .  httpwiki.c2.comUnitTestsAndDatabases  Agile Emergent Design . Agile Sherpa. 3 August 2010. Archived from the original on 22 March 2012 . Retrieved 8 May 2012 . Cite uses deprecated parameter deadurl  help   Bullseye Testing Technology 20062008. Intermediate Coverage Goals . Retrieved 24 March 2009 .  Crystal Spec . crystal-lang.org . Retrieved 18 September 2017 .  Unit Tests - D Programming Language . D Programming Language . D Language Foundation . Retrieved 5 August 2017 .  testing - The Go Programming Language . golang.org . Retrieved 3 December 2013 .  Python Documentation 2016. unittest -- Unit testing framework . Retrieved 18 April 2016 .  Welsh, Noel Culpepper, Ryan. RackUnit Unit Testing . PLT Design Inc . Retrieved 26 February 2019 .  Welsh, Noel Culpepper, Ryan. RackUnit Unit Testing package part of Racket main distribution . PLT Design Inc . Retrieved 26 February 2019 .  Minitest Ruby 2.0 . Ruby-Doc.org.  The Rust Project Developers 20112014. The Rust Testing Guide Rust 0.12.0-pre-nightly . Retrieved 12 August 2014 .  Sierra, Stuart. API for clojure.test - Clojure v1.6 stable . Retrieved 11 February 2015 .  Pester Framework . Retrieved 28 January 2016 . External links  edit  Test Driven Development Ward Cunninghams Wiki Retrieved from  httpsen.wikipedia.orgwindex.phptitleUnit_testing oldid908218502  Categories  Extreme programming Software testing Unit testing Types of tools used in software development Hidden categories CS1 errors deprecated parameters Articles with short description Articles needing additional references from November 2007 All articles needing additional references Use dmy dates from January 2011 All articles with unsourced statements Articles with unsourced statements from January 2013 Articles with unsourced statements from October 2010 Articles with unsourced statements from January 2010 All articles lacking reliable references Articles lacking reliable references from February 2019 Articles with unsourced statements from November 2008 Articles with example Java code