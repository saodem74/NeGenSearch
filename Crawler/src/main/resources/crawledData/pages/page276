Universal Systems Language From Wikipedia, the free encyclopedia Jump to navigation Jump to search Universal Systems Language  USL  is a modeling language and formal method for the specification and design of software and other complex systems. It was designed by Margaret Hamilton based on her experiences writing flight software for the Apollo program . 1  The language is implemented through the 001 Tool Suite software by Hamilton Technologies, Inc. 2  USL evolved from 001AXES which in turn evolved from AXES all of which are based on Hamiltons axioms of control. The 001 Tool Suite uses the preventative concept of Development Before the Fact DBTF for its life-cycle development process. DBTF eliminates errors as early as possible during the development process removing the need to look for errors after-the-fact. Contents 1 Philosophy 2 Formalism for a theory of control 3 Implementation 4 See also 5 References 6 Further reading 7 External links Philosophy  edit  USL was inspired by Hamiltons recognition of patterns or categories of errors occurring during Apollo software development. Errors at the interfaces between subsystem boundaries accounted for the majority of errors and were often the most subtle and most difficult to find. Each interface error was placed into a category identifying the means to prevent it by way of system defi nition. This process led to a set of six axioms, forming the basis for a mathematical constructive logical theory of control for designing systems that would eliminate entire classes of errors just by the way a system is defined. 3  Certain correctness guarantees are embedded in the USL grammar. In contrast to reactive approaches to program verification, testing for errors late into the life cycle, USLs development-before-the-fact philosophy is preventive, not allowing errors in the first place. A USL definition models both its application for example, an avionics or banking system and properties of con trol into its own life cycle. 4  Providing a mathematical framework within which objects, their interactions, and their relationships can be captured, USL  a metalanguage  has metamechanisms for defining systems. USLs philosophy is that all objects are recursively reusable and reliable reliable systems are defined in terms of reliable systems only reliable systems are used as building blocks and only reliable systems are used as mechanisms to integrate these building blocks to form a new system. Designers can then use the new system, along with more primitive ones, to define and build more comprehensive reliable systems. If a system is reliable, all the objects in all its levels and layers are reliable. USL is regarded by some users as more user-friendly than other formal systems. 5  It is not only a formalism for software, but also defines ontologies for common elements of problem domains, such as physical space and event timing. Formalism for a theory of control  edit  This section contains close paraphrasing of a non-free copyrighted source, httpwww.htius.comArticlesr12ham.pdf  Duplication Detector report  . Relevant discussion may be found on the talk page . Ideas in this article should be expressed in an original manner.  July 2016   Learn how and when to remove this template message  A systems philosophy formalism for representing the logic of the control of systems, USL is based on a set of axioms of a general systems control theory with formal rules for its application. At the base of every USL system is a set of six axioms and the assumption of a universal set of objects. 6  7  The axioms provide the formal foundation for a USL hierarchy  referred to as a map, which is a tree of control that spans networks of relations between objects. Explicit rules for defining a map have been derived from the axioms, where  among other things  structure, behavior, and their integration are captured. Each axiom defines a relation of immediate domination of a p arent over its children. The union of these relations is control. Among other things, the axioms establish the relationships of an object for invocation in time and space, input and output domain and codomain, input access rights and output access rights domain access rights and codomain access rights, error detection and recovery, and ordering during its developmental and operational states. Every system can ultimately be defined in terms of three primitive control structures, each of which is derived from the six axioms  resulting in a universal semantics for defining systems. All representations of a system are defined in terms of a function map FMap and a type map TMap. With USL, all functions in a system and their relationships are defined with a set of FMaps. Similarly, all types in a system and their relationships are defined with a set of TMaps. FMaps represent the dynamic doing world of action by capturing functional and temporal includ ing priority characteristics. TMaps represent the static being world of objects by capturing spatial characteristics  for example, containment of one object by another or relationships between locations of objects in space. FMaps are inherently integrated with TMaps. Three universal primitive structures derived from the set of axioms and non-primitive structures derived ult imately in terms of the primitive structures specify each map. Primitive structures are universal in that they are able to be used to derive new abstract universal structures, functions or types. The process of deriving new objects i.e., structures, types and functions is equivalent to the process of deriving new types in a constructive type theory. Primitive functions, corre sponding to primitive operations on types defined in a TMap, reside at the bottom nodes of an FMap. Primitive types, each defined by its own set of axioms, reside at the bottom nodes of a TMap. Each primitive function or type can be realized as a top node of a map on a lower more concrete layer of the system. Resident at every node on a map is the same kind of object for e xample, a function on every node of an FMap and a type on a TMap. The object at each node plays multiple roles for example, the object can serve as a parent in control of its children or a child being controlled by its parent. Whereas each function on an FMap has a mapping from its input to output domain to codomain, each type on a TMap has a relation between its domain and codomain. A structure relates each parent and its children according to the set of rules derived from the axioms of control. A primitive structure provides a relationship of the most primitive form finest grain of control. All maps are defined ultimately in terms of the primitive structures and therefore abide by the rules associated with each structur e A parent controls its children to have a dependent Join, independent Include, or decision-making relationship Or. Figure. 1 The three primitive control structures and their rules form a universal foundation for constructing maps in the domains of time and space as FMaps and TMaps Any system can be defined completely using only primitive structures, but less primitive structures defined by and derived from the primitive structures  and therefore governed by the control axioms  accelerate the definition and understanding of a system. The defined structure, a form of template-like reuse, provides a mechanism to define a map without explicitly defining so me of its elements. An FMap structure has placeholders for variable functions a TMap structure has placeholders for variable types a universal structure has placeholders for functions or types. Async is an example of a real-time, distributed, communicating FMap structure with both asynchronous and synchronous behavior. An example of a TMap structure is TreeOf, a collection of the same type of objects ordered using a tree indexing system. Each TMap structure assumes its own set of possible relations for its parent and children types. Abstract types decomposed with the same TMap structure inherit the same primitive operations and therefore the same behavior each of which is available to FMaps that have access to members of each of its TMaps types. Implementation  edit  The process of developing a software system with USL together with its automation, the 001 Tool Suite 001, is as follows define the system with USL, automatically analyze the definition with 001s analyzer to ensure that USL was used correctly, automatically generate much of the design and all of the implementation code with 001s generator. 8  9  10  11  USL can be used to lend its formal support to other languages. 12  See also  edit  Systems Philosophy IDEF Model Driven Architecture SysML Object Process Methodology References  edit   M. Hamilton and W.  R. Hackler,  Universal Systems Language Lessons Learned from Apollo , IEEE Computer, Dec. 2008.  001 Tool Suite 1986-2016  Margaret H. Hamilton, Hamilton Technologies September 27, 2012.   Universal Systems Language and its Automation, the 001 Tool Suite, for Designing and Building Systems and Software Lockheed MartinIEEE Computer Society Webinar Series . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Dolha, Steve, Chiste, Dave, A Remote Query System for the Web Managing the Development of Distributed Systems., Chapter 32, Internet Management, Editor Jessica Keyes, Auerbach, 2000.  Krut, Jr., B.,  Integrating 001 Tool Support in the Feature-Oriented Domain Analysis Methodology  CMUSEI-93-TR-11, ESC-TR-93-188, Pittsburgh, SEI, Carnegie Mellon University, 1993.  Hamilton, M. ,  Inside Development Before the Fact , cover story, Special Editorial Supplement, 8ES-24ES. Electronic Design, Apr. 1994.  Hamilton, M. ,  001 A FULL LIFE CYCLE SYSTEMS ENGINEERING AND SOFTWARE DEVELOPMENT ENVIRONMENT Development Before The Fact In Action , cover story, Special Editorial Supplement, 8ES-24ES. Electronic Design, Apr. 1994.  Ouyang, M., Golay, M.W. 1995, An Integrated Formal Approach for Developing High Quality Software of Safety-Critical Systems , Massachusetts Institute of Technology, Cambridge, Massachusetts, Report No. MIT-ANP-TR-035.  Software Productivity Consortium, SPC 1998, Object-Oriented Methods and Tools Survey , Herndon, VA.SPC-98022-MC, Version 02.00.02, December 1998.  Max Schindler 1990 Computer Aided Software Design , John Wiley  Sons, 1990.   Department of Defense 1992. Software engineering tools experiment-Final report , Vol. 1, Experiment Summary, Table 1, p.  9. Strategic Defense Initiative, Washington, D.C.  Hamilton, M. Hackler, W.R.,  A Formal Universal Systems Semantics for SysML , 17th Annual International Symposium, INCOSE 2007, San Diego, CA, June 2007. Further reading  edit  Hamilton, M. , Zeldin, S. 1976, Higher Order Software   A Methodology for Defining Software, IEEE Transactions on Software Engineering, vol. SE-2, no. 1, Mar. 1976. Hamilton, M. , Hackler, W.R.. 2004, Deeply Integrated Guidance Navigation Unit DI-GNU Common Software Architecture Principles revised dec-29-04, DAAAE30-02-D-1020 and DAAB07-98-D-H5020180, Picatinny Arsenal, NJ, 2003-2004. Hamilton, M. and Hackler, W.R. 2007,  Universal Systems Language for Preventative Systems Engineering , Proc. 5th Ann. Conf. Systems Eng. Res. CSER, Stevens Institute of Technology, Mar. 2007, paper 36. External links  edit  Wikimedia Commons has media related to Universal Systems Language . Hamilton Technologies Retrieved from  httpsen.wikipedia.orgwindex.phptitleUniversal_Systems_Language oldid874095673  Categories  Formal specification languages Systems engineering Modeling languages Hidden categories Articles needing cleanup from July 2016 All pages needing cleanup Articles with close paraphrasing from July 2016 All articles with close paraphrasing Commons category link from Wikidata