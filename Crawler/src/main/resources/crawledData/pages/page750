Burroughs large systems From Wikipedia, the free encyclopedia Jump to navigation Jump to search In the 1970s, Burroughs Corporation was organized into three divisions with very different product line architectures for high-end, mid-range, and entry-level business computer systems. Each divisions product line grew from a different concept for how to optimize a computers instruction set for particular programming languages. The Burroughs Large Systems Group designed large mainframes using stack machine instruction sets with dense syllables NB 1  and 48-bit data words. The first such design is the B5000 in 1961. It is optimized for running ALGOL 60 extremely well, using simple compilers. It evolved into the B5500. Subsequent major redesigns include the B6500B6700 line and its successors, and the separate B8500 line. Burroughs Large Systems referred to all of these product lines together, in contrast to the COBOL -optimized Medium Systems B2000, B3000, B4000 or the flexible-architecture Small Systems B1000. Founded in the 1880s, Burroughs was the oldest continuously operating entity in computing, but by the late 1950s its computing equipment was still limited to electromechanical accounting machines such as the Sensimatic  as such it had nothing to compete with its traditional rivals IBM and NCR , who had started to produce larger-scale computers, or with recently founded Univac . While in 1956 it branded as the B205 a machine produced by a company it bought, its first internally developed machine, the B5000, was designed in 1961 and Burroughs sought to address its late entry in the market with the strategy of a completely different design based on the most advanced computing ideas available at the time. While the B5000 architecture is dead, it inspire d the B6500 and subsequent B6700 and B7700. Computers using that architecture are still in production as the Unisys ClearPath Libra servers which run an evolved but compatible version of the MCP operating system first introduced with the B6700. The third and largest line, the B8500, 1  2  had no commercial success. In addition to a proprietary CMOS processor design, Unisys also uses Intel Xeon processors and runs MCP , Microsoft Windows and Linux operating systems on their Libra servers the use of custom chips was gradually eliminated, and by 2018 the Libra servers had been strictly commodity Intel for some years. Figure 4.5 From the ACM Monograph in the References. Elliot Organick 1973. Contents 1 B5000 1.1 Unique features 1.1.1 Unique system design 1.1.2 Language support 2 B6500 3 B8500 4 History 5 Primary lines of hardware 6 ALGOL 6.1 ESPOL and NEWP 6.2 DCALGOL and Message Control Systems MCS 6.3 DMALGOL and databases 7 Stack architecture 7.1 Stack speed and performance 7.2 How programs map to the stack 7.3 Procedures 7.3.1 Run invocation type 7.3.2 Inline procedures 7.3.3 Asynchronous calls 7.3.4 Display registers 7.3.5 Array storage 7.4 Stack structure advantages 8 Tagged architecture 9 Descriptor-based architecture 10 Instruction set 11 Multiple processors 12 Influence of the B5000 13 See also 14 Notes 15 References 16 Further reading 17 External links B5000  edit  The first member of the first series, the B5000, 3  was designed beginning in 1961 by a team under the leadership of Robert Bob Barton . It was a unique machine, well ahead of its time. It has been listed by the influential computing scientist John Mashey as one of the architectures that he admires the most. I always thought it was one of the most innovative examples of combined hardwaresoftware design Ive seen, and far ahead of its time. 4  The B5000 was succeeded by the B5500 5  which used disks rather than drum storage and the B5700 which allowed multiple CPUs to be clustered around shared disk. While there was no successor to the B5700, the B5000 line heavily influenced the design of the B6500, and Burroughs ported the Master Control Program  MCP  to that machine. Unique features  edit  All code automatically reentrant fig 4.5 from the ACM Monograph shows in a nutshell why programmers dont have to do anything more to have any code in any language spread across processors than to use just the two shown simple primitives. This is perhaps the canonical but no means the only benefit of these major distinguishing features of this architecture Partially data-driven tagged and descriptor -based design Hardware was designed to support software requirements Hardware designed to exclusively support high-level programming languages No Assembly language or assembler all system software written in an extended variety of ALGOL 60 . However, ESPOL had statements for each of the syllables in the architecture. Few programmer accessible registers Simplified instruction set Stack architecture to support high-level algorithmic languages Support for high-level operating system MCP, Master Control Program  Support for asymmetric masterslave multiprocessing Support for other languages such as COBOL Powerful string manipulation An attempt at a secure architecture prohibiting unauthorized access of data or disruptions to operations NB 2  Early error-detection supporting development and testing of software First commercial implementation of virtual memory NB 3  Successors still exist in the Unisys ClearPathMCP machines Influenced many of todays computing techniques In the following discussion, the machine designations, B5000, A Series, and ClearPathMCP are used interchangeably although this needlessly conflates the features and concepts of the B5000 and B8500 lines with the B6500 line. Unique system design  edit  The B5000 was revolutionary at the time in that the architecture and instruction set were designed with the needs of software taken into consideration. This was a large departure from the computer system design of the time, where a processor and its instruction set would be designed and then handed over to the software people, and is still. That is, most other instruction sets, such as the IBM System360 instruction set of that era, and later instruction set designs such as the x86 , PPC , and ARM instruction set architectures, are essentially traditional instruction set based architectures rather than holistic designs like the original Burroughs systems. The B5000, B5500 and B5700 in Word Mode has two different addressing modes, depending on whether it is executing a main program SALF off or a subroutine SALF on. For a main program, the T field of an Operand Call or Descriptor Call syllable is relative to the Program Reference Table PRT. For subroutines, the type of addressing is dependent on the high three bits of T and on the Mark Stack FlipFlop MSFF, as shown in B5x00 Relative Addressing . B5x00 Relative Addressing 6  SALF a  T0 A38 T1 A39 T2 A40 MSFF b  Base Contents Index Sign Index Bits c  Max Index OFF - - - - R Address of PRT  T 0-9 A 38-47 1023 ON OFF - - - R Address of PRT  T 1-9 A 39-47 511 ON ON OFF - OFF F Address of last RCW d  or MSCW e  on stack  T 2-9 A 40-47 255 ON ON OFF - ON R7 f  F register from MSCW e  at PRT7  T 2-9 A 40-47 255 ON ON ON OFF - C g  Address of current instruction word  T 3-9 A 41-47 127 ON ON ON ON OFF F Address of last RCW d  or MSCW e  on stack - T 3-9 A 41-47 127 ON ON ON ON ON R7 f  F register from MSCW e  at PRT7 - T 3-9 A 41-47 127 Notes  SALF Subroutine Level Flipflop  MSFF Mark Stack FlipFlop  For Operand Call OPDC and Descriptor Call DESC syllables, the relative address is bits 0-9 T register of the syllable. For Store operators CID, CND, ISD, ISN, STD, STN, the A register top of stack contains an absolute address if the Flag bit is set and a relative address if the Flag bit is off.  a b RCW   Return Control Word  a b c d MSCW Mark Stack Control Word  a b F register from MSCW at PRT7  C current instruction word-relative forced to R PRT-relative for Store, Program and IO Release operators Language support  edit  The B5000 was designed to exclusively support high-level languages. This was at a time when such languages were just coming to prominence with FORTRAN and then COBOL . FORTRAN and COBOL were considered weaker languages by some, when it comes to modern software techniques, so a newer, mostly untried language was adopted, ALGOL-60 . The ALGOL dialect chosen for the B5000 was Elliott ALGOL , first designed and implemented by C.A.R. Hoare on an Elliott 503 . This was a practical extension of ALGOL with IO instructions which ALGOL had ignored and powerful string processing instructions. Hoares famous Turing Award lecture was on this subject. Thus the B5000 was based on a very powerful language. Most other vendors could only dream of implementing an ALGOL compiler  dubious  discuss  and most in the industry dismissed ALGOL as being unimplementable.  citation needed  However, a bright young student named Donald Knuth had previously implemented ALGOL 58 on an earlier Burroughs machine during the three months of his summer break, and he was peripherally involved in the B5000 design as a consultant. Many wrote ALGOL off, mistakenly believing that high-level languages could not have the same power as assembler, and thus not realizing ALGOLs potential as a systems programming language. The Burroughs ALGOL compiler was very fast  this impressed the Dutch scientist Edsger Dijkstra when he submitted a program to be compiled at the B5000 Pasadena plant. His deck of cards was compiled almost immediately and he immediately wanted several machines for his university, Eindhoven University of Technology in the Netherlands. The compiler was fast for several reasons, but the primary reason was that it was a one-pass compiler . Early computers did not have enough memory to store the source code, so compilers and even assemblers usually needed to read the source code more than once. The Burroughs ALGOL syntax, unlike the official language, requires that each variable or other object be declared before it is used, so it is feasible to write an ALGOL compiler that reads the data only once. This con cept has profound theoretical implications, but it also permits very fast compiling. Burroughs large systems could compile as fast as they could read the source code from the punched cards , and they had the fastest card readers in the industry. The powerful Burroughs COBOL compiler was also a one-pass compiler and equally fast. A 4000-card COBOL program compiled as fast as the 1000-cardminute readers could read the code. The program was ready to use as soon as the cards went through the reader. B6500  edit  See also Burroughs B6x00-7x00 instruction set The B6500 7  delivery in 1969 8  9   and B7500 were the first computers in the only line of Burroughs systems to survive to the present day. While they were inspired by the B5000, they had a totally new architecture. Among the most important differences were The B6500 had variable length instructions with an 8-bit syllable instead of fixed length instructions with a 12-bit syllable . The B6500 had a 51-bit NB 4  instead of a 48-bit word, and used 3 bits as a tag The B6500 had Symmetric Multiprocessing SMP The B6500 had a Saguaro stack The B6500 had paged arrays The B6500 had Display Registers, D1 thru D32 to allow nested subroutines to access variables in outer blocks. The B6500 used monolithic integrated circuits with magnetic thin-film memory . 8  B8500  edit  The B8500 1  2  line derives from the D825, 10  a military computer that was inspired by the B5000. The B8500 was designed in the 1960s as an attempt to merge the B5500 and the D825 designs. The system used monolithic integrated circuits with magnetic thin-film memory . The architecture employed a 48-bit word, stack, and descriptors like the B5500, but was not advertised as being upward-compatible. 1  The B8500 could never be gotten to work reliably, and the project was canceled after 1970, never having delivered a completed system. 2  History  edit  This section needs expansion . You can help by adding to it .  June 2008  In the following discussion, the machine designations, B5000, A Series, and ClearPathMCP are used interchangeably although this needlessly conflates the features and concepts of the B5000 and B8500 lines with the B6500 line. The first of the Burroughs large systems was the B5000. Designed in 1961, it was a second-generation computer using discrete transistor logic and magnetic core memory . The first machines to replace the B5000 architecture were the B6500 and B7500. The successor machines followed the hardware development trends to re-implement the architectures in new logic over the next 25 years, with the B5500, B6500, B5700, B6700, B7700, B6800, B7800, and finally the Burroughs A series. After a merger in which Burroughs acquired Sperry Corporation and changed its name to Unisys , the company continued to develop new machines based on the MCP CMOS ASIC . These machines were the Libra 100 through the Libra 500, With the Libra 590 being announced in 2005. Later Libras, including the 590, also incorporate Intel Xeon processors and can run the Burroughs large systems architecture in emulation as well as on the MCP CMOS processors. It is unclear if Unisys will continue development of new MCP CMOS ASICs. Burroughs 19611986 B5000 1961 initial system, 2nd generation transistor computer B5500 1964 3x speed improvement 2  B6500 1969 3rd generation computer integrated circuits, up to 4 processors B5700 1971 new name for B5500  disputed  discuss  B6700 1971 new namebug fix for B6500  disputed  discuss  B7700 1972 faster processor, cache for stack, up to 8 requestors IO or Central processors in one or two partitions. B6800 1977 semiconductor memory, NUMA architecture B7800 1977 semiconductor memory, faster, up to 8 requestors IO or Central processors in one or two partitions. B5900 1980 semiconductor memory, NUMA architecture. Max of 4 B5900 CPUs bound to a local memory and a common Global Memory II tm B6900 1979 semiconductor memory, NUMA architecture. Max of 4 B6900 CPUs bound to a local memory and a common Global Memorytm B7900 1982 semiconductor memory, faster, code  data caches, NUMA architecture, 1-2 HDUs IO, 1-2 APs, 1-4 CPUs, Soft implementation of NUMA memory allowed CPUs to float from memory space to memory space. A9A10 1984 B6000 class, First pipelined processor in the mid-range, single CPU dual on A10, First to support eMode Beta expanded Memory Addressing A12A15 1985 B7000 class, Re-implemented in custom-designed Motorola ECL MCA1, then MCA2 gate arrays , single CPU single HDU A12 14 CPU, 12 HDU A15 Unisys 1986present Micro A 1989 desktop mainframe with single-chip SCAMP 11  12  processor. Clearpath HMP NX 4000 198  Clearpath HMP NX 5000 199  Clearpath HMP LX 5000 1998 Implements Burroughs Large systems in emulation only  Xeon processors 13  Libra 100 2002  Libra 200 200  Libra 300 200  Libra 400 200  Libra 500 2005 e.g. Libra 595 14  Libra 600 2006  Libra 700 2010 e.g. Libra 750 15  Primary lines of hardware  edit  Hardware and software design, development, and manufacturing were split between two primary locations, in Orange County, California , and the outskirts of Philadelphia . The initial Large Systems Plant, which developed the B5000 and B5500, was located in Pasadena, California but moved to City of Industry, California , where it developed the B6500. The Orange County location, which was based in a plant in Mission Viejo, California but at times included facilities in nearby Irvine and Lake Forest , was responsible for the smaller B6x00 line, while the East Coast operations, based in Tredyffrin, Pennsylvania , handled the larger B7x00 line. All machines from both lines were fully object-compatible, meaning a program compiled on one could be executed on another. Newer and larger models had instructions which were not supported on older and slower models, but the hardware, when encountering an unrecognized instruction, invoked an operating system function which interpreted it. Oth er differences include how process switching and IO were handled, and maintenance and cold-starting functionality. Larger systems included hardware process scheduling and more capable inputoutput modules, and more highly functional maintenance processors. When the Bxx00 models were replaced by the A Series models, the differences were retained but no longer readily identifi able by model number. ALGOL  edit  Main article ALGOL The Burroughs large systems implement an ALGOL-derived stack architecture , unlike linear architectures such as PDP-11 , Motorola M68k , and Itanium or segmented architectures such as x86 and Texas Instruments . This refers to the layout of the memory and how a program uses it. While B5000 was specifically designed to support ALGOL, this was only a starting point. Other business-oriented languages such as COBOL were also well supported, most notably by the powerful string operators which were included for the development of fast compilers. The ALGOL used on the B5000 is an extended ALGOL subset. It includes powerful string manipulation instructions but excludes certain ALGOL constructs, notably unspecified formal parameters. A DEFINE mechanism serves a similar purpose to the defines found in C, but is fully integrated into the language rather than being a preprocessor. The EVENT data type facilitates coordination between processes, and ON FAULT blocks enable handling program faults. The user level of ALGOL does not include many of the insecure constructs needed by the operating system and other system software. Two levels of language extensions provide the additional constructs ESPOL and NEWP for writing the MCP and closely related software, and DCALGOL and DMALGOL to provide more specific extensions for specific kinds of system software. ESPOL and NEWP  edit  Originally, the B5000 MCP operating system was written in an extension of extended ALGOL called ESPOL Executive Systems Programming Oriented Language. This was replaced in the mid-to-late 70s by a language called NEWP . Though NEWP probably just meant New Programming language, legends surround the name. A common perhaps apocryphal story within Burroughs at the time suggested it came from  No Executive Washroom Privileges . Another story is that circa 1976, John McClintock of Burroughs the software engineer developing NEWP named the language NEWP after being asked, yet again, does it have a name yet answering nyoooop, he adopted that as a name. NEWP, too, was a subset ALGOL extension, but it was more secure than ESPOL, and dropped some little-used complexities of ALGOL. In fact, all un safe constructs are rejected by the NEWP compiler unless a block is specifically marked to allow those instructions. Such marking of blocks provide a multi-level protection mechanism. NEWP programs that contain unsafe constructs are initially non-executable. The security administrator of a system is able to bless such programs and make them executable, but normal users are not able to do this. Even privileged users, who normally have essentially root privilege, may be unable to do this depending on the configuration chosen by the site. While NEWP can b e used to write general programs and has a number of features designed for large software projects, it does not support everything ALGOL does. NEWP has a number of facilities to enable large-scale software projects, such as the operating system, including named interfaces functions and data, groups of interfaces, modules, and super-modules. Modules group data and functions together, allowing easy access to the data as global within the module. Interfaces allow a module to import and export functions and data. Super- modules allow modules to be grouped. DCALGOL and Message Control Systems MCS  edit  The second intermediate level of security between operating system code in NEWP and user programs in ALGOL is for middleware programs, which are written in DCALGOL data comms ALGOL. This is used for message reception and dispatching which remove messages from input queues and places them on queues for other processes in the system to handle. Middleware such as COMS introduced around 1984 receive messages from around the network and dispatch these messages to specific handling processes or to an MCS Message Control System such as CANDE  C ommand AND E dit, the program development environment. MCSs are items of software worth noting  they control user sessions and provide keeping track of user state without having to run per-user processes since a single MCS stack can be shared by many users. Load balancing can also be achieved at the MCS level. For example, saying that you want to handle 30 users per stack, in which case if you have 31 to 60 users, you have two sta cks, 61 to 90 users, three stacks, etc. This gives B5000 machines a great performance advantage in a server since you dont need to start up another user process and thus create a new stack each time a user attaches to the system. Thus you can efficiently service users whether they require state or not with MCSs. MCSs also provide the backbone of large-scale transaction proce ssing. The MCS talked with an external co-processor, the DCP Datacomm Control Processor. This was a 24-bit minicomputer with a conventional register architecture and hardware IO capability to handle thousands of remote terminals. The DCP and the B6500 communicated by messages in memory, essentially packets in todays terms, and the MCS did the B6500-side processing of those message s. In the early years the DCP did have an assembler Dacoma, an application program called DCPProgen written in B6500 ALGOL. Later the NDL Network Definition Language compiler generated the DCP code and NDF network definition file. There was one ALGOL function for each kind of DCP instruction, and if you called that function then the corresponding DCP instruction bits would be emitted to the output. A DCP program was an ALGOL program comprising nothing but a long list of calls on these functions, one for each assembly language statement. Essentially ALGOL acted like the macro pass of a macro assembler. The first pass was the ALGOL compiler the second pass was running the resulting program on the B6500 which would then emit the binary for the DCP. DMALGOL and databases  edit  Another variant of ALGOL is DMALGOL Data Management ALGOL. DMALGOL is ALGOL extended for compiling the DMSII database software from database description files created by the DASDL Data Access and Structure Definition Language compiler. Database designers and administrators compile database descriptions to generate DMALGOL code tailored for the tables and indexes specified. Administrators never need to write DMALGOL themselves. Normal user-level programs obtain database access by using code written in application languages, mainly ALGOL and COBOL, extended with database instructions and transaction processing directives. The most notable feature of DMALGOL is its preprocessing mechanisms to generate code for handling tables and indices. DMALGOL preprocessing includes variables and loops, and can generate names based on compile-time variables. This enables tailoring far beyond what can be done by preprocessing facilities which lack loops. DMALGOL is used to provide tailored access routines for DMSII databases. After a database is defined using the Data Access and Structure Definition Language DASDL, the schema is translated by the preprocessor into tailored DMALGOL access routines and then compiled. This means that, unlike in other DBMS implementations, there is often no need for database-specific ifthenelse code at run-time. In the 1970s, this tailoring was used ve ry extensively to reduce the code footprint and execution time. It became much less used in later years, partly because low-level fine tuning for memory and speed became less critical, and partly because eliminating the preprocessing made coding simpler and thus enabled more important optimizations. DMALGOL included verbs like find, lock, store. Also the verbs begintrans action and endtransaction were included, solving the deadlock situation when multiple processes accessed and updated the same structures. Roy Guck of Burroughs was one of the main developers of DMSII . In later years, with compiler code size being less of a concern, most of the preprocessing constructs were made available in the user level of ALGOL. Only the unsafe constructs and the direct processing of the database description file remain restricted to DMALGOL. Stack architecture  edit  In many early systems and languages, programmers were often told not to make their routines too small. Procedure calls and returns were expensive, because a number of operations had to be performed to maintain the stack. The B5000 was designed as a stack machine  all program data except for arrays which include strings and objects was kept on the stack. This meant that stac k operations were optimized for efficiency. As a stack-oriented machine, there are no programmer addressable registers. Multitasking is also very efficient on B5000 machines. There is one specific instruction to perform process switches  MVST move stack. 16  Each stack represents a process task or thread and tasks can become blocked waiting on resource requests which includes waiting for a processor to run on if the task has been interrupted because of preemptive multitasking. User programs cannot issue an MVST, and there is only one line of code in the operating system where this is done. So a process switch proceeds something like this  a process requests a resource that is not immediately available, maybe a read of a record of a file from a block which is not currently in memory, or the system timer has triggered an interrupt. The operating system code is entered and run on top of the user stack. It turns off user process timers. The current process is placed in the appropriate queue for the resource being requested, or the ready queue waiting for the processor if this is a preemptive context switch. The operating system determines the first process in the ready queue and invokes the instruction move_stack, which makes the process at the head of the ready queue active. Stack speed and performance  edit  Some of the detractors of the B5000 architecture believed that stack architecture was inherently slow compared to register-based architectures. The trick to system speed is to keep data as close to the processor as possible. In the B5000 stack, this was done by assigning the top two positions of the stack to two registers A and B. Most operations are performed on those two top of stack positions. On faster machines past the B5000, more of the stack may be kept in registers or cache near the processor. Thus the designers of the current successors to the B5000 systems can optimize in whatever is the latest technique, and programmers do not have to adjust their code for it to run faster  they do not even need to recompile, thus protecting software investment. Some programs have been known to run for years over many processor upgrades. Such speed up is limited on register-based machines.  citation needed  Another point for speed as promoted by the RISC designers was that processor speed is considerably faster if everything is on a single chip. It was a valid point in the 1970s when more complex architectures such as the B5000 required too many transistors to fit on a single chip. However, this is not the case today and every B5000 successor machine now fits on a single chip as w ell as the performance support techniques such as caches and instruction pipelines. In fact, the A Series line of B5000 successors included the first single chip mainframe, the Micro-A of the late 1980s. This mainframe chip named SCAMP for Single-Chip A-series Mainframe Processor sat on an Intel-based plug-in PC board. How programs map to the stack  edit  Here is an example of how programs map to the stack structure begin                                                        This is lexical level 2 level zero is reserved for the operating system and level 1 for code segments.                                                        At level 2 we place global variables f or our program. integer i , j , k  real f , g  array a 09 procedure p  real p1 , p2  value p1   p1 passed by value, p2 implicitly passed by reference. begin                    This block is at lexical level 3                   real r1 , r2  r2   p1  5  p2   r2   This sets g to the value of r2 p1   r2   This sets p1 to r2 , but not f  Since this overwrites the original value of f in p1 it might be a  coding mistake. Some few of ALGOLs successors therefore insist that  value parameters be read only  but most do not. if r2  10 then begin                              A variable declared here makes this lexical level 4                             integer n   The declaration of a variable makes this a block, which will invoke some  stack building code. Normally you wont declare variables here, in which  case this would be a compound statement, not a block. ...  sample stack is executing somewhere here. end  end  ..... p  f , g  end . Each stack frame corresponds to a lexical level in the current execution environment. As you can see, lexical level is the static textual nesting of a program, not the dynamic call nesting. The visibility rules of ALGOL, a language designed for single pass compilers, mean that only variables declared before the current position are visible at that part of the code, thus the req uirement for forward declarations. All variables declared in enclosing blocks are visible. Another case is that variables of the same name may be declared in inner blocks and these effectively hide the outer variables which become inaccessible. Lexical nesting is static, unrelated to execution nesting with recursion, etc. so it is very rare to find a procedure nested more than five levels deep, and it could be argued that such programs would be poorly structured. B5000 machines allow nesting of up to 32 levels. This could cause difficulty for some systems that generated Algol source as output tailored to solve some s pecial problem if the generation method frequently nested procedure within procedure. Procedures  edit  Procedures can be invoked in four ways  normal, call, process, and run. The normal invocation invokes a procedure in the normal way any language invokes a routine, by suspending the calling routine until the invoked procedure returns. The call mechanism invokes a procedure as a coroutine. Coroutines have partner tasks, where control is explicitly passed between the tasks by means of a CONTINUE instruction. These are synchronous processes. The process mechanism invokes a procedure as an asynchronous task and in this case a separate stack is set up starting at the lexical level of the processed procedure. As an asynchronous task, there is no control over exactly when control will be passed between the tasks, unlike coroutines. Note also that the processed procedure still has access to the enclosing environment and this is a very efficient IPC Inter Process Communication mechanism. Since two or more tasks now have access to common variables, the tasks must be synchronized to prevent race conditions, which is handled by the EVENT data type, where processes can WAIT on an event until they are caused by another cooperating process. EVENTs also allow for mutual exclusion synchronization through the P ROCURE and LIBERATE functions. If for any reason the child task dies, the calling task can continue  however, if the parent process dies, then all child processes are automatically terminated. On a machine with more than one processor, the processes may run simultaneously. This EVENT mechanism is a basic enabler for multiprocessing in addition to multitasking. Run invocation type  edit  The last invocation type is run . This runs a procedure as an independent task which can continue on after the originating process terminates. For this reason, the child process cannot access variables in the parents environment, and all parameters passed to the invoked procedure must be call-by-value. Thus Burroughs Extended ALGOL had some of the multi-processing and synchronization features of later languages like Ada . It made use of the support for asynchronous processes that was built into the hardware. Inline procedures  edit  One last possibility is that a procedure may be declared INLINE, that is when the compiler sees a reference to it the code for the procedure is generated inline to save the overhead of a procedure call this is best done for small pieces of code. Inline functions are similar to parameterized macros such as C defines, except you dont get the problems with parameters that you can with macros. This facility is available in NEWP. Asynchronous calls  edit  In the example program only normal calls are used, so all the information will be on a single stack. For asynchronous calls, the stack would be split into multiple stacks so that the processes share data but run asynchronously. Display registers  edit  A stack hardware optimization is the provision of D or display registers. These are registers that point to the start of each called stack frame. These registers are updated automatically as procedures are entered and exited and are not accessible by any software. There are 32 D registers, which is what limits to 32 levels of lexical nesting. Consider how we would access a lexical level 2 D2 global variable from lexical level 5 D5. Suppose the variable is 6 words away from the base of lexical level 2. It is thus represented by the address couple 2, 6. If we dont have D registers, we have to look at the control word at the base of the D5 frame, which points to the frame containing the D4 environment. W e then look at the control word at the base of this environment to find the D3 environment, and continue in this fashion until we have followed all the links back to the required lexical level. Note this is not the same path as the return path back through the procedures which have been called in order to get to this point. The architecture keeps both the data stack and the call stack in the same structure, but uses control words to tell them apart. As you can see, this is quite inefficient just to access a variable. With D registers, the D2 register points at the base of the lexical level 2 environment, and all we need to do to generate the address of the variable is to add its offset from the stack frame base to the frame base address in the D register. There is an efficient linked list search operator LLLU, which cou ld search the stack in the above fashion, but the D register approach is still going to be faster. With D registers, access to entities in outer and global environments is just as efficient as local variable access. D Tag Data  Address couple, Comments register  0  n  4, 1 The integer n declared on entry to a block, not a procedure -----------------------  D4 3  MSCW  4, 0 The Mark Stack Control Word containing the link to D3.   0  r2  3, 5 The real r2 -----------------------  0  r1  3, 4 The real r1 -----------------------  1  p2  3, 3 A SIRW reference to g at 2,6 -----------------------  0  p1  3, 2 The parameter p1 from value of f -----------------------  3  RCW  3, 1 A return control word -----------------------  D3 3  MSCW  3, 0 The Mark Stack Control Word containing the link to D2.   1  a  2, 7 The array a  ten word memory block -----------------------  0  g  2, 6 The real g -----------------------  0  f  2, 5 The real f -----------------------  0  k  2, 4 The integer k -----------------------  0  j  2, 3 The integer j -----------------------  0  i  2, 2 The integer i -----------------------  3  RCW  2, 1 A return control word -----------------------  D2 3  MSCW  2, 0 The Mark Stack Control Word containing the link to the previous stack frame.   Stack bottom If we had invoked the procedure p as a coroutine, or a process instruction, the D3 environment would have become a separate D3-based stack. Note that this means that asynchronous processes still have access to the D2 environment as implied in ALGOL program code. Taking this one step further, a totally different program could call another programs code, creating a D3 st ack frame pointing to another process D2 environment on top of its own process stack. At an instant the whole address space from the codes execution environment changes, making the D2 environment on the own process stack not directly addressable and instead make the D2 environment in another process stack directly addressable. This is how library calls are implemented. At such a cross-stack call, the calling code and called code could even originate from programs written in different source languages and be compiled by different compilers. Note that the D1 and D0 environments do not occur in the current processs stack. The D1 environment is the code segment dictionary, which is shared by all processes running the same code. The D0 environment represents entities exported by the operating system. Stack frames actually dont even have to exist in a process stack. This feature was used early on for file IO optimization, the FIB file information block was linked into the display registers at D1 during IO operations. In the early nineties, this ability was implemented as a language feature as STRUCTURE BLOCKs and  combined with library technology - as CONNECTION BLOCKs . The ability to link a data structure into the display register address scope implemented object orientation. Thus, the B5000 actually used a form of object orientation long before the term was ever used. On other systems, the compiler might build its symbol table in a similar manner, but eventually the storage requirements would be collated and the machine code would be written to use flat memory addresses of 16-bits or 32-bits or even 64-bits. These addresses might contain anything so that a write to the wrong address could damage anything. Instead, the two-part address scheme was implemented by the hardware. At each lexical level, variables were placed at displacements up from the base of the levels stack, typically occupying one word - double precision or complex variables would occupy two. Arrays were not stored in this area, only a one word descriptor for the array. Thus, at each lexical level the total storage requirement was not great dozens, hundreds or a few thousand in extreme cases, certainly not a count requiring 32-bits or more. And indeed, this was reflected in the form of the VALC instruction value call that loaded an operand onto the stack. This op-code was two b its long and the rest of the bytes bits were concatenated with the following byte to give a fourteen-bit addressing field. The code being executed would be at some lexical level, say six this meant that only lexical levels zero to six were valid, and so just three bits were needed to specify the lexical level desired. The address part of the VALC operation thus reserved just three bits for that purpose, with the remainder being available for referring to entities at that and lower levels. A deeply nested procedure thus at a high lexical level would have fewer bits available to identify entities, and so for level sixteen upwards their number was restricted. At the deepest nesting five bits would be needed to specify the choice of levels 031 thus leaving nine bits to identify 512 entities - not a severe constraint. This is much more compact than addressing entities by their literal memory address in a 32-bit addressing space. Further, only the VALC opcode loaded data opcodes for ADD, MULT and so forth did no addressing, working entirely on the top elements of the stack. Much more important is that this method meant that many errors available to systems employing flat addressing could not occur because they were simply unspeakable even at the machine code level. A task had no way to corrupt memory in use by another task, because it had no way to develop its address. Similarly, within a task, an array descriptor contained information on the arra ys bounds, and so any indexing operation was checked by the hardware put another way, each array formed its own address space. In any case, the tagging of all memory words provided a second level of protection a misdirected assignment of a value could only go to a data-holding location, not to one holding a pointer or an array descriptor, etc. and certainly not to a location holding machine code. Array storage  edit  Arrays were not stored contiguous in memory with other variables, they were each granted their own address space, which was located via the descriptor. The access mechanism was to calculate on the stack the index variable which therefore had the full integer range potential, not just fourteen bits and use it as the offset into the arrays address space, with bound checking pr ovided by the hardware. Should an arrays length exceed 1,024 words, the array would be segmented, and the index be converted into a segment index and an offset into the indexed segment. In ALGOLs case, a multidimensional array would employ multiple levels of such addressing. For a reference to Ai,j, the first index would be into an array of descriptors, one descriptor for e ach of the rows of A, which row would then be indexed with j as for a single-dimensional array, and so on for higher dimensions. Hardware checking against the known bounds of all the arrays indices would prevent erroneous indexing. FORTRAN however regards all multidimensional arrays as being equivalent to a single-dimensional array of the same size, and for a multidimensional array simple integer arithmetic is used to calculate the offset where element Ai,j,k would be found in that single sequence. The single-dimensional equivalent array, possibly segmented if large enough, would then be accessed in the same manner as a single-dimensional array in ALGOL. Although accessing outside this array would be prevented, a wrong value for one index combined with a suitably wrong value for another index might not result in a bounds violation of the single sequence array in other words, the indices were not checked individually. Because an arrays storage was not bounded on each side by storage for other items, it was easy for the system to resize an array - though changing the number of dimensions was precluded because compilers required all references to have the same number of dimensions. In ALGOLs case, this enabled the development of ragged arrays, rather than the usual fixed rectangular or higher dimension arrays. Thus in two dimensions, a ragged array would have rows that were of different sizes. For instance, given a large array A100,100 of mostly-zero values, a sparse array representation that was declared as SA100,0 could have each row resized to have exactly enough elements to hold only the non-zero values of A along that row. Because arrays larger than 1024 words were segmented but smaller arrays were not, on a system that was short of real memory, increasing the declared size of a collection of scratchpad arrays from 1,000 to say 1,050 could mean that the program would run with far less thrashing as only the smaller individual segments in use were needed in memory. Actual storage for an array seg ment would be allocated at run time only if an element in that segment were accessed, and all elements of a created segment would be initialised to zero. Not initialising an array to zero at the start therefore was encouraged by this, normally an unwise omission. Stack structure advantages  edit  One nice thing about the stack structure is that if a program does happen to fail, a stack dump is taken and it is very easy for a programmer to find out exactly what the state of a running program was. Compare that to core dumps and exchange packages of other systems. Another thing about the stack structure is that programs are implicitly recursive. FORTRAN was not expected to support recursion and perhaps one stumbling block to peoples understanding of how ALGOL was to be implemented was how to implement recursion. On the B5000, this was not a problem  in fact, they had the reverse problem, how to stop programs from being recursive. In th e end they didnt bother. The Burroughs FORTRAN compiler allowed recursive calls just as every other FORTRAN compiler does, but unlike many other computers, on a stack-based system the returns from such calls succeeded as well. This could have odd effects, as with a system for the formal manipulation of mathematical expressions whose central subroutines repeatedly invoked eac h other without ever returning large jobs were ended by stack overflow Thus Burroughs FORTRAN had better error checking than other contemporary implementation of FORTRAN.  citation needed  For instance, for subroutines and functions it checked that they were invoked with the correct number of parameters, as is normal for ALGOL-style compilers. On other computers, such mismatches were common causes of crashes. Similarly with the array-bound checking programs that had been used for years on other systems embarrassingly often would fail when run on a Burroughs sys tem. In fact, Burroughs became known for its superior compilers and implementation of languages, including the object-oriented Simula a superset of ALGOL, and Iverson , the designer of APL declared that the Burroughs implementation of APL was the best hed seen.  citation needed  John McCarthy , the language designer of LISP disagreed, since LISP was based on modifiable code  citation needed  , he did not like the unmodifiable code of the B5000  citation needed  , but most LISP implementations would run in an interpretive environment anyway. Note also that the storage required for the multiple processes came from the systems memory pool as needed. There was no need to do SYSGENs on Burroughs systems as with competing systems in order to preconfigure memory partitions in which to run tasks. Tagged architecture  edit  The most defining aspect of the B5000 is that it is a stack machine as treated above. However, two other very important features of the architecture is that it is tag-based and descriptor-based. In the original B5000, a flag bit in each control or numeric word NB 5  was set aside to identify the word as a control word or numeric word. This was partially a security mechanism to stop programs from being able to corrupt control words on the stack. Later, when the B6500 was designed, it was realized that the 1-bit control wordnumeric distinction was a powerful idea and this was extended to three bits outside of the 48 bit word into a tag. The data bits are bits 047 and the tag is in bits 4850. Bit 48 was the read-only bit, thus odd tags indicated control words that could not be written by a user-level program. Code wor ds were given tag 3. Here is a list of the tags and their function Tag Word kind Description 0 Data All kinds of user and system data text data and single precision numbers 2 Double Double Precision data 4 SIW Step Index word used in loops 6 Uninitialized data SCW Software Control Word used to cut back the stack 1 IRW Indirect Reference Word SIRW Stuffed Indirect Reference Word 3 Code Program code word MSCW Mark Stack Control Word RCW Return Control Word TOSCW Top of Stack Control Word SD Segment Descriptor 5 Descriptor Data block descriptors 7 PCW Program Control Word Note Internally, some of the machines had 60 bit words, with the extra bits being used for engineering purposes such as a Hamming code error-correction field, but these were never seen by programmers. Note The current incarnation of these machines, the Unisys ClearPath has extended tags further into a four bit tag. The microcode level that specified four bit tags was referred to as level Gamma. Even-tagged words are user data which can be modified by a user program as user state. Odd-tagged words are created and used directly by the hardware and represent a programs execution state. Since these words are created and consumed by specific instructions or the hardware, the exact format of these words can change between hardware implementation and user programs do not ne ed to be recompiled, since the same code stream will produce the same results, even though system word format may have changed. Tag 1 words represent on-stack data addresses. The normal IRW simply stores an address couple to data on the current stack. The SIRW references data on any stack by including a stack number in the address. Tag 5 words are descriptors, which are more fully described in the next section. Tag 5 words represent off-stack data addresses. Tag 7 is the program control word which describes a procedure entry point. When operators hit a PCW, the procedure is entered. The ENTR operator explicitly enters a procedure non-value-returning routine. Functions value-returning routines are implicitly entered by operators such as value call VALC. Note that global routines are stored in the D2 environment as SIRWs that point to a PCW stored in the code segment dictionary in the D1 environment. The D1 environment is not stored on the current stack because it can be referenced by all processes sharing this code. Thus code is reentrant and shared. Tag 3 represents code words themselves, which wont occur on the stack. Tag 3 is also used for the stack control words MSCW, RCW, TOSCW. Figure 9.2 From the ACM Monograph in the References. Elliot Organick 1973. Descriptor-based architecture  edit  The figure to the left shows how the Burroughs Large System architecture was fundamentally a hardware architecture for object-oriented programming , something that still doesnt exist in conventional architectures. Main article Burroughs large systems descriptors Instruction set  edit  Main article Burroughs large systems instruction set Multiple processors  edit  The B5000 line also were pioneers in having multiple processors connected together on a high-speed bus. The B7000 line could have up to eight processors, as long as at least one was an IO module. Note that RDLK is a very low-level way of synchronizing between processors. The high level used by user programs is the EVENT data type. The EVENT data type did have some system overh ead. To avoid this overhead, a special locking technique called Dahm locks named after a Burroughs software guru, Dave Dahm can be used. Notable operators are HEYU  send an interrupt to another processor RDLK  Low-level semaphore operator Load the A register with the memory location given by the A register and place the value in the B register at that memory location in a single uninterruptible cycle. The Algol compiler produced code to invoke this operator via a special function that enabled a swap operation on single-word data without an explicit temporary value. xRDLKx,y WHOI  Processor identification IDLE  Idle until an interrupt is received Two processors could infrequently simultaneously send each other a HEYU command resulting in a lockup known as a deadly embrace . Influence of the B5000  edit  The direct influence of the B5000 can be seen in the current Unisys ClearPath range of mainframes which are the direct descendants of the B5000 and still have the MCP operating system after 40 years of consistent development. This architecture is now called emode for emulation mode since the B5000 architecture has been implemented on machines built from Intel Xeon processors running the x86 instruction set as the native instruction set, with code running on those processors emulating the B5000 instruction set. In those machines, there was also going to be an nmode  native mode , but this was dropped  citation needed  , so you may often hear the B5000 successor machines being referred to as emode machines. B5000 machines were programmed exclusively in high-level languages there is no assembler. The B5000 stack architecture inspired Chuck Moore , the designer of the programming language Forth , who encountered the B5500 while at MIT. In Forth - The Early Years , Moore described the influence, noting that Forths DUP, DROP and SWAP came from the corresponding B5500 instructions DUPL, DLET, EXCH. B5000 machines with their stack-based architecture and tagged memory also heavily influenced the Soviet Elbrus series of mainframes and supercomputers . The first two generations of the series featured tagged memory and stack-based CPUs that were programmed only in high-level languages. There existed a kind of an assembly language for them, called El-76, but it was more or less a modification of ALGOL 68 and supported structured programming and first-class procedures. Later generations of the series, though, switched away from this architecture to the EPIC -like VLIW CPUs . The Hewlett-Packard designers of the HP 3000 business system had used a B5500 and were greatly impressed by its hardware and software they aimed to build a 16-bit minicomputer with similar software. Several other HP divisions created similar minicomputer or microprocessor stack machines. Bob Bartons work on reverse Polish notation RPN also found its way into HP calculators beginning with the 9100A, and notably the HP-35 and subsequent calculators. The NonStop systems designed by Tandem Computers in the late 1970s and early 1980s were also 16-bit stack machines, influenced by the B5000 indirectly through the HP 3000 connection, as several of the early Tandem engineers were formerly with HP. Around 1990, these systems migrated to MIPS RISC architecture but continued to support execution of stack machine binaries by object code translation or direct emulation. Sometime after 2000, these systems migrated to Itanium architecture and continued to run the legacy stack machine binaries. Bob Barton was also very influential on Alan Kay . Kay was also impressed by the data-driven tagged architecture of the B5000 and this influenced his thinking in his developments in object-oriented programming and Smalltalk . Another facet of the B5000 architecture was that it was a secure architecture that runs directly on hardware. This technique has descendants in the virtual machines of today in their attempts to provide secure environments. One notable such product is the Java JVM which provides a secure sandbox in which applications run. The value of the hardware-architecture binding that existed before emode would be substantially preserved in the x86 -based machines to the extent that MCP was the one and only control program, but the support provided by those machines is still inferior to that provided on the machines where the B5000 instruction set is the native instruction set. A little-known Intel processor architecture that actually preceded 32-bit implementations of the x86 instruction set, the Intel iAPX 432 , would have provided an equivalent physical basis, as it too was essentially an object-oriented architecture. See also  edit  Burroughs Medium Systems Burroughs Small Systems CANDE Network Definition Language NDL Work Flow Language WFL Octal floating point Notes  edit   E.g., 12-bit syllables for B5000, 8-bit syllables for B6500  There were security issues  Unless you counted the Ferranti Atlas as a commercial machine.  Not counting error controls  There was no flag bit in words containing character data or code References  edit  This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources   Burroughs large systems     news    newspapers    books    scholar    JSTOR  November 2009   Learn how and when to remove this template message  The Extended ALGOL Primer Three Volumes, Donald J. Gregory. Computer Architecture A Structured Approach, R. Doran, Academic Press 1979. Stack Computers The New Wave, Philip J. Koopman, available at 1 B5500, B6500, B6700, B6800, B6900, B7700 manuals at bitsavers.org  a b c John T. Lynch August 1965, The Burroughs B8500 PDF , Datamation  4950 .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  a b c d George Gray October 1999, Burroughs Third-Generation Computers , Unisys History Newsletter , 3 5, archived from the original on September 26, 2017  Burroughs 1963, The Operational Characteristics of the Processors for the Burroughs B5000 PDF , Revision A, 5000-21005  John Mashey 2006-08-15. Admired designs  designs to study . Newsgroup    comp.arch . Usenet   1155671202.964792.162180b28g2000cwb.googlegroups.com . Retrieved 2007-12-15 .  Burroughs May 1967, Burroughs B5500 Information Processing System Reference Manual PDF , 1021326  Taken from Table 5-1 Relative Addressing Table. Burroughs B5500 Information Processing Systems Reference Manual pdf . Systems Documentation. Burroughs Corporation. May 1967. p.  5-4. 1021326.  Burroughs B6500 Information Processing System Reference Manual PDF , Burroughs, September 1969, 1043676  a b Historical Narrative The 1960s US vs IBM, Exhibit 14971, Part 2 . ed-thelen.org . US Government. July 22, 1980. p.  648 409. Archived PDF from the original on 1980 . Retrieved February 21, 2019 . Cite uses deprecated parameter dead-url  help   Burroughs Corporation 1969, Burroughs B6500 Status Report film, Nigel Williams published 2015-08-08, Timecode 1969 status - 000-052, 604-701, 814 date - 340, 421 , retrieved 2019-03-04 Shipments rate, first 16 computers burroughs   B6500 6700   CUBE XVI B6500 Status Apr70 . Apr 1970. pp.  12.  Anderson, James P. Hoffman, Samuel A. Shifman, Joseph Williams, Robert J. 1962, D825 - a multiple-computer system for command  control, Proceedings of the December 46, 1962, Fall Joint Computer Conference , AFIPS Conference Proceedings, Volume 24, doi  10.11451461518.1461527  SCAMP picture at daves Old computers  Reitman, Valerie January 18, 1989, Unisys Ready To Offer A Desktop Mainframe , Philadelphia Inquirer , retrieved 2011-04-16  Unisys Accelerates Mainframe Rebirth with New ClearPath Enterprise Servers, Aggressive New Pricing. - Business Wire - HighBeam Research Press release. June 8, 1998. Archived from the original on May 16, 2011.  Libra 595 . Unisys.  Libra 750 . Unisys.  Organick, Elliot 1973. Computer System Organization . ACM . pp.  115117. ISBN   0-12-528250-8 . Further reading  edit  Barton, Robert S. A New Approach to the Functional Design of a Digital Computer Proceedings of the Western Joint Computer Conference. ACM 1961. Burroughs B 5000 Oral history , Charles Babbage Institute , University of Minnesota. The Burroughs 5000 computer series is discussed by individuals responsible for its development and marketing from 1957 through the 1960s in a 1985 conference sponsored by AFIPS and Burroughs Corporation . Gray, George March 1999. Some Burroughs Transistor Computers . Unisys History Newsletter . 3 1. Archived from the original on October 1, 2016. Gray, George October 1999. Burroughs Third-Generation Computers . Unisys History Newsletter . 3 5. Archived from the original on September 26, 2017. Hauck, E.A., Dent, Ben A. Burroughs B6500B7500 Stack Mechanism, SJCC 1968 pp.  245251. McKeeman, William M. Language Directed Computer Design, Fall Joint Computer Conference, 1967 pp.  413417. Organick, Elliot I. Computer System Organization The B5700B6700 series , Academic Press 1973. Waychoff, Richard, Stories of the B5000 and People Who Were There , September 27, 1979. 2 Allweiss, Jack. The Burroughs B5900 and E-Mode A bridge to 21st Century Computing , Revised 2010. Martin, Ian. Too far ahead of its time Britain, Burroughs and real-time banking in the 1960s , Society for the History of Technology Annual Meeting, 20 Sep-3 Oct 2010, Tacoma, USA. External links  edit  Ian Joyners Burroughs page The Burroughs B5900 and E-Mode A bridge to 21st Century Computing - Jack Allweiss web archive of Ralph Klimek on the B7800 at Monash University Early Burroughs Machines , University of Virginia s Computer Museum. Computer System Organization , ACM Monograph Series. Index of B8500 manuals B5500 Emulation Project Project to create a functional emulator for the Burroughs B5500 computer system. Burroughs B6500 film  transcript v t e Unisys History Burroughs Corporation System Development Corporation Convergent Technologies Sperry Corporation EckertMauchly Computer Corporation Remington Rand Mainframes Burroughs large systems MCP UNIVAC 11002200 series OS 2200 Products Burroughs B1700 Burroughs B2500 Command AND Edit ES7000 HOLMES 2 LINC 4GL MCP Compiler New Executive Programming Language Unisys Icon UNIVAC List of UNIVAC products UNIVAC FASTRAND People Robert S. Barton J. Presper Eckert Retrieved from  httpsen.wikipedia.orgwindex.phptitleBurroughs_large_systems oldid912000415  Categories  Burroughs mainframe computers High-level language computer architecture Stack machines Transistorized computers Unisys Computer-related introductions in 1961 1960s in computer science 1970s in computer science 1980s in computer science 48-bit computers Hidden categories CS1 errors deprecated parameters CS1 long volume value All accuracy disputes Articles with disputed statements from May 2016 All articles with unsourced statements Articles with unsourced statements from May 2016 Articles to be expanded from June 2008 All articles to be expanded Articles using small message boxes Articles with disputed statements from November 2010 Articles with unsourced statements from January 2010 Articles with unsourced statements from February 2007 Articles with unsourced statements from September 2007 Articles needing additional references from November 2009 All articles needing additional references