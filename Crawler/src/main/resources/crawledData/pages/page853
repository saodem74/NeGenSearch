ALGOL 68 From Wikipedia, the free encyclopedia Jump to navigation Jump to search ALGOL 68 Revised Report on the Algorithmic Language - Algol 68 Edited by A. van Wijngaarden et al, September 1973 1  Paradigm multi-paradigm  concurrent , imperative Designed  by A. van Wijngaarden , B. J. Mailloux , J. E. L. Peck and C. H. A. Koster , et al. First  appeared Final Report 1968 r0 Stable release Algol 68RR  Revised Report 1973 r1 Typing discipline static , strong , safe , structural Major implementations ALGOL 68C , Algol 68 Genie recent, ALGOL 68-R , ALGOL 68RS , ALGOL 68S , FLACC ,  68 Leningrad Unit , Odra ALGOL 68 Dialects ALGOL 68FR Final Report r0  Influenced by ALGOL 60 , ALGOL Y Influenced C , 3  5  C , 6  Bourne shell , KornShell , Bash , Steelman , Ada , Python , 7  Seed7 , Mary , S3 This article contains Unicode 6.0  Miscellaneous Technical  characters. Without proper rendering support , you may see question marks, boxes, or other symbols instead of something like   Decimal Exponent Symbol U23E8 TTF . ALGOL 68 short for Algorithmic Language 1968  is an imperative computer programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics. The complexity of the languages definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had no implementations and no users. This was only partially true ALGOL 68 did find use in a number of niche markets, notably in the United Kingdom where it was popular on ICL machines, and in teaching roles. Outside these circles, usage was relatively limited. Nevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal , or were reimplementations for specific roles, like Ada . Many languages of the 1970s trace their design specifically to ALGOL 68, selecting particular features while abandoning others that were considered too complex or out-of-scope for particular roles. Among these is the C programming language , which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68. Contents 1 Overview 2 History 2.1 Origins 2.2 Definition process 2.3 Publication 2.4 Implementations 2.4.1 ALGOL 68-R 2.4.2 Others 2.5 Timeline of ALGOL 68 2.6 The Algorithmic Language ALGOL 68 Reports 2.7 Timeline of standardization 3 Notable language elements 3.1 Bold symbols and reserved words 3.2 Units Expressions 3.3 mode Declarations 3.4 Coercions casting 3.4.1 Coercion hierarchy with examples 3.5 pr  co Pragmats and Comments 3.6 Expressions and compound statements 3.7 struct, union   Structures, unions and arrays 3.8 proc Procedures 3.9 op Operators 3.9.1 Array, Procedure, Dereference and coercion operations 3.9.2 Monadic operators 3.9.3 Dyadic operators with associated priorities 3.9.4 Assignation and identity relations etc 3.9.5 Special characters 3.10 transput Input and output 3.10.1 Books, channels and files 3.10.2 formatted transput 3.11 par Parallel processing 4 Examples of use 4.1 Code sample 4.2 Operating systems written in ALGOL 68 4.3 Applications 4.4 Libraries and APIs 5 Program representation 5.1 Example of different program representations 6 Some Vanitas 7 Comparisons with other languages 8 Revisions 8.1 The language of the unrevised report 8.2 Extension proposals from IFIP WG 2.1 8.3 True ALGOL 68s specification and implementation timeline 8.4 Implementation specific extensions 9 Quotes 10 See also 11 References 11.1 Citations 11.2 Works cited 12 External links Overview  edit  ALGOL 68 features include expression-based syntax, user-declared types and structurestagged-unions, a reference model of variables and reference parameters, string, array and matrix slicing, and also concurrency. ALGOL 68 was designed by the IFIP Working Group 2.1 . On December 20, 1968, the language was formally adopted by Working Group 2.1 and subsequently approved for publication by the General Assembly of IFIP. ALGOL 68 was defined using a two-level grammar formalism invented by Adriaan van Wijngaarden . Van Wijngaarden grammars use a context-free grammar to generate an infinite set of productions that will recognize a particular ALGOL 68 program notably, they are able to express the kind of requirements that in many other programming language standards are labelled semantics and have to be expressed in ambiguity-prone natural language prose, and then implemented in compilers as ad hoc code attached to the formal language parser. The main aims and principles of design of ALGOL 68 Completeness and clarity of description 8  Orthogonal design 9  Security 10  Efficiency 11  Static mode checking Mode-independent parsing Independent compilation Loop optimization Representations  in minimal  larger character sets  ALGOL 68 was the first and possibly one of the last major language for which a full formal definition was made before it was implemented.   C. H. A. Koster , 12  ALGOL 68 has been criticized, most prominently by some members of its design committee such as C. A. R. Hoare and Edsger Dijkstra , for abandoning the simplicity of ALGOL 60 , becoming a vehicle for complex or overly general ideas, and doing little to make the compiler writers task easier, in contrast to deliberately simple contemporaries and competitors such as C , S-algol and Pascal . In 1970, ALGOL 68-R became the first working compiler for ALGOL 68. In the 1973 revision, certain features  such as proceduring , gommas 13  and formal bounds  were omitted. 14  C.f. The language of the unrevised report. r0 Though European defence agencies in Britain Royal Signals and Radar Establishment  RSRE promoted the use of ALGOL 68 for its expected security advantages, the American side of the NATO alliance decided to develop a different project, the Ada programming language , making its use obligatory for US defense contracts. Algol 68 also had a notable influence within the Soviet Union, details of which can be found in Andrey Ershov s 2014 paper ALGOL 68 and Its Impact on the USSR and Russian Programming 15  and  68          16  . Steve Bourne , who was on the Algol 68 revision committee, took some of its ideas to his Bourne shell and thereby, to descendant shells such as Bash  and to C and thereby to descendants such as C . The complete history of the project can be found in C. H. Lindsey s A History of ALGOL 68 . 17  18  For a full-length treatment of the language, see Programming Algol 68 Made Easy 19  by Dr. Sian Mountbatten, or Learning Algol 68 Genie 20  by Marcel van der Veer which includes the Revised Report. History  edit  Origins  edit  ALGOL 68, as the name implies, is a follow-on to the ALGOL language that was first formalized in 1960. That same year the International Federation for Information Processing IFIP formed and started the Working Group on ALGOL, or WG2.1. This group released an updated ALGOL 60 specification in Rome in April 1962. At a follow-up meeting in March 1964, it was agreed that the group should begin work on two follow-on standards, ALGOL X which would be a redefinition of the language with some additions, and an ALGOL Y , which would have the ability to modify its own programs in the style of the LISP . 21  Definition process  edit  The first meeting of the ALGOL X group was held in Princeton University in May 1965. A report of the meeting noted two broadly supported themes, the introduction of strong typing and interest in Eulers concepts of trees or lists for handling collections. 22  At the second meeting in October in France, three formal proposals were presented, Niklaus Wirth s ALGOL W along with comments about record structures by C.A.R. Tony Hoare , a similar language by Gerhard Seegmller, and a paper by Adriaan van Wijngaarden on Orthogonal design and description of a formal language. The later, written in almost indecipherable W-Grammar, proved to be a decisive shift in the evolution of the language. The meeting closed with an agreement that van Wijngaarden would re-write the WirthHoare submission using his W-Grammar. 22  This seemingly simple task ultimately proved more difficult than expected, and the follow-up meeting had to be delayed six months. When it met in April 1966 in Kootwijk , van Wijngaardens draft remained incomplete and Wirth and Hoare presented a version using more traditional descriptions. It was generally agreed that their paper was the right language in the wrong formalism. 23  As these approaches were explored, it became clear there was a difference in the way parameters were described that would have real-world effects, and while Wirth and Hoare protested that further delays might become endless, the committee decided to wait for van Wijngaardens version. Wirth then implemented their current definition as ALGOL W. 24  At the next meeting in Warsaw in October 1968, there was an initial report from the IO Subcommittee who had met at the Oak Ridge National Laboratory and the University of Illinois but had not yet made much progress. The two proposals from the previous meeting were again explored, and this time a new debate emerged about the use of pointers  ALGOL W used them only to refer to records, while van Wijngaardens version could point to any object. To add confusion, John McCarthy presented a new proposal for operator overloading and the ability to string together and and or constructs, and Klaus Samelson wanted to allow anonymous functions . In the resulting confusion, there was some discussion of abandoning the entire effort. 24  The confusion continued through what was supposed to be the ALGOL Y meeting in Zandvoort in May 1967. 22  Publication  edit  A draft report was finally published in February 1968. This was met by shock, horror and dissent, 22  mostly due to the hundreds of pages of unreadable grammar and odd terminology. Charles H. Lindsey attempted to figure out what language was hidden inside of it, 25  a process that took six man-weeks of effort. The resulting paper, ALGOL 68 with fewer tears, was widely circulated. At a wider information processing meeting in Zurich in May 1968, attendees complained that the language was being forced upon them and that IFIP was the true villain of this unreasonable situation as the meetings were mostly closed and there was no formal feedback mechanism. Wirth and Peter Naur formally resigned their authorship positions in WG2.1 at this point. 25  The next WG2.1 meeting took place in Tirrenia in June 1968. It was supposed to discuss the release of compilers and other issues, but instead devolved into a discussion on the language itself. van Wijngaarden responded by saying or threatening that he would release only one more version of the report. By this point Naur, Hoare and Wirth had left the effort, and several more were threatening to. 26  Several more meetings followed, North Berwick in August 1968, Munich in December which produced the release of the official Report in January 1969 but also resulted in a contentious Minority Report being written. Finally, at Banff, Alberta in September 1969, the project was generally considered complete and the discussion was primarily on errata and a greatly expanded Introduction to the Report. 27  The effort took five years, burned out many of the greatest names in computer science , and on several occasions became deadlocked over issues both in the definition and the group as a whole. Hoare released a Critique of ALGOL 68 almost immediately, 28  which has been widely referenced in many works. Wirth went on to further develop the ALGOL W concept and released this as Pascal in 1970. Implementations  edit  ALGOL 68-R  edit  The first implementation of the standard, based on the late-1968 draft Report, was introduced by the Royal Radar Establishment in the UK as ALGOL 68-R in July 1970. This was, however, a subset of the full language, and Barry Mailloux , the final editor of the Report, joked that It is a question of morality. We have a Bible and you are sinning 29  This version nevertheless became very popular on the ICL machines, and became a widely-used language in military coding, especially in the UK. 30  Among the changes in 68-R was the requirement for all variables to be declared before their first use. This had a significant advantage that it allowed the compiler to be one-pass, as space for the variables in the activation record was set aside before it was used. However, this change also had the side-effect of demanding the proc s be declared twice, once as a declaration of the types, and then again as the actual body of code. Another change was to eliminate the assumed void mode, an expression that returns no value known as a statement in other languages and demanding the word void be added where it would have been assumed. Additionally, 68-R eliminated the explicit parallel processing commands based on par . 29  Others  edit  The first full implementation of the language was introduced in 1974 by CDC Netherlands for the Control Data mainframe series. This saw limited use, mostly teaching in Germany and the Netherlands. 30  A version similar to 68-R was introduced from Carnegie Mellon University in 1976 as 68S, and was again a one-pass compiler based on various simplifications of the original and intended for use on smaller machines like the DEC PDP-11 . It too was used mostly for teaching purposes. 30  A version for IBM mainframes did not become available until 1978, when one was released from Cambridge University . This was nearly complete. Lindsey released a version for small machines including the IBM PC in 1984. 30  Timeline of ALGOL 68  edit  Year Event Contributor March 1959 ALGOL Bulletin Issue 1 First Peter Naur  ACM February 1968 Draft Report DR Published 31  IFIP Working Group 2.1 March 1968 Algol 68 Final Report r0 Presented at Munich Meeting IFIP Working Group 2.1 June 1968 Meeting in Tirrenia, Italy IFIP Working Group 2.1 Aug 1968 Meeting in North Berwick, Scotland IFIP Working Group 2.1 December 1968 ALGOL 68 Final Report r0 Presented at Munich Meeting IFIP Working Group 2.1 April 1970 ALGOL 68-R R under GEORGE 3 on an ICL 1907F Royal Signals and Radar Est. September 1973 Algol 68 Revised Report 32  r1 Published IFIP Working Group 2.1 1975 ALGOL 68C C - transportable compiler zcode VM  S. Bourne , Andrew Birrell , and Michael Guy June 1977 Strathclyde ALGOL 68 conference, Scotland ACM May 1978 Proposals for ALGOL H - A Superlanguage of ALGOL 68 33  A. P. Black, V. J. Rayward-Smith 1984 Full ALGOL 68S S compiler for Sun, SPARC, and PCs C. H. Lindsey et al, Manchester August 1988 ALGOL Bulletin Issue 52 last Ed. C. H. Lindsey  ACM May 1997 Algol68 S S published on the internet 34  Charles H. Lindsey November 2001 Algol 68 Genie G published on the internet 35  GNU GPL open source licensing Marcel van der Veer A Shorter History of Algol 68 ALGOL 68 - 3rd generation ALGOL The Algorithmic Language ALGOL 68 Reports  edit  March 1968 Draft Report on the Algorithmic Language ALGOL 68 36  - Edited by A. van Wijngaarden , B. J. Mailloux , J. E. L. Peck and C. H. A. Koster .  Van Wijngaarden once characterized the four authors, somewhat tongue-in-cheek, as Koster transputter , Peck syntaxer, Mailloux implementer, Van Wijngaarden party ideologist.  Koster.  October 1968 Penultimate Draft Report on the Algorithmic Language ALGOL 68  Chapters 1-9 37  Chapters 10-12 38   Edited by A. van Wijngaarden, B.J. Mailloux, J. E. L. Peck and C. H. A. Koster. December 1968 Report on the Algorithmic Language ALGOL 68  Offprint from Numerische Mathematik, 14, 79-218 1969 Springer-Verlag. 39   Edited by A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster. WG 2.1 members active in the original design of ALGOL 68 18  Friedrich L. Bauer  Hans Bekic  Edsger Dijkstra   Fraser Duncan   Jan Garwick   Gerhard Goos  Tony Hoare   Peter Zilahy Ingerman  Kees Koster  Peter Landin  Charles Lindsey  Barry Mailloux  John McCarthy  Jack Merner  Peter Naur   Manfred Paul  John Peck  Willem van der Poel  Brian Randell   Doug Ross  Klaus Samelson  Gerhard Seegmller   Michel Sintzoff  Wlad Turski   Aad van Wijngaarden  Niklaus Wirth   Mike Woodger   Nobuo Yoneda  Key Signatories to the Minority Report. Resigned after MR 93. September 1973 Revised Report on the Algorithmic Language Algol 68 - Springer-Verlag 1976 40  - Edited by A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck , C.H.A. Koster, M. Sintzoff , C. H. Lindsey , L. G. L. T. Meertens and R. G. Fisker . Timeline of standardization  edit  1968 On 20 December 1968, the Final Report MR 101 was adopted by the Working Group, then subsequently approved by the General Assembly of UNESCO s IFIP for publication. Translations of the standard were made for Russian , German , French and Bulgarian , and then later Japanese and Chinese . 41  The standard was also made available in Braille . 1984 TC97 considered Algol 68 for standardisation as New Work Item TC97N1642 2 3  permanent dead link  . West Germany, Belgium, Netherlands, USSR and Czechoslovakia willing to participate in preparing the standard but the USSR and Czechoslovakia were not the right kinds of member of the right ISO committees 4 and Algol 68s ISO standardisation stalled. 5 1988 Subsequently ALGOL 68 became one of the GOST standards in Russia. GOST 27974-88 Programming language ALGOL 68     68 42  GOST 27975-88 Programming language ALGOL 68 extended     68  43  Notable language elements  edit  Bold symbols and reserved words  edit  The standard language contains about sixty reserved words, typically bolded in print, and some with brief symbol equivalents mode , op , prio , proc , flex , heap , loc , long , ref , short , bits , bool , bytes , char , compl , int , real , sema , string , void , channel , file , format , struct , union , at , either r0 , is , isnt is not r0  , of  r0 , true , false , empty , nil , skip , co , comment , pr , pragmat , case  in  ouse  in  out  esac           , for  from  to  by  while  do  od , if  then  elif  then  else  fi           , par begin  end   , go to , goto , exit . r0 . Units Expressions  edit  The basic language construct is the unit . A unit may be a formula , an enclosed clause , a routine text or one of several technically needed constructs assignation, jump, skip, nihil. The technical term enclosed clause unifies some of the inherently bracketing constructs known as block , do statement , switch statement in other contemporary languages. When keywords are used, generally the reversed character sequence of the introducing keyword is used for terminating the enclosure, e.g.  if  then  else  fi , case  in  out  esac , for  while  do  od . This Guarded Command syntax was reused by Stephen Bourne in the common Unix Bourne shell . An expression may also yield a multiple value , which is constructed from other values by a collateral clause . This construct just looks like the parameter pack of a procedure call. mode Declarations  edit  This article contains Unicode 6.0  Miscellaneous Technical  characters. Without proper rendering support , you may see question marks, boxes, or other symbols instead of something like   Decimal Exponent Symbol U23E8 TTF . The basic data types called mode s in Algol 68 parlance are real , int , compl  complex number , bool , char , bits and bytes . For example int n  2 co n is fixed as a constant of 2. co int m   3 co m is a newly created local variable whose value is initially set to 3. co co This is short for ref int m  loc int   3 co real avogadro  6.022141523 co Avogadros number co long long real long long pi  3.14159 26535 89793 23846 26433 83279 50288 41971 69399 37510 compl square root of minus one  0  1 However, the declaration real x is just syntactic sugar for ref real x  loc real  . That is, x is really the constant identifier for a reference to a newly generated local real variable. Furthermore, instead of defining both float and double , or int and long and short , etc., ALGOL 68 provides modifiers , so that the presently common double would be written as long real or long long real instead, for example. The prelude constants max real and min long int are provided to adapt programs to different implementations. All variables need to be declared, the declaration does not have to appear prior to the first use. primitive-declarer int , real , compl , complex G , bool , char , string , bits , bytes , format , file , pipe G , channel , sema bits - a packed vector of bool . bytes - a packed vector of char . string - a flex ible array of char . sema - a sema phore which can be initialised with the op erator level . Complex types can be created from simpler ones using various type constructors ref mode - a reference to a value of type mode , similar to  in CC and ref in Pascal struct - used to build structures, like struct in CC and record in Pascal union - used to build unions, like in CC and Pascal proc - used to specify procedures, like functions in CC and proceduresfunctions in Pascal For some examples, see Comparison of ALGOL 68 and C . Other declaration symbols include flex , heap , loc , ref , long , short , event S flex - declare the array to be flexible, i.e. it can grow in length on demand. heap - allocate variable some free space from the global heap. loc - allocate variable some free space of the local stack. long - declare an int , real or compl to be of a long er size. short - declare an int , real or compl to be of a short er size. A name for a mode type can be declared using a mode declaration, which is similar to typedef in CC and type in Pascal int max99 mode newmode  090max struct  long real a, b, c, short int i, j, k, ref real r  This is similar to the following C code const int max  99  typedef struct  double a , b , c  short i , j , k  float  r   newmode  9  1  max  1  Note that for ALGOL 68 only the newmode mode-indication appears to the left of the equals symbol, and most notably the construction is made - and can be read - from left to right without regard to priorities. Note also that the lower bound of Algol 68 arrays is one by default, but can be any integer from - max int to max int . Mode declarations allow types to be recursive defined directly or indirectly in terms of themselves. This is subject to some restrictions - for instance, these declarations are illegal mode A  ref A mode A  struct A a, B b mode A  proc A a A while these are valid mode A  struct  ref A a, B b mode A  proc  ref A a ref A Coercions casting  edit  The coercions produce a coercee from a coercend according to three criteria the a priori mode of the coercend before the application of any coercion, the a posteriori mode of the coercee required after those coercions, and the syntactic position or sort of the coercee. Coercions may be cascaded. The six possible coercions are termed deproceduring, dereferencing, uniting, widening, rowing, and voiding. Each coercion, except for uniting, prescribes a corresponding dynamic effect on the associated values. Hence, a number of primitive actions can be programmed implicitly by coercions. Context strength  allowed coercions soft  deproceduring weak  dereferencing or deproceduring, yielding a name meek  dereferencing or deproceduring firm  meek, followed by uniting strong  firm, followed by widening, rowing or voiding Coercion hierarchy with examples  edit  ALGOL 68 has a hierarchy of contexts which determine the kind of coercions available at a particular point in the program. These contexts are Context Context location Coercions available Coercion examples in the context Soft Weak Meek Firm Strong Strong Right hand side of Identity-declarations, as  in REAL x   Initialisations, as  in REAL x    Also Actual-parameters of calls, as  in PROC sin Enclosed clauses of casts, as  in REAL Units of routine-texts Statements yielding VOID All parts but one of a balanced clause One side of an identity relation, as  in  IS  deproc edur ing All soft then weak derefer encing deref erencing or deproc eduring, yield ing a name All weak then derefer enc ing deref erenc ing or deproc edur ing All meek then unit ing All firm then widen ing, rowing or voiding Widening occurs if there is no loss of precision. For example An INT will be coerced to a REAL, and a REAL will be coerced to a LONG REAL. But not vice versa. Examples INT to LONG INT INT to REAL REAL to COMPL BITS to BOOL BYTES to STRING A variable can also be coerced rowed to an array of length 1. For example INT to 1INT REAL to 1REAL etc. Firm Operands of formulas as  in OP    Parameters of transput calls Example UNIONINT,REAL var   1 Meek Trimscripts yielding INT Enquiries e.g. as  in the following IF  THEN ... FI and FROM  BY  TO  WHILE  DO ... OD etc Primaries of calls e.g. sin in sinx Examples REF REF BOOL to BOOL REF REF REF INT to INT Weak Primaries of slices, as in  in 199 Secondaries of selections, as  in value OF  Examples REF BOOL to REF BOOL REF REF INT to REF INT REF REF REF REAL to REF REAL REF REF REF REF STRUCT to REF STRUCT Soft The LHS of assignments, as  in    ... Example deproceduring of PROC REAL random e.g. random For more details about Primaries, Secondaries, Tertiary  Quaternaries refer to Operator precedence . pr  co Pragmats and Comments  edit  Pragmats are directives in the program, typically hints to the compiler in newer languages these are called pragmas no t. e.g. pragmat heap32 pragmat pr heap32 pr Comments can be inserted in a variety of ways  The original way of adding your 2 cents worth to a program  comment bold comment comment co Style i comment co  Style ii comment   This is a hashpound comment for a UK keyboard  Normally, comments cannot be nested in ALGOL 68. This restriction can be circumvented by using different comment delimiters e.g. use hash only for temporary code deletions. Expressions and compound statements  edit  ALGOL 68 being an expression-oriented programming language , the value returned by an assignment statement is a reference to the destination. Thus, the following is valid ALGOL 68 code real half pi, one pi one pi   2   half pi   2  arc tan1  This notion is present in C and Perl , among others. Note that as in earlier languages such as Algol 60 and FORTRAN , spaces are allowed in identifiers, so that half pi is a single identifier thus avoiding the underscores versus camel case versus all lower-case issues. As another example, to express the mathematical idea of a sum of fi from i1 to n, the following ALGOL 68 integer expression suffices  int sum   0 for i to n do sum  fi od  sum Note that, being an integer expression, the former block of code can be used in any context where an integer value can be used . A block of code returns the value of the last expression it evaluated this idea is present in Lisp , among other languages. Compound statements are all terminated by distinctive closing brackets if choice clauses if condition then statements  else statements  fi brief form  condition  statements  statements  if condition1 then statements elif condition2 then statements  else statements  fi brief form  condition1  statements  condition2  statements  statements  This scheme not only avoids the dangling else problem but also avoids having to use begin and end in embedded statement sequences. case choice clauses case switch in statements, statements,...  out statements  esac brief form  switch  statements,statements,...  statements  case switch1 in statements, statements,... ouse switch2 in statements, statements,...  out statements  esac brief form of case statement  switch1  statements,statements,...  switch2  statements,statements,...  statements  Choice clause example with Brief symbols proc days in month   int year, month int  month 31, year40  year1000  year4000  29  28 , 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  Choice clause example with Bold symbols proc days in month   int year, month int  case month in 31, if year mod 4 eq 0 and year mod 100 ne 0 or year mod 400 eq 0 then 29 else 28 fi , 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 esac  Choice clause example mixing Bold and Brief symbols proc days in month   int year, month int  case month in Jan 31, Feb  year mod 4  0 and year mod 100  0 or year mod 400  0  29  28 , Mar 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  to Dec.  esac  Algol68 allowed the switch to be of either type int or uniquely union . The latter allows the enforcing strong typing onto union variables. c.f. union below for example. do loop clause  for index   from first   by increment   to last   while condition  do statements od The minimum form of a loop clause is thus do statements od This was considered the universal loop, the full syntax is for i from 1 by -22 to -333 while ii4444 do  od The construct have several unusual aspects only the do  od portion was compulsory, in which case the loop will iterate indefinitely. thus the clause to 100 do  od , will iterate only 100 times. the while syntactic element allowed a programmer to break from a for loop early. e.g. int sum sq0 for i while printSo far,i,newline sum sq702 do sum sqi2 od Subsequent extensions to the standard Algol68 allowed the to syntactic element to be replaced with upto and downto to achieve a small optimisation. The same compilers also incorporated until C - for late loop termination. foreach S - for working on arrays in parallel . Further examples can be found in the code examples below. struct, union   Structures, unions and arrays  edit  ALGOL 68 supports arrays with any number of dimensions, and it allows for the slicing of whole or partial rows or columns. mode vector  13 real   vector mode declaration typedef  mode matrix  13,13 real   matrix mode declaration typedef  vector v1  1,2,3  array variable initially 1,2,3   real v2  4,5,6  constant array, type equivalent to vector , bounds are implied  op    vector a,b vector   binary op erator definition   vector out for i from a to a do outi   aibi od  out matrix m   v1, v2, v1v2 print m,2  a slice of the 2nd and 3rd columns  Matrices can be sliced either way, e.g. ref vector row  m2,  define a ref pointer to the 2nd row  ref vector col  m,2  define a ref pointer to the 2nd column  ALGOL 68 supports multiple field structures  struct  and united modes . Reference variables may point to any mode including array slices and structure fields. For an example of all this, here is the traditional linked list declaration mode node  union  real , int , compl , string , list  struct  node val, ref list next Usage example for union case of node  Algol68 r0 as in the 1968 Final Report node n   1234 real r int i compl c string s case r,i,c,sn in printreal, r, printint, i, printcompl, c, printstring, s out print, n esac Algol68 r1 as in the 1973 Revised Report node n   1234   case n in  real r printreal, r,  int i printint, i,  compl c printcompl, c,  string s printstring, s out print, n esac proc Procedures  edit  Procedure  proc  declarations require type specifications for both the parameters and the result  void if none proc max of real   real a, b real  if a  b then a else b fi  or, using the brief form of the conditional statement proc max of real   real a, b real  a b  a  b The return value of a proc is the value of the last expression evaluated in the procedure. References to procedures  ref proc  are also permitted. Call-by-reference parameters are provided by specifying references such as ref real  in the formal argument list. The following example defines a procedure that applies a function specified as a parameter to each element of an array proc apply   ref  real a, proc  real  real f   for i from lwb a to upb a do ai   fai od This simplicity of code was unachievable in ALGOL 68s predecessor ALGOL 60 . op Operators  edit  The programmer may define new operators and both those and the pre-defined ones may be overloaded and their priorities may be changed by the coder. The following example defines operator max with both dyadic and monadic versions scanning across the elements of an array. prio max  9   op max   int a,b int   a b  a  b  op max   real a,b real   a b  a  b  op max   compl a,b compl   abs a  abs b  a  b    op max   real a real   real out   a lwb a for i from lwb a  1 to upb a do  ai out  outai  od  out Array, Procedure, Dereference and coercion operations  edit  prio rity Operation r0  r1 Algol68 r0 Algol68 G Effectively  12 Primary dereferencing, deproceduring,, subscripting, rowing,, slicing, size denotations long  short proceduring currying,,,, diag , trnsp , row , col Effectively  11 Secondary of selection, loc  heap generators  selection new generators These are technically not operators, rather they are considered  units associated with names  Monadic operators  edit  prio rity Tertiary Algol68 Worthy characters 6  r0  r1 Algol68 r0  r1 Algol68 C,G Algol68 r0 10 not , up , down , lwb , upb , -, abs , arg , bin , entier , leng , level , odd , repr , round , shorten , , , ,  norm , trace , t , det , inv lws , ups , , , btb , ctb Dyadic operators with associated priorities  edit  prio rity Tertiary Algol68 Worthy characters r0  r1 Algol68 r0  r1 Algol68 C,G Algol68 r0 9 , i  ,   8 shl , shr , , up , down , lwb , upb , , ,   , , lws , ups , ,  7 , , , over , , mod , elem , ,  , ,   ,   6 -,  5 , lt , , le , , ge , , gt ,  4 eq , ne   ,  3 , and   2 or   1 minusab , plusab , timesab , divab , overab , modab , plusto , -, , , ,  ,  ,  , ,  , ,   minus , plus , div , overb , modb , , prus Note Tertiaries include names nil and . Assignation and identity relations etc  edit  These are technically not operators, rather they are considered  units associated with names  prio rity Quaternaries Algol68 Worthy characters r0  r1 Algol68 r0  r1 Algol68 C,G,R Algol68 r0 Effectively 0 , is  , isnt    , at , ,      C ,  R .., ., ct ,  , ctab ,  , .., is not , .., ., Note Quaternaries include names skip and .  alternatively  is  tests if two pointers are equal  alternatively  isnt  tests if they are unequal. Why   and   are needed Consider trying to compare two pointer values, such as the following variables, declared as pointers-to-integer ref int ip, jp Now consider how to decide whether these two are pointing to the same location, or whether one of them is pointing to nil . The following expression ip  jp will dereference both pointers down to values of type int , and compare those, since the  operator is defined for int , but not ref int . It is not legal to define  for operands of type ref int and int at the same time, because then calls become ambiguous, due to the implicit coercions that can be applied should the operands be left as ref int and that version of the operator called Or should they be dereferenced further to int and that version used instead Therefore the following expression can never be made legal ip  nil Hence the need for separate constructs not subject to the normal coercion rules for operands to operators. But there is a gotcha. The following expressions ip   jp ip   nil while legal, will probably not do what might be expected. They will always return false , because they are comparing the actual addresses of the variables ip and jp , rather than what they point to . To achieve the right effect, one would have to write ip   ref int jp ip   ref int  nil  Patent application On 14 May 2003, software patent application No. 20040230959 44  was filed for the ISNOT operator by employees of Microsoft . This patent was granted on 18 November 2004. Special characters  edit  IBM 2741 keyboard with APL symbols Most of Algols special characters , , , , , , , , , , , , , , , , , , , , , , ,  and  can be found on the IBM 2741 keyboard with the APL golf-ball print head inserted these became available in the mid-1960s while ALGOL 68 was being drafted. These characters are also part of the Unicode standard and most of them are available in several popular fonts . transput Input and output  edit  Transput is the term used to refer to ALGOL 68s input and output facilities. It includes pre-defined procedures for unformatted, formatted and binary transput. Files and other transput devices are handled in a consistent and machine-independent manner. The following example prints out some unformatted output to the standard output device print newpage, Title, newline, Value of i is , i, and xi is , xi, newline Note the predefined procedures newpage and newline passed as arguments. Books, channels and files  edit  The transput is considered to be of books , channels and files  Books are made up of pages, lines and characters, and may be backed up by files. A specific book can be located by name with a call to match . channel s correspond to physical devices. e.g. card punches and printers. Three standard channels are distinguished stand in channel, stand out channel, stand back channel. A file is a means of communicating between a program and a book that has been opened via some channel. The mood of a file may be read, write, char, bin, and opened. transput procedures include establish, create, open, associate, lock, close, scratch . position enquires char number, line number, page number . layout routines include space , backspace , newline , newpage . get good line, get good page, get good book , and proc set ref file f, int page,line,char void  A file has event routines . e.g. on logical file end, on physical file end, on page end, on line end, on format end, on value error, on char error . formatted transput  edit  Formatted transput in ALGOL 68s transput has its own syntax and patterns functions, with format s embedded between two  characters. 45  Examples printf 2lThe sum isx, g0, m  n  prints the same as  print new line, new line, The sum is, space, whole m  n, 0 par Parallel processing  edit  ALGOL 68 supports programming of parallel processing. Using the keyword par , a collateral clause is converted to a parallel clause , where the synchronisation of actions is controlled using semaphores . In A68G the parallel actions are mapped to threads when available on the hosting operating system . In A68S a different paradigm of parallel processing was implemented see below. int initial foot width  5 mode foot  struct  string name, sema width, bits toe  packed vector of BOOL     foot left foot foot Left, level initial foot width, 2r11111, right foot foot Right, level initial foot width, 2r11111    10 round clip in a 1968 Colt Python .357 Magnum  sema rounds  level 10    the Magnum needs more barrels to take full advantage of parallelism  sema acquire target  level 1   prio   1 op    ref bits lhs, bits rhs ref bits  lhs   lhs  rhs   proc shoot   ref foot foot void   acquire target rounds printBANG  width  foot toe  foot   bin 1 shl level width  foot printfg Ouch - 5gl, name  foot,  bool toe  footbits width - initial foot width  1 acquire target     do shooting in parallel to cater for someone hoping to stand on just one foot  par  for toe to initial foot width do shootleft foot od ,   a comma is required  for toe to initial foot width do shootright foot od  Examples of use  edit  Code sample  edit  This sample program implements the Sieve of Eratosthenes to find all the prime numbers that are less than 100. nil is the ALGOL 68 analogue of the null pointer in other languages. The notation x of y accesses a member x of a struct y . begin  Algol-68 prime number sieve, functional style    proc error   string s void  print newline,  error , s, newline goto stop proc one to   int n list   proc f   int m,n list  m n  nil  consm, fm1,n f1,n   mode list  ref node  mode node  struct  int h, list t proc cons   int n, list l list  heap node   n,l proc hd   list l int   l is nil  errorhd nil  skip  h of l  proc tl   list l list   l is nil  errortl nil  skip  t of l  proc show   list l void   l isnt nil  print  ,wholehdl,0 showtll   proc filter   proc  int  bool p, list l list  if l is nil then nil elif phdl then conshdl, filterp,tll else filterp, tll fi    proc sieve   list l list  if l is nil then nil else proc not multiple   int n bool  n mod hdl  0 conshdl, sieve filter not multiple, tll  fi    proc primes   int n list  sieve tl one ton    show primes100  end Operating systems written in ALGOL 68  edit  Cambridge CAP computer  All procedures constituting the operating system were written in ALGOL 68C , although a number of other closely associated protected procedures  such as a paginator  are written in BCPL . 46  Eldon 3 - Developed at Leeds University for the ICL 1900 was written in ALGOL 68-R . 47  Flex machine  The hardware was custom and microprogrammable, with an operating system, modular compiler, editor, garbage collector and filing system all written in ALGOL 68RS . The command shell Curt 48  was designed to access typed data similar to Algol-68 modes. VME  S3 was the implementation language of the operating system VME. S3 was based on ALGOL 68 but with data types and operators aligned to those offered by the ICL 2900 Series . Note The Soviet Era computers -1 Elbrus-1 and -2 were created using high-level language -76 AL-76, rather than the traditional assembly. -76 resembles Algol-68, The main difference is the dynamic binding types in -76 supported at the hardware level. -76 is used for application, job control, system programming. 49  Applications  edit  Both ALGOL 68C and ALGOL 68-R are written in ALGOL 68, effectively making ALGOL 68 an application of itself. Other applications include ELLA - a hardware description language and support toolset. Developed by the Royal Signals and Radar Establishment during the 1980s and 1990s. RAF Strike Command System - ... 400K of error-free ALGOL 68-RT code was produced with three man-years of work. ... 50  Libraries and APIs  edit  NAG Numerical Libraries - a software library of numerical analysis routines. Supplied in ALGOL 68 during the 1980s. TORRIX - a programming system for operations on vectors and matrices over arbitrary fields and of variable size by S. G. van der Meulen and M. Veldhorst. 51  Program representation  edit  A feature of ALGOL 68, inherited from the ALGOL tradition, is its different representations. There is a representation language used to describe algorithms in printed work, a strict language rigorously defined in the Report and an official reference language intended to be used in actual compiler input. In the examples you will observe bold typeface words, this is the strict language. ALGOL 68s reserved words are effectively in a different namespace from identifiers, and spaces are allowed in identifiers, so this next fragment is legal int a real int  3   The programmer who actually writes code does not always have an option of bold typeface or underlining in the code as this may depend on hardware and cultural issues. Different methods to denote these identifiers have been devised. This is called a stropping regime . For example all or some of the following may be available programming representations  int a real int  3  the strict language  INTA REAL INT  3  QUOTE stropping style  .INT A REAL INT  3  POINT stropping style  INT a real int  3  UPPER stropping style  int a_real_int  3  RES stropping style, there are 61 accepted reserved words  All implementations must recognize at least POINT, UPPER and RES inside PRAGMAT sections. Of these, POINT and UPPER stropping are quite common, while RES stropping is a contradiction to the specification as there are no reserved words. QUOTE single apostrophe quoting was the original recommendation, while matched apostrophe quoting, common in ALGOL 60, is not used much in A LGOL 68. 52  The following characters were recommended for portability, and termed worthy characters in the Report on the Standard Hardware Representation of Algol 68   Worthy Characters ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ,-.   _ This reflected a problem in the 1960s where some hardware didnt support lower-case, nor some other non- ASCII characters, indeed in the 1973 report it was written Four worthy characters  , _, , and   are often coded differently, even at installations which nominally use the same character set. Base characters Worthy characters are a subset of base characters. Example of different program representations  edit  Algol68 strict as typically published   Quote stropping like wikitext    For a 7-bit character code compiler   For a 6-bit character code compiler  underline or bold typeface  mode xint  int  xint sum sq0 for i while sum sq7070 do sum sqi2 od   pr  quote pr  mode  xint   int  xint  sum sq0 for  i while  sum sq7070 do  sum sqi2 od    .PR UPPER .PR MODE XINT  INT XINT sum sq0 FOR i WHILE sum sq7070 DO sum sqi2 OD   .PR POINT .PR .MODE .XINT  .INT .XINT SUM SQ0 .FOR I .WHILE SUM SQ .NE 7070 .DO SUM SQ .PLUSAB I .UP 2 .OD ALGOL 68 allows for every natural language to define its own set of keywords Algol-68. As a result, programmers are able to write programs using keywords from their native language. Below is an example of a simple procedure that calculates the day following, the code is in two languages English and German.  citation needed   Next day date - English variant  mode date  struct  int day, string month, int year proc the day following   date x date  if day of x  length of month month of x, year of x then day of x  1, month of x, year of x elif month of x  December then 1, January, year of x  1 else 1, successor of month month of x, year of x fi   Nachfolgetag - Deutsche Variante  menge datum  tupel  ganz tag, wort monat, ganz jahr funktion naechster tag nach   datum x datum  wenn tag von x  monatslaengemonat von x, jahr von x dann tag von x  1, monat von x, jahr von x wennaber monat von x  Dezember dann 1, Januar, jahr von x  1 ansonsten 1, nachfolgemonatmonat von x, jahr von x endewenn  RussianSoviet example In English Algol68s case statement reads case  in  out  esac , in Cyrillic this reads        . Some Vanitas  edit  For its technical intricacies, ALGOL 68 needs a cornucopia of methods to deny the existence of something skip ,  or  C - an undefined value always syntactically valid, empty - the only value admissible to void , needed for selecting void in a union , void - syntactically like a mode , but not one, nil or  - a name not denoting anything, of an unspecified reference mode,  or specifically 10 int - a vacuum is an empty array here specifically of mode  int . undefined - a standards reports procedure raising an exception in the runtime system.  - Used in the standards report to inhibit introspection of certain types. e.g. sema c.f. below for other examples of . The term nil is var always evaluates to true for any variable but see above for correct use of is  , whereas it is not known to which value a comparison x  skip evaluates for any integer x . ALGOL 68 leaves intentionally undefined what happens in case of integer overflow, the integer bit representation, and the degree of numerical accuracy for floating point. In contrast, the language Java has been criticized for over-specifying the latter. Both official reports included some advanced features that were not part of the standard language. These were indicated with an  and considered effectively private. Examples include  and  for templates, the outtype  intype for crude duck typing , and the straightout and straightin operators for straightening nested arrays and structures. Extract from the 1973 report 10.3.2.2. Transput modes a mode  simplout  union  int ,  real ,  compl , bool ,  bits, char ,   char  b mode  outtype   an actual - declarer specifying a mode united from a sufficient set of modes none of which is void or contains flexible, reference to, procedure or union of  c mode  simplin  union  ref  int ,  ref  real ,  ref  compl , ref bool ,  ref  bits , ref char , ref   char , ref string  d mode  intype   ...    10.3.2.3. Straightening a op  straightout   outtype x   simplout   the result of straightening x  b op  straightin   intype x   simplin   the result of straightening x  Comparisons with other languages  edit  1973  Comparative Notes on Algol 68 and PLI - S. H. Valentine - February 1973 1973  B. R. Alexander and G. E. Hedrick. A Comparison of PL1 and ALGOL 68. International Symposium on Computers and Chinese InputOutput Systems. pp.  359368. 1976  Evaluation of ALGOL 68, JOVIAL J3B, Pascal , Simula 67, and TACPOL Versus TINMAN - Requirements for a Common High Order Programming Language. 1976  A Language Comparison - A Comparison of the Properties of the Programming Languages ALGOL 68, CAMAC-IML , Coral 66 , PAS 1 , PEARL , PL1 , PROCOL , RTL2 in Relation to Real Time Programming - R. Roessler K. Schenk - October 1976 7 1976  Evaluation of ALGOL 68, Jovial J3B, PASCAL, SIMULA 67, and TACPOL Versus Steelman language requirementsTINMAN Requirements for a Common High Order Programming Language. October 1976 8 1977  Report to the High Order-Language Working Group HOLWG - Executive Summary - Language Evaluation Coordinating Committee - Evaluation of PLI , Pascal , ALGOL 68, HALS , PEARL , SPLI , PDL2 , LTR , CS-4 , LIS , Euclid , ECL , Moral , RTL2 , Fortran , COBOL , ALGOL 60 , TACPOL , CMS-2 , Simula 67, JOVIAL J3B, JOVIAL J73  Coral 66 . 1977  A comparison of PASCAL and ALGOL 68 53  - Andrew S. Tanenbaum - June 1977. 1980  A Critical Comparison of Several Programming Language Implementations - Algol 60, FORTRAN, Pascal and Algol 68. 1993  Five Little Languages and How They Grew - BLISS , Pascal , Algol 68, BCPL  C - Dennis M. Ritchie - April 1993. 1999  On Orthogonality  Algol68, Pascal and C 2000  A Comparison of Arrays in ALGOL 68 and BLISS  University of Virginia  Michael Walker  Spring 2000 2009  On Go - oh, go on - How well will Googles Go stand up against Brand X programming language - David Given  November 2009 2010  Algol and Pascal from Concepts in Programming Languages - Block-structured procedural languages  by Marcelo Fiore Comparison of ALGOL 68 and C Revisions  edit  Except where noted with a superscript , the language described above is that of the Revised Report r1 . The language of the unrevised report  edit  The original language As per the Final Report r0  differs in syntax of the mode cast , and it had the feature of proceduring , i.e. coercing the value of a term into a procedure which evaluates the term. Proceduring would be intended to make evaluations lazy . The most useful application could have been the short-circuited evaluation of boolean operators. In op andf   bool a, proc bool b bool a  b  false  op orf   bool a, proc bool b bool a  true  b b is only evaluated if a is true. As defined in ALGOL 68, it did not work as expected, for example in the code if false andf co proc bool co  print Should not be executed true  then ... against the programmers nave expectations the print would be executed as it is only the value of the elaborated enclosed-clause after andf that was procedured. Textual insertion of the commented-out proc bool  makes it work. Some implementations emulate the expected behaviour for this special case by extension of the language. Before revision, the programmer could decide to have the arguments of a procedure evaluated serially instead of collaterally by using semicolons instead of commas  gomma s. For example in proc test   real a real b  ... ... test x plus 1, x The first argument to test is guaranteed to be evaluated before the second, but in the usual proc test   real a, b  ... ... test x plus 1, x then the compiler could evaluate the arguments in whatever order it felt like. Extension proposals from IFIP WG 2.1  edit  After the revision of the report, some extensions to the language have been proposed to widen the applicability partial parametrisation aka Currying  creation of functions with fewer parameters by specification of some, but not all parameters for a call, e.g. a function logarithm of two parameters, base and argument, could be specialised to natural, binary or decadic log, module extension  for support of external linkage, two mechanisms were proposed, bottom-up definition modules , a more powerful version of the facilities from ALGOL 68-R and top-down holes , similar to the ENVIRON and USING clauses from ALGOL 68C 54  mode parameters  for implementation of limited parametrical polymorphism most operations on data structures like lists, trees or other data containers can be specified without touching the pay load. So far, only partial parametrisation has been implemented, in Algol 68 Genie. True ALGOL 68s specification and implementation timeline  edit  Name Year Purpose State Description Target CPU Licensing Implementation Language Generalized ALGOL 1962 Scientific NL ALGOL for generalised grammars ALGOL Y Y 1966 Draft proposal Intl First version of Algol 68 Specification ACM ALGOL 68 DR 1968 Draft proposal Intl IFIP WG 2.1 Draft Report Specification - March ACM ALGOL 68 r0 1968 Standard Intl IFIP WG 2.1 Final Report Specification - August ACM ALGOL 68-R R 1970 Military UK ICL 1900 ALGOL 60 EPOS ALGOL E 1971 Scientific ALGOL 68RS RS 1972 Military UK Portable compiler system ICL 2900Series 39, Multics, VMS  C  generator  1993 Crown Copyright ALGOL 68RS Algol 68 with areas 1972 Experimental  other UK Addition of areas to Algol 68 Mini ALGOL 68 1973 Research NL An interpreter for simple Algol 68 Programs Portable interpreter Mathematisch Centrum ALGOL 60 OREGANO 1973 Research US The importance of implementation models. UCLA ALGOL 68C C 1975 Scientific UK Cambridge Algol 68 ICL , IBM 360, PDP 10  Unix, Telefunken , Tesla  Z80 1980 55  Cambridge ALGOL 68C ALGOL 68 Revised Report r1 1975 Standard Intl IFIP WG 2.1 Revised Report Specification ACM Algol H H 1975 Experimental  other UK Proposed extensions to the mode system of Algol 68 Specification ALGOL W Odra Algol 68 1976 practical uses USSRPoland Odra 1204IL Soviet ALGOL 60 Oklahoma ALGOL 68 1976 programming instruction USA Oklahoma State University implementation 56  IBM 1130 and System370 158 Unknown ANSI Fortran 66 . Berlin ALGOL 68 1977 Research DE The Berlin ALGOL 68 implementation  57  An Abstract ALGOL 68 Machine - machine independent Compiler Technical University of Berlin CDL 2 FLACC F 1977 Multi-purpose CA Revised Report complete implementation with debug features System370 lease, Chion Corporation Assembler ALGOL 68-RT RT 1979 Scientific UK Parallel ALGOL 68-R RS Algol rs 1979 Scientific UK ALGOL 68 1980 Scientific NL Proposed superlanguage of ALGOL 68 58  M-220 ALGOL 68 USSR M-220 Soviet EPSILON Leningrad ALGOL 68 L 1980 Telecommunications USSR Full Language  Modules IBM, DEC, CAMCOH, PS 1001  PC Soviet Interactive ALGOL 68 I 1983 UK Incremental compilation PC Noncommercial shareware  ALGOL 68S S 1985 Scientific Intl Sun version of ALGOL 68 Sun-3 , Sun SPARC under SunOS 4.1  Solaris 2, Atari ST under GEMDOS , Acorn Archimedes under RISC OS , VAX-11 under Ultrix-32 Algol68toC 59  ctrans 1985 Electronics UK ctrans from ELLA ALGOL 68RS Portable C  generator   Open Sourced  Public Domained 1995 ALGOL 68RS MK2 Interactive ALGOL 68 1992 UK Incremental compilation PC Noncommercial shareware 60  Algol 68 Genie G 2001 Full Language NL Includes standard collateral clause Portable interpreter GPL C Algol 68 Genie Version 2.0.0 2010 Full Language NL Portable interpreter optional compilation of selected units GPL C The S3 language that was used to write the ICL VME operating system and much other system software on the ICL 2900 Series was a direct derivative of Algol 68. However, it omitted many of the more complex features, and replaced the basic modes with a set of data types that mapped directly to the 2900 Series hardware architecture. Implementation specific extensions  edit  ALGOL 68R R from RRE was the first ALGOL 68 subset implementation, running on the ICL 1900 . Based on the original language, the main subset restrictions were definition before use and no parallel processing. This compiler was popular in UK universities in the 1970s, where many computer science students learnt ALGOL 68 as their first programming language the compiler was renowned for good error messages. ALGOL 68RS RS from RSRE was a portable compiler system written in ALGOL 68RS bootstrapped from ALGOL 68R, and implemented on a variety of systems including the ICL 2900  Series 39 , Multics and DEC VAXVMS . The language was based on the Revised Report, but with similar subset restrictions to ALGOL 68R. This compiler survives in the form of an Algol68-to-C compiler. In ALGOL 68S S from Carnegie Mellon University the power of parallel processing was improved by adding an orthogonal extension, eventing . Any variable declaration containing keyword event made assignments to this variable eligible for parallel evaluation, i.e. the right hand side was made into a procedure which was moved to one of the processors of the C.mmp multiprocessor system. Accesses to such variables were delayed after termination of the assignment. Cambridge ALGOL 68C C was a portable compiler that implemented a subset of ALGOL 68, restricting operator definitions and omitting garbage collection, flexible rows and formatted transput. Algol 68 Genie G by M. van der Veer is an ALGOL 68 implementation for todays computers and operating systems. Despite good intentions, a programmer may violate portability by inadvertently employing a local extension. To guard against this, each implementation should provide a PORTCHECK pragmat option. While this option is in force, the compiler prints a message for each construct that it recognizes as violating some portability constraint. 61  Quotes  edit  ... The scheme of type composition adopted by C owes considerable debt to Algol 68, although it did not, perhaps, emerge in a form that Algols adherents would approve of. The central notion I captured from Algol was a type structure based on atomic types including structures, composed into arrays, pointers references, and functions procedures. Algol 68s concept of union s and casts also had an influence that appeared later. Dennis Ritchie Apr 1993. 2  ... C does not descend from Algol 68 is true, yet there was influence, much of it so subtle that it is hard to recover even when I think hard. In particular, the union type a late addition to C does owe to A68, not in any details, but in the idea of having such a type at all. More deeply, the type structure in general and even, in some strange way, the declaration syntax the type-constructor part was inspired by A68. And yes, of course, long. Dennis Ritchie , 18 June 1988 4  Congratulations, your Master has done it - Niklaus Wirth 62  The more I see of it, the more unhappy I become - E. W. Dijkstra, 1968 63  ... it was said that A68s popularity was inversely proportional to ... the distance from Amsterdam - Guido van Rossum 64  ... The best we could do was to send with it a minority report, stating our considered view that, ... as a tool for the reliable creation of sophisticated programs, the language was a failure. ... - C. A. R. Hoare in his Oct 1980 Turing Award Lecture 65  Their actual minority report quote from 1970 ... More than ever it will be required from an adequate programming tool that it assists, by structure, the programmer in the most difficult aspects of his job, viz. in the reliable creation of sophisticated programs. In this respect we fail to see how the language proposed here Algol68 is a significant step forward on the contrary, we feel that its implicit view of the programmers task is very much the same as, say, ten years ago. This forces upon us the conclusion that, regarded as a programming tool, the language must be regarded as obsolete. ... Signed by Dijkstra , Duncan , Hoare , Randell , Seegmueller , Turski , Woodger . With Jan V. Garwick 66  on 23 December 1968. See also  edit  ALGOL 60 ALGOL Y ALGOL N ALGOL 68C C programming language C Bourne shell Bash Steelman language requirements Ada programming language Python programming language References  edit  Citations  edit   van Wijngaarden, Adriaan  Mailloux, Barry James  Peck, John Edward Lancelot  Koster, Cornelis Hermanus Antonius  Sintzoff, Michel  Lindsey, Charles Hodgson  Meertens, Lambert Guillaume Louis Thodore  Fisker, Richard G., eds. 1976. Revised Report on the Algorithmic Language ALGOL 68 PDF . Springer-Verlag . ISBN   978-0-387-07592-1 . OCLC   1991170 . Archived PDF from the original on 2019-04-19 . Retrieved 2019-05-11 . Cite uses deprecated parameter dead-url  help  .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  a b Dennis Ritchie April 1993. The Development of the C Language PDF . Archived from the original PDF on 2005-11-06 . Retrieved 2007-04-26 . Cite uses deprecated parameter dead-url  help   Influence on C types, structures, arrays, pointers and procedures - Dennis Ritchie 2   a b Dennis Ritchie June 1988. C and Algol 68 . Retrieved 2006-09-15 .  Influence on C union, structure, syntax and long precision - Dennis Ritchie 4   A History of C 19791991 PDF . March 1993. Page 12, 2nd paragraph Algol68 gave operator overloading3.3.3, references 3.3.4, and the ability to declare variables anywhere in a block 3.3.1 . Retrieved 2008-05-06 .  Interview with Guido van Rossum . July 1998. Archived from the original on 2007-05-01 . Retrieved 2007-04-29 . Cite uses deprecated parameter dead-url  help   Completeness and clarity of description Archived 2013-03-17 at the Wayback Machine  Orthogonal design Archived 2013-03-17 at the Wayback Machine  Security Archived 2013-03-17 at the Wayback Machine  Efficiency Archived 2013-03-17 at the Wayback Machine  A Shorter History of Algol68 . Archived from the original on 2006-08-10 . Retrieved 2006-09-15 . Cite uses deprecated parameter dead-url  help   httpsgroups.google.comgroupcomp.lang.miscmsg03af5063e1662d4d  Revised Report on the Algorithmic Language Algol 68 Archived 2013-03-17 at the Wayback Machine . jmvdveer.home.xs4all.nl 1968-12-20. Retrieved on 2013-07-21.  httpieeexplore.ieee.orgxplarticleDetails.jsparnumber7032965 ALGOL 68 and Its Impact on the USSR and Russian Programming  httptoc.proceedings.com25445webtoc.pdf  68          - pages 336  342  Lindsey 1996 .  a b Lindsey, Charles H. 1996. Bergin, T. J. Gibson, R. G. eds.. A History of ALGOL 68 . ACM SIGPLAN Notices . History of Programming Languages-II . 28 . also in ACM SIGPLAN Notices 283, March 1993 includes a comprehensive bibliography of the meetings and discussions before, during and after development of ALGOL 68. ACM Press . pp.  97132. doi  10.1145155360.155365 . ISBN   978-0-201-89502-5 .  Programming Algol 68 Made Easy  Learning Algol 68 Genie  Lindsey 1993 , p.  7.  a b c d Lindsey 1993 , p.  9.  Lindsey 1993 , p.  24.  a b Lindsey 1993 , p.  10.  a b Lindsey 1993 , p.  12.  Lindsey 1993 , p.  13.  Lindsey 1993 , p.  15.  Critique of ALGOL 68 . ALGOL Bulletin  2729. November 1968.  a b Peck, J. E. L., ed. 1970, Proceedings of the IFIP working conference on ALGOL 68 Implementation , Munich North-Holland, ISBN   0-7204-2045-8  a b c d Koster, C. H. A. A Shorter History of Algol 68 . Archived from the original on 2007-12-17.  Draft Report DR Published  Algol 68 Revised Report  Proposals for ALGOL H - A Superlanguage of ALGOL 68  Algol68 S S published on the internet  Algol 68 Genie G  Draft Report on the Algorithmic Language ALGOL 68 . March 1968. Archived from the original on 2007-09-30 . Retrieved 2007-06-22 . Cite uses deprecated parameter dead-url  help   Penultimate Draft Report on the Algorithmic Language ALGOL 68  Chapters 1-9 PDF . October 1968 . Retrieved 2007-06-22 .  permanent dead link   Penultimate Draft Report on the Algorithmic Language ALGOL 68 - Chapters 10-12 PDF . October 1968 . Retrieved 2007-06-22 .  permanent dead link   Report on the Algorithmic Language ALGOL 68 PDF . December 1968 . Retrieved 2007-12-30 .  Revised Report on the Algorithmic Language Algol 68 . September 1973. Archived from the original on 2007-09-27 . Retrieved 2007-04-30 . Cite uses deprecated parameter dead-url  help   Lu Hu-quan 1971. The Translation of Algol 68 into Chinese PDF . Institute of Mathematics, Academia Sinica - Peking, China . Retrieved 2012-08-17 .  GOST 27974-88 Programming language ALGOL 68 -    68 PDF in Russian. GOST . 1988. Archived PDF from the original on 2008-11-15 . Retrieved 2008-11-15 . Cite uses deprecated parameter dead-url  help   GOST 27975-88 Programming language ALGOL 68 extended -    68  PDF in Russian. GOST . 1988 . Retrieved 2008-11-15 .  IS NOT OPERATOR - US application 20,040,230,959    Format syntax in ALGOL 68G Archived 2008-01-09 at the Wayback Machine  Needham, R. M. Wilkes, M. V. January 1979. The Cambridge CAP Computer and its Operating System PDF . Microsoft Research .  David Holdsworth Winter 20092010. KDF9 Time Sharing Eldon 2 is not EGDON . Computer Resurrection - Number 49 . Computer Conservation Society . Retrieved 2010-10-03 .  httpwww.vitanuova.comdistdocrsre-3522-curt.pdf     Pentium  . Ixbt.com. Retrieved on 2013-07-21.  Oliver, J. R. Newton, R. S. 1979. Practical experience with ALGOL 68-RT PDF . The Computer Journal . 22 2 114118. doi  10.1093comjnl22.2.114 . Retrieved 2011-04-09 .  Applications, libraries, and test suites  Software Preservation Group . Softwarepreservation.org. Retrieved on 2013-07-21.  Revised Report, page 123, footnote  httpdare.ubvu.vu.nlbitstream18712609111054.pdf  Lindsey, C. H. Boom, H. J. December 1978. A Modules and Separate Compilation facility for ALGOL 68 . ALGOL Bulletin 43. doi  10.11451061719.1061724 inactive 2019-08-20 . Retrieved 2011-05-05 .  permanent dead link   Archived copy PDF . Archived from the original PDF on 2010-04-15 . Retrieved 2010-03-20 . Cite uses deprecated parameter dead-url  help  CS1 maint archived copy as title  link   httphtportal.acm.orgft_gateway.cfmid803425 typepdf  permanent dead link   An abstract ALGOL 68 machine and its application in a machine independent compiler - Springer . Springerlink.com. Retrieved on 2013-07-21.  Archived copy . Archived from the original on 2011-03-10 . Retrieved 2010-03-20 . Cite uses deprecated parameter dead-url  help  CS1 maint archived copy as title  link   Open source Algol 68 implementations - Browse Files at . Sourceforge.net. Retrieved on 2013-07-21.  1 Archived 2006-08-29 at the Wayback Machine  httpwww.fh-jena.dekleinehistorylanguagesAlgol68-RR-HardwareRepresentation.pdf  C. H. A. Koster 1993. The Making of Algol 68. CiteSeerX   10.1.1.76.2072 . Cite journal requires journal  help   E. W. Dijkstra. To the EDITOR ALGOL 68 Mathematische Centrum . Archived from the original on 2007-04-21 . Retrieved 2007-04-28 . Cite uses deprecated parameter dead-url  help   Guido van Rossum June 2005. Python-Dev Wishlist dowhile . Retrieved 2007-04-28 .  Hoare, C. A. R. February 1981 based on his 1980 Turing Award Lecture . The emperors old clothes PDF . Communications of the ACM . 24 2 7583. doi  10.1145358549.358561 . Archived from the original on 2010-01-07.  ALGOL Bulletin referred to in AB30.1.1.1 . March 1970. Archived from the original on 2007-09-30 . Retrieved 2007-03-01 . Cite uses deprecated parameter dead-url  help  Works cited  edit  .mw-parser-output .refbeginfont-size90margin-bottom0.5em.mw-parser-output .refbegin-hanging-indentsullist-style-typenonemargin-left0.mw-parser-output .refbegin-hanging-indentsulli,.mw-parser-output .refbegin-hanging-indentsdlddmargin-left0padding-left3.2emtext-indent-3.2emlist-stylenone.mw-parser-output .refbegin-100font-size100 Brailsford, D. F. and Walker, A. N., Introductory ALGOL 68 Programming , Ellis HorwoodWiley, 1979 Lindsey, C. H. and van der Meulen, S. G., Informal Introduction to ALGOL 68 , North-Holland, 1971 Lindsey, C. H. 1993-03-02. A History of ALGOL 68. ACM SIGPLAN Notices . 28 3 171. McGettrick, A. D., ALGOL 68, A First and Second Course , Cambridge Univ. Press, 1978 Peck, J. E. L., An ALGOL 68 Companion , Univ. of British Columbia, October 1971 Tanenbaum, A. S., A Tutorial on ALGOL 68 , Computing Surveys 8 , 155-190, June 1976 and 9 , 255-256, September 1977, 9  permanent dead link  Woodward, P. M. and Bond, S. G., ALGOL 68-R Users sic Guide , London, Her Majestys Stationery Office, 1972 External links  edit  Revised Report on the Algorithmic Language ALGOL 68 The official reference for users and implementors of the language large pdf file, scanned from Algol Bulletin Revised Report on the Algorithmic Language ALGOL 68 Hyperlinked HTML version of the Revised Report A Tutorial on Algol 68 , by Andrew S. Tanenbaum , in Computing Surveys , Vol. 8, No. 2, June 1976, with Corrigenda Vol. 9, No. 3, September 1977 Algol 68 Genie - a GNU GPL Algol 68 compiler-interpreter Open source Algol 68 implementations, on SourceForge Algol68 Standard Hardware representation .pdf       68 Algol 68  25 Years in the USSR         68 C history with Algol68 heritage McJones, Paul, Algol 68 implementations and dialects , Software Preservation Group , Computer History Museum , 2011-07-05 Web enabled ALGOL 68 compiler for small experiments Authority control GND  4141871-2 Retrieved from  httpsen.wikipedia.orgwindex.phptitleALGOL_68 oldid911626831  Categories  ALGOL 68 Algol programming language family Academic programming languages Computer-related introductions in 1968 Procedural programming languages Programming languages created in 1968 Systems programming languages Programming languages 1968 software Hidden categories CS1 errors deprecated parameters Webarchive template wayback links All articles with dead external links Articles with dead external links from November 2016 Articles with permanently dead external links CS1 Russian-language sources ru Pages with DOIs inactive as of 2019 August CS1 maint archived copy as title Articles with dead external links from October 2016 CS1 errors missing periodical Use dmy dates from May 2019 Articles with attributed pull quotes Articles with dead external links from September 2018 All articles with unsourced statements Articles with unsourced statements from August 2011 Articles with dead external links from June 2017 Wikipedia articles with GND identifiers Articles with example ALGOL 68 code