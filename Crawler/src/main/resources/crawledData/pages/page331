COBOL From Wikipedia, the free encyclopedia Jump to navigation Jump to search Programming language with English-like syntax Not to be confused with Kobol , a fictional planet in Battlestar Galactica. COBOL Paradigm Procedural , imperative , object-oriented Designed  by Howard Bromberg , Howard Discount , Vernon Reeves , Jean E. Sammet , William Selden , Gertrude Tierney Developers CODASYL , ANSI , ISO First  appeared 1959  60  years ago   1959  Stable release ISOIEC 19892014  2014 Typing discipline Weak , static Filename extensions .cbl , .cob , .cpy Major implementations GnuCOBOL , IBM COBOL , Micro Focus Visual COBOL Dialects ACUCOBOL-GT, COBOL-IT, COBOL2, DEC COBOL-10, DEC VAX COBOL, DOSVS COBOL, Fujitsu COBOL, Hitachi COBOL2002, HP3000 COBOLII, IBM COBOL SAA, IBM COBOL400, IBM COBOLII, IBM Enterprise COBOL, IBM ILE COBOL, IBM OSVS COBOL, ICL COBOL VME, isCOBOL, Micro Focus COBOL, Microsoft COBOL, Realia COBOL, Ryan McFarland RMCOBOL, Ryan McFarland RMCOBOL-85, Tandem NonStop COBOL85, T andem NonStop SCOBOL, UNIVAC COBOL, Unisys MCP COBOL74, Unisys MCP COBOL85, Unix COBOL XOpen, Veryant isCOBOL, Visual COBOL, Wang VS COBOL Influenced by AIMACO , C , a  COMTRAN , Eiffel , a  FACT , FLOW-MATIC , Smalltalk a  Influenced CobolScript , 4  EGL , 5  PLI , 6  PLB  citation needed  COBOL at Wikibooks COBOL    k o b  l , - b  l   an acronym for common business-oriented language is a compiled English-like computer programming language designed for business use. It is imperative , procedural and, since 2002, object-oriented . COBOL is primarily used in business, finance, and administrative systems for companies and governments. COBOL is still widely used in legacy applications deployed on mainframe computers , such as large-scale batch and transaction processing jobs. But due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. 7  Most programming in COBOL is now purely to maintain existing applications. 8  COBOL was designed in 1959 by CODASYL and was partly based on previous programming language design work by Grace Hopper , commonly referred to as the grandmother of COBOL. 9  10  11  It was created as part of a US Department of Defense effort to create a portable programming language for data processing. It was originally seen as a stopgap, but the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. 12  It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming . The current standard is ISO  IEC 19892014 . 13  COBOL statements have an English-like syntax, which was designed to be self-documenting and highly readable. However, it is verbose and uses over 300 reserved words . In contrast with modern, succinct syntax like y  x  , COBOL has a more English-like syntax in this case, MOVE x TO y . COBOL code is split into four divisions identification, environment, data and procedure containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library , the standard specifies 43 statements, 87 functions and just one class. Academic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design it was effectively designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text. 14  COBOL has been criticized throughout its life, for its verbosity, design process, and poor support for structured programming . These weaknesses result in monolithic and, though intended to be English-like, not easily comprehensible and verbose programs. Contents 1 History and specification 1.1 Background 1.2 COBOL 60 1.3 COBOL-61 to COBOL-65 1.4 COBOL-68 1.5 COBOL-74 1.6 COBOL-85 1.7 COBOL 2002 and object-oriented COBOL 1.8 COBOL 2014 1.9 Legacy 2 Features 2.1 Syntax 2.1.1 Metalanguage 2.2 Code format 2.3 Identification division 2.3.1 Object-oriented programming 2.4 Environment division 2.4.1 Files 2.5 Data division 2.5.1 Aggregated data 2.5.2 Other data levels 2.5.3 Data types 2.5.3.1 PICTURE clause 2.5.3.2 USAGE clause 2.5.4 Report writer 2.6 Procedure division 2.6.1 Procedures 2.6.2 Statements 2.6.2.1 Control flow 2.6.2.2 IO 2.6.2.3 Data manipulation 2.6.3 Scope termination 2.6.4 Self-modifying code 2.7 Hello, world 3 Criticism and defense 3.1 Lack of structure 3.2 Compatibility issues 3.3 Verbose syntax 3.4 Isolation from the computer science community 3.5 Concerns about the design process 3.6 Influences on other languages 4 See also 5 Notes 6 References 6.1 Citations 6.2 Sources 7 External links History and specification  edit  Background  edit  In the late 1950s, computer users and manufacturers were becoming concerned about the rising cost of programming. A 1959 survey had found that in any data processing installation, the programming cost US800,000 on average and that translating programs to run on new hardware would cost 600,000. At a time when new programming languages were proliferating at an ever-increasing rate, the same survey suggested that if a common business-oriented language were used, conversion would be far cheaper and faster. 15  Grace Hopper , the inventor of FLOW-MATIC , a predecessor to COBOL On 8 April 1959, Mary K. Hawes , a computer scientist at Burroughs Corporation , called a meeting of representatives from academia, computer users, and manufacturers at the University of Pennsylvania to organize a formal meeting on common business languages. 16  Representatives included Grace Hopper , inventor of the English-like data processing language FLOW-MATIC , Jean Sammet and Saul Gorn . 17  18  At the April meeting, the group asked the Department of Defense DoD to sponsor an effort to create a common business language. The delegation impressed Charles A. Phillips, director of the Data System Research Staff at the DoD, 19  who thought that they thoroughly understood the DoDs problems. The DoD operated 225 computers, had a further 175 on order and had spent over 200 million on implementing programs to run on them. Portable programs would save time, reduce costs and ease modernization. 20  Phillips agreed to sponsor the meeting and tasked the delegation with drafting the agenda. 21  COBOL 60  edit  On 28 and 29 May 1959 exactly one year after the Zrich ALGOL 58 meeting, a meeting was held at the Pentagon to discuss the creation of a common programming language for business. It was attended by 41 people and was chaired by Phillips. 22  The Department of Defense was concerned about whether it could run the same data processing programs on different computers. FORTRAN , the only mainstream language at the time, lacked the features needed to write such programs. 23  Representatives enthusiastically described a language that could work in a wide variety of environments, from banking and insurance to utilities and inventory control. They agreed unanimously that more people should be able to program and that the new language should not be restricted by the limitations of contemporary technology. A majority agreed that the language should make maximal use of English, be capable of change, be machine-independent and be easy to use, even at the expense of power. 24  The meeting resulted in the creation of a steering committee and short-, intermediate- and long-range committees. The short-range committee was given to September three months to produce specifications for an interim language, which would then be improved upon by the other committees. 25  26  Their official mission, however, was to identify the strengths and weaknesses of existing programming languages and did not explicitly direct them to create a new language. 23  The deadline was met with disbelief by the short-range committee. 27  One member, Betty Holberton , described the three-month deadline as gross optimism and doubted that the language really would be a stopgap. 28  The steering committee met on 4 June and agreed to name the entire activity as the Committee on Data Systems Languages , or CODASYL , and to form an executive committee. 29  The short-range committee was made up of members representing six computer manufacturers and three government agencies. The six computer manufacturers were Burroughs Corporation , IBM , Minneapolis-Honeywell Honeywell Labs, RCA , Sperry Rand , and Sylvania Electric Products . The three government agencies were the US Air Force , the Navys David Taylor Model Basin , and the National Bureau of Standards now the National Institute of Standards and Technology. 30  The committee was chaired by Joseph Wegstein of the US National Bureau of Standards. Work began by investigating data description, statements, existing applications and user experiences. 31  The committee mainly examined the FLOW-MATIC , AIMACO and COMTRAN programming languages. 23  32  The FLOW-MATIC language was particularly influential because it had been implemented and because AIMACO was a derivative of it with only minor changes. 33  34  FLOW-MATICs inventor, Grace Hopper, also served as a technical adviser to the committee. 27  FLOW-MATICs major contributions to COBOL were long variable names, English words for commands and the separation of data descriptions and instructions. 35  IBMs COMTRAN language, invented by Bob Bemer , was regarded as a competitor to FLOW-MATIC 36  37  by a short-range committee made up of colleagues of Grace Hopper. 38  Some of its features were not incorporated into COBOL so that it would not look like IBM had dominated the design process, 25  and Jean Sammet said in 1981 that there had been a strong anti-IBM bias from some committee members herself included. 39  In one case, after Roy Goldfinger, author of the COMTRAN manual and intermediate-range committee member, attended a subcommittee meeting to support his language and encourage the use of algebraic expressions, Grace Hopper sent a memo to the short-range committee reiterating Sperry Rands efforts to create a language based on English. 40  In 1980, Grace Hopper commented that COBOL 60 is 95 FLOW-MATIC and that COMTRAN had had an extremely small influence. Furthermore, she said that she would claim that work was influenced by both FLOW-MATIC and COMTRAN only to keep other people happy so they wouldnt try to knock us out. 41  Features from COMTRAN incorporated into COBOL included formulas, 42  the PICTURE clause , 43  an improved IF statement, which obviated the need for GO TOs , and a more robust file management system. 36  The usefulness of the committees work was subject of great debate. While some members thought the language had too many compromises and was the result of design by committee , others felt it was better than the three languages examined. Some felt the language was too complex others, too simple. 44  Controversial features included those some considered useless or too advanced for data processing users. Such features included boolean expressions , formulas and table subscripts indices. 45  46  Another point of controversy was whether to make keywords context-sensitive and the effect that would have on readability. 45  Although context-sensitive keywords were rejected, the approach was later used in PLI and partially in COBOL from 2002. 47  Little consideration was given to interactivity , interaction with operating systems few existed at that time and functions thought of as purely mathematical and of no use in data processing. 48  49  The specifications were presented to the Executive Committee on 4 September. They fell short of expectations Joseph Wegstein noted that it contains rough spots and requires some additions, and Bob Bemer later described them as a hodgepodge. The subcommittee was given until December to improve it. 27  At a mid-September meeting, the committee discussed the new languages name. Suggestions included BUSY Business System, INFOSYL Information System Language and COCOSYL Common Computer Systems Language. 50  The name COBOL was suggested by Bob Bemer. 51  52  In October, the intermediate-range committee received copies of the FACT language specification created by Roy Nutt . Its features impressed the committee so much that they passed a resolution to base COBOL on it. 53  This was a blow to the short-range committee, who had made good progress on the specification. Despite being technically superior, FACT had not been created with portability in mind or through manufacturer and user consensus. It also lacked a demonstrable implementation, 27  allowing supporters of a FLOW-MATIC-based COBOL to overturn the resolution. RCA representative Howard Bromberg also blocked FACT, so that RCAs work on a COBOL implementation would not go to waste. 54  .mw-parser-output .quoteboxbackground-colorF9F9F9border1px solid aaabox-sizingborder-boxpadding10pxfont-size88max-width100.mw-parser-output .quotebox.floatleftmargin0.5em 1.4em 0.8em 0.mw-parser-output .quotebox.floatrightmargin0.5em 0 0.8em 1.4em.mw-parser-output .quotebox.centeredmargin0.5em auto 0.8em auto.mw-parser-output .quotebox.floatleft p,.mw- parser-output .quotebox.floatright pfont-styleinherit.mw-parser-output .quotebox-titlebackground-colorF9F9F9text-aligncenterfont-sizelargerfont-weightbold.mw-parser-output .quotebox-quote.quotedbeforefont-familyTimes New Roman,seriffont-weightboldfont-sizelargecolorgraycontent  vertical-align-45line-height0.mw-parser-output .quotebox-quote.quo tedafterfont-familyTimes New Roman,seriffont-weightboldfont-sizelargecolorgraycontent  line-height0.mw-parser-output .quotebox .left-alignedtext-alignleft.mw-parser-output .quotebox .right-alignedtext-alignright.mw-parser-output .quotebox .center-alignedtext-aligncenter.mw-parser-output .quotebox citedisplayblockfont-stylenormalmedia screen and max-width360px.mw-parser-output .quoteboxmin-width100margin0 0 0.8emimportantfloatnoneimportant And what name do you want inscribed I said, Ill write it for you. I wrote the name down COBOL. What kind of name is that Well its a Polish name. We shortened it and got rid of a lot of unnecessary notation. Howard Bromberg on how he bought the COBOL tombstone 55  It soon became apparent that the committee was too large for any further progress to be made quickly. A frustrated Howard Bromberg bought a 15 tombstone with COBOL engraved on it and sent it to Charles Phillips to demonstrate his displeasure. b  55  57  A sub-committee was formed to analyze existing languages and was made up of six individuals 23  58  William Selden and Gertrude Tierney of IBM, Howard Bromberg and Howard Discount of RCA, Vernon Reeves and Jean E. Sammet of Sylvania Electric Products. The sub-committee did most of the work creating the specification, leaving the short-range committee to review and modify their work before producing the finished specification. 23  The cover of the COBOL 60 report The specifications were approved by the Executive Committee on 3 January 1960, and sent to the government printing office, which printed these as COBOL 60 . The languages stated objectives were to allow efficient, portable programs to be easily written, to allow users to move to new systems with minimal effort and cost, and to be suitable for inexperienced programmers. 59  The CODASYL Executive Committee later created the COBOL Maintenance Committee to answer questions from users and vendors and to improve and expand the specifications. 60  During 1960, the list of manufacturers planning to build COBOL compilers grew. By September, five more manufacturers had joined CODASYL  Bendix , Control Data Corporation , General Electric GE, National Cash Register and Philco , and all represented manufacturers had announced COBOL compilers. GE and IBM planned to integrate COBOL into their own languages, GECOM and COMTRAN, respectively. In contrast, International Computers and Tabulators planned to replace their language, CODEL, with COBOL. 61  Meanwhile, RCA and Sperry Rand worked on creating COBOL compilers. The first COBOL program ran on 17 August on an RCA 501. 62  On 6 and 7 December, the same COBOL program albeit with minor changes ran on an RCA computer and a Remington-Rand Univac computer, demonstrating that compatibility could be achieved. 63  The relative influences of which languages were used continues to this day in the recommended advisory printed in all COBOL reference manuals .mw-parser-output .templatequoteoverflowhiddenmargin1em 0padding0 40px.mw-parser-output .templatequote .templatequoteciteline-height1.5emtext-alignleftpadding-left1.6emmargin-top0 COBOL is an industry language and is not the property of any company or group of companies, or of any organization or group of organizations. No warranty, expressed or implied, is made by any contributor or by the CODASYL COBOL Committee as to the accuracy and functioning of the programming system and language. Moreover, no responsibility is assumed by any contributor, or by the committee, in connection therewith. The authors and copyright holders of the copyrighted material used herein are as follows FLOW-MATIC trademark of Unisys Corporation, Programming for the UNIVAC R I and II, Data Automation Systems, copyrighted 1958, 1959, by Unisys Corporation IBM Commercial Translator Form No. F28-8013, copyrighted 1959 by IBM FACT, DSI 27A5260-2760, copyrighted 1960 by Minneapolis-Honeywell. They have specifically authorized the use of this material, in whole or in part, in the COBOL specifications. Such authorization extends to the reproduction and use of COBOL specifications in programming manuals or similar publications. 64  COBOL-61 to COBOL-65  edit  It is rather unlikely that Cobol will be around by the end of the decade. Anonymous, June 1960 65  Many logical flaws were found in COBOL 60 , leading GEs Charles Katz to warn that it could not be interpreted unambiguously. A reluctant short-term committee enacted a total cleanup and, by March 1963, it was reported that COBOLs syntax was as definable as ALGOL s, although semantic ambiguities remained. 61  Early COBOL compilers were primitive and slow. A 1962 US Navy evaluation found compilation speeds of 311 statements per minute. By mid-1964, they had increased to 111000 statements per minute. It was observed that increasing memory would drastically increase speed and that compilation costs varied wildly costs per statement were between 0.23 and 18.91. 66  In late 1962, IBM announced that COBOL would be their primary development language and that development of COMTRAN would cease. 66  The COBOL specification was revised three times in the five years after its publication. COBOL-60 was replaced in 1961 by COBOL-61. This was then replaced by the COBOL-61 Extended specifications in 1963, which introduced the sort and report writer facilities. 67  The added facilities corrected flaws identified by Honeywell in late 1959 in a letter to the short-range committee. 62  COBOL Edition 1965 brought further clarifications to the specifications and introduced facilities for handling mass storage files and tables . 68  COBOL-68  edit  Efforts began to standardize COBOL to overcome incompatibilities between versions. In late 1962, both ISO and the United States of America Standards Institute now ANSI  formed groups to create standards. ANSI produced USA Standard COBOL X3.23 in August 1968, which became the cornerstone for later versions. 69  This version was known as American National Standard ANS COBOL and was adopted by ISO in 1972. 70  COBOL-74  edit  By 1970, COBOL had become the most widely used programming language in the world. 71  Independently of the ANSI committee, the CODASYL Programming Language Committee was working on improving the language. They described new versions in 1968, 1969, 1970 and 1973, including changes such as new inter-program communication, debugging and file merging facilities as well as improved string-handling and library inclusion features. 72  Although CODASYL was independent of the ANSI committee, the CODASYL Journal of Development was used by ANSI to identify features that were popular enough to warrant implementing. 73  The Programming Language Committee also liaised with ECMA and the Japanese COBOL Standard committee. 72  The Programming Language Committee was not well-known, however. The vice-president, William Rinehuls, complained that two-thirds of the COBOL community did not know of the committees existence. It was also poor, lacking the funds to make public documents, such as minutes of meetings and change proposals, freely available. 74  In 1974, ANSI published a revised version of ANS COBOL, containing new features such as file organizations , the DELETE statement 75  and the segmentation module. 76  Deleted features included the NOTE statement, the EXAMINE statement which was replaced by INSPECT  and the implementer-defined random access module which was superseded by the new sequential and relative IO modules. These made up 44 changes, which rendered existing statements incompatible with the new standard. 77  The report writer was slated to be removed from COBOL, but was reinstated before the standard was published. 78  79  ISO later adopted the updated standard in 1978. 70  COBOL-85  edit  In June 1978, work began on revising COBOL-74. The proposed standard commonly called COBOL-80 differed significantly from the previous one, causing concerns about incompatibility and conversion costs. In January 1981, Joseph T. Brophy, Senior Vice-President of Travelers Insurance, threatened to sue the standard committee because it was not upwards compatible with COBOL-74. Mr. Brophy described previous conversions of their 40-million-line code base as non-productive and a complete waste of our programmer resources. 80  Later that year, the Data Processing Management Association DPMA said it was strongly opposed to the new standard, citing prohibitive conversion costs and enhancements that were forced on the user. 81  82  During the first public review period, the committee received 2,200 responses, of which 1,700 were negative form letters. 83  Other responses were detailed analyses of the effect COBOL-80 would have on their systems conversion costs were predicted to be at least 50 cents per line of code. Fewer than a dozen of the responses were in favor of the proposed standard. 84  In 1982, ISO installed then-SC5s later SC22 first Working Group WG4 COBOL . ISO took primary ownership and development of the COBOL standard, where ANSI did most of the proposals. In 1983, the DPMA withdrew its opposition to the standard, citing the responsiveness of the committee to public concerns. In the same year, a National Bureau of Standards study concluded that the proposed standard would present few problems. 82  85  A year later, a COBOL-80 compiler was released to DEC VAX users, who noted that conversion of COBOL-74 programs posed few problems. The new EVALUATE statement and inline PERFORM were particularly well received and improved productivity, thanks to simplified control flow and debugging . 86  The second public review drew another 1,000 mainly negative responses, while the last drew just 25, by which time many concerns had been addressed. 82  In 1985, the ISO Working Group 4 accepted the then-version of the ANSI proposed standard, made several changes and set it as the new ISO standard COBOL 85. It was published in late 1985. Sixty features were changed or deprecated and many  quantify  were added, such as 87  88  Scope terminators  END-IF , END-PERFORM , END-READ , etc. Nested subprograms CONTINUE , a no-operation statement EVALUATE , a switch statement INITIALIZE , a statement that can set groups of data to their default values Inline PERFORM loop bodies  previously, loop bodies had to be specified in a separate procedure Reference modification, which allows access to substrings IO status codes. The new standard was adopted by all national standard bodies, including ANSI. 70  Two amendments followed in 1989 and 1993, the first introducing intrinsic functions and the other providing corrections., 70  COBOL 2002 and object-oriented COBOL  edit  In 1997, Gartner Group estimated that there were a total of 200 billion lines of COBOL in existence, which ran 80 of all business programs. 89   better  source  needed  In the early 1990s, work began on adding object-orientation in the next full revision of COBOL. Object-oriented features were taken from C and Smalltalk . 1  2  The initial estimate was to have this revision completed by 1997, and an ISO Committee Draft CD was available by 1997. Some vendors including Micro Focus , Fujitsu , and IBM  introduced object-oriented syntax based on drafts of the full revision. The final approved ISO standard was approved and published in late 2002. 90  FujitsuGTSoftware, 91  Micro Focus and RainCode introduced object-oriented COBOL compilers targeting the .NET Framework . There were many other new features, many of which had been in the CODASYL COBOL Journal of Development since 1978 and had missed the opportunity to be included in COBOL-85. 92  These other features included 93  94  Free-form code User-defined functions Recursion Locale -based processing Support for extended character sets such as Unicode Floating-point and binary data types until then, binary items were truncated based on their declarations base-10 specification Portable arithmetic results Bit and boolean data types Pointers and syntax for getting and freeing storage The SCREEN SECTION for text-based user interfaces The VALIDATE facility Improved interoperability with other programming languages and framework environments such as .NET and Java . Three corrigenda were published for the standard two in 2006 and one in 2009. 95  COBOL 2014  edit  Between 2003 and 2009, three technical reports were produced describing object finalization , XML processing and collection classes for COBOL. 95  COBOL 2002 suffered from poor support no compilers completely supported the standard. Micro Focus found that it was due to a lack of user demand for the new features and due to the abolition of the NIST test suite, which had been used to test compiler conformance. The standardization process was also found to be slow and under-resourced. 96  COBOL 2014 includes the following changes 97  Portable arithmetic results have been replaced by IEEE 754 data types Major features have been made optional, such as the VALIDATE facility, the report writer and the screen-handling facility. Method overloading Dynamic capacity tables a feature dropped from the draft of COBOL 2002 98  Legacy  edit  COBOL programs are used globally in governments and businesses and are running on diverse operating systems such as zOS , zVSE , VME , Unix , OpenVMS and Windows . In 1997, the Gartner Group reported that 80 of the worlds business ran on COBOL with over 200 billion lines of code and 5 billion lines more being written annually. 99  Near the end of the 20th century, the year 2000 problem Y2K was the focus of significant COBOL programming effort, sometimes by the same programmers who had designed the systems decades before. The particular level of effort required to correct COBOL code has been attributed  by whom  to the large amount of business-oriented COBOL, as business applications use dates heavily, and to fixed-length data fields. After the clean-up effort put into these programs for Y2K, a 2003 survey found that many remained in use. 100  The authors said that the survey data suggest a gradual decline in the importance of Cobol in application development over the following 10 years unless ... integration with other languages and technologies can be adopted. 101  In 2006 and 2012, Computerworld surveys found that over 60 of organizations used COBOL more than C and Visual Basic .NET  and that for half of those, COBOL was used for the majority of their internal software. 8  102  36 of managers said they planned to migrate from COBOL, and 25 said they would like to if it was cheaper. Instead, some businesses have migrated their systems from expensive mainframes to cheaper, more modern systems, while maintaining their COBOL programs. 8  Testimony before the House of Representatives in 2016 indicated that COBOL is still in use by many federal agencies. 103  Features  edit  Syntax  edit  COBOL has an English-like syntax, which is used to describe nearly everything in a program. For example, a condition can be expressed as   x IS GREATER THAN y or more concisely as   x GREATER y   or   x  y . More complex conditions can be abbreviated by removing repeated conditions and variables. For example,   a  b AND a  c OR a  d   can be shortened to a  b AND c OR  d . As a consequence of this English-like syntax, COBOL has over 300 keywords . 104  c  Some of the keywords are simple alternative or pluralized spellings of the same word, which provides for more English-like statements and clauses e.g., the IN and OF keywords can be used interchangeably, as can IS and ARE , and VALUE and VALUES . Each COBOL program is made up of four basic lexical items  words, literals, picture character-strings see   PICTURE clause  and separators. Words include reserved words and user-defined identifiers. They are up to 31 characters long and may include letters, digits, hyphens and underscores. Literals include numerals e.g. 12  and strings e.g. Hello  . 106  Separators include the space character and commas and semi-colons followed by a space. 107  A COBOL program is split into four divisions the identification division, the environment division, the data division and the procedure division. The identification division specifies the name and type of the source element and is where classes and interfaces are specified. The environment division specifies any program features that depend on the system running it, such as files and character sets . The data division is used to declare variables and parameters . The procedure division contains the programs statements . Each division is sub-divided into sections, which are made up of paragraphs. Metalanguage  edit  COBOLs syntax is usually described with a unique metalanguage using braces, brackets, bars and underlining. The metalanguage was developed for the original COBOL specifications. Although BackusNaur form did exist at the time, the committee had not heard of it. 108  Elements of COBOLs metalanguage Element Appearance Function All capitals EXAMPLE Reserved word Underlining EXAMPLE The reserved word is compulsory Braces   Only one option may be selected Brackets  Zero or one options may be selected Ellipsis ... The preceding element may be repeated Bars    One or more options may be selected. Any option may only be selected once.    Zero or more options may be selected. Any option may only be selected once. As an example, consider the following description of an ADD statement ADD _  identifier-1 literal-1   TO _  identifier-2  ROUNDED _      ON SIZE _ ERROR _ imperative-statement-1 NOT _ ON SIZE _ ERROR _ imperative-statement-2    END-ADD _  displaystyle beginarraylunderline textADD,beginBmatrixtextidentifier-1textliteral-1endBmatrixdots underline textTO,lefttextidentifier-2,left,underline textROUNDED,rightrightdots quad leftleftbeginarrayltextON,underline textSIZE,underline textERROR,textimperative-statement-1underline textNOT,textON,underline textSIZE,underline textERROR,textimperative-statement-2endarrayrightrightquad left,underline textEND-ADD,rightendarray This description permits the following variants ADD 1 TO x ADD 1 , a , b TO x ROUNDED , y , z ROUNDED ADD a , b TO c ON SIZE ERROR DISPLAY Error  END-ADD ADD a TO b NOT SIZE ERROR DISPLAY No error  ON SIZE ERROR DISPLAY Error  Code format  edit  COBOL can be written in two formats fixed the default or free. In fixed-format, code must be aligned to fit in certain areas a hold-over from using punched cards. Until COBOL 2002, these were Name Columns Usage Sequence number area 16 Originally used for cardline numbers, this area is ignored by the compiler Indicator area 7 The following characters are allowed here   Comment line   Comment line that will be printed on a new page of a source listing -  Continuation line, where words or literals from the previous line are continued D  Line enabled in debugging mode, which is otherwise ignored Area A 811 This contains DIVISION , SECTION and procedure headers 01 and 77 level numbers and filereport descriptors Area B 1272 Any other code not allowed in Area A Program name area 73 Historically up to column 80 for punched cards, it is used to identify the program or sequence the card belongs to In COBOL 2002, Areas A and B were merged to form the program-text area, which now ends at an implementor-defined column. 109  COBOL 2002 also introduced free-format code. Free-format code can be placed in any column of the file, as in newer programming languages. Comments are specified using   , which can be placed anywhere and can also be used in fixed-format source code. Continuation lines are not present, and the  PAGE directive replaces the  indicator. 109  Identification division  edit  The identification division identifies the following code entity and contains the definition of a class or interface. Object-oriented programming  edit  Classes and interfaces have been in COBOL since 2002. Classes have factory objects, containing class methods and variables, and instance objects, containing instance methods and variables. 110  Inheritance and interfaces provide polymorphism . Support for generic programming is provided through parameterized classes, which can be instantiated to use any class or interface. Objects are stored as references which may be restricted to a certain type. There are two ways of calling a method the INVOKE statement, which acts similarly to CALL , or through inline method invocation, which is analogous to using functions. 111    These are equivalent. INVOKE my-class foo  RETURNING var MOVE my-class  foo  TO var   Inline method invocation COBOL does not provide a way to hide methods. Class data can be hidden, however, by declaring it without a PROPERTY clause, which leaves the user with no way to access it. 112  Method overloading was added in COBOL 2014. 113  Environment division  edit  The environment division contains the configuration section and the input-output section. The configuration section is used to specify variable features such as currency signs, locales and character sets. The input-output section contains file-related information. Files  edit  COBOL supports three file formats, or organizations  sequential, indexed and relative. In sequential files, records are contiguous and must be traversed sequentially , similarly to a linked list . Indexed files have one or more indexes which allow records to be randomly accessed and which can be sorted on them. Each record must have a unique key , but other, alternate , record keys need not be unique. Implementations of indexed files vary between vendors, although common implementations, such as C ISAM and VSAM , are based on IBMs ISAM . Relative files, like indexed files, have a unique record key, but they do not have alternate keys. A relative records key is its ordinal position for example, the 10th record has a key of 10. This means that creating a record with a key of 5 may require the creation of empty preceding records. Relative files also allow for both sequential and random access. 114  A common non-standard extension is the line sequential organization, used to process text files. Records in a file are terminated by a newline and may be of varying length. 115  Data division  edit  The data division is split into six sections which declare different items the file section, for file records the working-storage section, for static variables  the local-storage section, for automatic variables  the linkage section, for parameters and the return value the report section and the screen section, for text-based user interfaces . Aggregated data  edit  Data items in COBOL are declared hierarchically through the use of level-numbers which indicate if a data item is part of another. An item with a higher level-number is subordinate to an item with a lower one. Top-level data items, with a level-number of 1, are called records . Items that have subordinate aggregate data are called group items  those that do not are called elementary items . Level-numbers used to describe standard data items are between 1 and 49. 116  117  01 some-record .   Aggregate group record item 05 num PIC 910 .   Elementary item 05 the-date .   Aggregate subgroup record item 10 the-year PIC 94 .   Elementary item 10 the-month PIC 99 .   Elementary item 10 the-day PIC 99 .   Elementary item In the above example, elementary item num and group item the-date are subordinate to the record some-record , while elementary items the-year , the-month , and the-day are part of the group item the-date . Subordinate items can be disambiguated with the IN or OF  keyword. For example, consider the example code above along with the following example 01 sale-date . 05 the-year PIC 94 . 05 the-month PIC 99 . 05 the-day PIC 99 . The names the-year , the-month , and the-day are ambiguous by themselves, since more than one data item is defined with those names. To specify a particular data item, for instance one of the items contained within the sale-date group, the programmer would use the-year IN sale-date or the equivalent the-year OF sale-date . This syntax is similar to the dot notation supported by most contemporary languages. Other data levels  edit  A level-number of 66 is used to declare a re-grouping of previously defined items, irrespective of how those items are structured. This data level, also referred to by the associated RENAMES clause , is rarely used 118  and, circa 1988, was usually found in old programs. Its ability to ignore the hierarchical and logical structure data meant its use was not recommended and many installations forbade its use. 119  01 customer-record . 05 cust-key PIC X10 . 05 cust-name . 10 cust-first-name PIC X30 . 10 cust-last-name PIC X30 . 05 cust-dob PIC 98 . 05 cust-balance PIC 97V99 . 66 cust-personal-details RENAMES cust-name THRU cust-dob . 66 cust-all-details RENAMES cust-name THRU cust-balance . A 77 level-number indicates the item is stand-alone, and in such situations is equivalent to the level-number 01. For example, the following code declares two 77-level data items, property-name and sales-region , which are non-group data items that are independent of not subordinate to any other data items 77 property-name PIC X80 . 77 sales-region PIC 95 . An 88 level-number declares a condition name a so-called 88-level which is true when its parent data item contains one of the values specified in its VALUE clause. 120  For example, the following code defines two 88-level condition-name items that are true or false depending on the current character data value of the wage-type data item. When the data item contains a value of H  , the condition-name wage-is-hourly is true, whereas when it contains a value of S  or Y  , the condition-name wage-is-yearly is true. If the data item contains some other value, both of the condition-names are false. 01 wage-type PIC X . 88 wage-is-hourly VALUE H  . 88 wage-is-yearly VALUE S  , Y  . Data types  edit  Standard COBOL provides the following data types 121  Data type Sample declaration Notes Alphabetic PIC A30 May only contain letters or spaces Alphanumeric PIC X30 May contain any characters Boolean PIC 1 USAGE BIT Data stored in the form of 0s and 1s, as a binary number Index USAGE INDEX Used to reference table elements National PIC N30 Similar to alphanumeric, but using an extended character set, e.g. UTF-8 Numeric PIC 95V95 May contain only numbers Object USAGE OBJECT REFERENCE May reference either an object or NULL Pointer USAGE POINTER Type safety is variable in COBOL. Numeric data is converted between different representations and sizes silently and alphanumeric data can be placed in any data item that can be stored as a string, including numeric and group data. 122  In contrast, object references and pointers may only be assigned from items of the same type and their values may be restricted to a certain type. 123  PICTURE clause  edit  A PICTURE or PIC  clause is a string of characters, each of which represents a portion of the data item and what it may contain. Some picture characters specify the type of the item and how many characters or digits it occupies in memory. For example, a 9 indicates a decimal digit, and an S indicates that the item is signed . Other picture characters called insertion and editing characters specify how an item should be formatted. For example, a series of  characters define character positions as well as how a leading sign character is to be positioned within the final character data the rightmost non-numeric character will contain the items sign, while other character positions corresponding to a  to the left of this position will contain a space. Repeated characters can be specified more concisely by specifying a number in parentheses after a picture character for example, 97 is equivalent to 9999999 . Picture specifications containing only digit  9  and sign  S  characters define purely numeric data items, while picture specifications containing alphabetic  A  or alphanumeric  X  characters define alphanumeric data items. The presence of other formatting characters define edited numeric or edited alphanumeric data items. 124  Examples PICTURE clause Value in Value out PIC 95 100 00100 Hello  Hello  this is legal, but results in undefined behavior  122  PIC  -10     -10 note leading spaces PIC 999994 31042003 31042003  PIC 49.99 100.50 100.50  0 0.00  PIC X3BX3BX3 ABCDEFGHI  ABC DEF GHI  USAGE clause  edit  The USAGE clause declares the format data is stored in. Depending on the data type, it can either complement or be used instead of a PICTURE clause. While it can be used to declare pointers and object references, it is mostly geared towards specifying numeric types. These numeric formats are 125  Binary, where a minimum size is either specified by the PICTURE clause or by a USAGE clause such as BINARY-LONG . USAGE COMPUTATIONAL , where data may be stored in whatever format the implementation provides often equivalent to   USAGE BINARY USAGE DISPLAY , the default format, where data is stored as a string Floating-point, in either an implementation-dependent format or according to IEEE 754. USAGE NATIONAL , where data is stored as a string using an extended character set USAGE PACKED-DECIMAL , where data is stored in the smallest possible decimal format typically packed binary-coded decimal  Report writer  edit  The report writer is a declarative facility for creating reports. The programmer need only specify the report layout and the data required to produce it, freeing them from having to write code to handle things like page breaks, data formatting, and headings and footings. 126  Reports are associated with report files, which are files which may only be written to through report writer statements. FD report-out REPORT sales-report . Each report is defined in the report section of the data division. A report is split into report groups which define the reports headings, footings and details. Reports work around hierarchical control breaks . Control breaks occur when a key variable changes it value for example, when creating a report detailing customers orders, a control break could occur when the program reaches a different customers orders. Here is an example report description for a report which gives a salespersons sales and which warns of any invalid records RD sales-report PAGE LIMITS 60 LINES FIRST DETAIL 3 CONTROLS seller-name . 01 TYPE PAGE HEADING . 03 COL 1 VALUE Sales Report  . 03 COL 74 VALUE Page  . 03 COL 79 PIC Z9 SOURCE PAGE-COUNTER . 01 sales-on-day TYPE DETAIL , LINE  1 . 03 COL 3 VALUE Sales on  . 03 COL 12 PIC 99999999 SOURCE sales-date . 03 COL 21 VALUE were  . 03 COL 26 PIC 9.99 SOURCE sales-amount . 01 invalid-sales TYPE DETAIL , LINE  1 . 03 COL 3 VALUE INVALID RECORD  . 03 COL 19 PIC X34 SOURCE sales-record . 01 TYPE CONTROL HEADING seller-name , LINE  2 . 03 COL 1 VALUE Seller  . 03 COL 9 PIC X30 SOURCE seller-name . The above report description describes the following layout Sales Report Page 1 Seller Howard Bromberg Sales on 10122008 were 1000.00 Sales on 12122008 were 0.00 Sales on 13122008 were 31.47 INVALID RECORD Howard Bromberg XXXXYY Seller Howard Discount ... Sales Report Page 12 Sales on 08052014 were 543.98 INVALID RECORD William Selden 12O52014FOOFOO Sales on 30052014 were 0.00 Four statements control the report writer INITIATE , which prepares the report writer for printing GENERATE , which prints a report group SUPPRESS , which suppresses the printing of a report group and TERMINATE , which terminates report processing. For the above sales report example, the procedure division might look like this OPEN INPUT sales , OUTPUT report-out INITIATE sales-report PERFORM UNTIL 1   1 READ sales AT END EXIT PERFORM END-READ VALIDATE sales-record IF valid-record GENERATE sales-on-day ELSE GENERATE invalid-sales END-IF END-PERFORM TERMINATE sales-report CLOSE sales , report-out . Procedure division  edit  Procedures  edit  The sections and paragraphs in the procedure division collectively called procedures can be used as labels and as simple subroutines . Unlike in other divisions, paragraphs do not need to be in sections. 127  Execution goes down through the procedures of a program until it is terminated. 128  To use procedures as subroutines, the PERFORM verb is used. A PERFORM statement somewhat resembles a procedure call in a modern language in the sense that execution returns to the code following the PERFORM statement at the end of the called code however, it does not provide any mechanism for parameter passing or for returning a result value. If a subroutine is invoked using a simple statement like PERFORM subroutine , then control returns at the end of the called procedure. However, PERFORM is unusual in that it may be used to call a range spanning a sequence of several adjacent procedures. This is done with the PERFORM sub-1 THRU sub-n construct PROCEDURE so-and-so . PERFORM ALPHA PERFORM ALPHA THRU GAMMA STOP RUN . ALPHA . DISPLAY A  . BETA . DISPLAY B  . GAMMA . DISPLAY C  . The output of this program will be A A B C. PERFORM also differs from conventional procedure calls in that there is, at least traditionally, no notion of a call stack. As a consequence, nested invocations are possible a sequence of code being PERFORM ed may execute a PERFORM statement itself, but require extra care if parts of the same code are executed by both invocations. The problem arises when the code in the inner invocation reaches the exit point of the outer invocation. More formally, if control passes through the exit point of a PERFORM invocation that was called earlier but has not completed yet, the COBOL 2002 standard officially stipulates that the behaviour is undefined . The reason is that COBOL, rather than a return address, operates with what may be called a continuation address. When control flow reaches the end of any procedure, the continuation address is looked up and control is transferred to that address. Before the program runs, the continuation address for every procedure is initialised to the start address of the procedure that comes next in the program text so that, if no PERFORM statements happen, control flows from top to bottom through the program. But when a PERFORM statement executes, it modifies the continuation address of the called procedure or the last procedure of the called range, if PERFORM THRU was used, so that control will return to the call site at the end. The original value is saved and is restored afterwards, but there is only one storage position. If two nested invocations operate on overlapping code, they may interfere which each others management of the continuation address in several ways. 129  130  The following example taken from VeermanVerhoeven, 2006 illustrates the problem LABEL1 . DISPLAY 1  PERFORM LABEL2 THRU LABEL3 STOP RUN . LABEL2 . DISPLAY 2  PERFORM LABEL3 THRU LABEL4 . LABEL3 . DISPLAY 3  . LABEL4 . DISPLAY 4  . One might expect that the output of this program would be 1 2 3 4 3 After displaying 2, the second PERFORM causes 3 and 4 to be displayed, and then the first invocation continues on with 3. In traditional COBOL implementations, this is not the case. Rather, the first PERFORM statement sets the continuation address at the end of LABEL3 so that it will jump back to the call site inside LABEL1 . The second PERFORM statement sets the return at the end of LABEL4 but does not modify the continuation address of LABEL3 , expecting it to be the default continuation. Thus, when the inner invocation arrives at the end of LABEL3 , it jumps back to the outer PERFORM statement, and the program stops having printed just 1 2 3. On the other hand, in some COBOL implementations like the open-source TinyCOBOL compiler, the two PERFORM statements do not interfere with each other and the output is indeed 1 2 3 4 3. Therefore the behaviour in such cases is not only perhaps surprising, it is also not portable. 130  A special consequence of this limitation is that PERFORM cannot be used to write recursive code. Another simple example to illustrate this slightly simplified from VeermanVerhoeven, 2006 MOVE 1 TO A PERFORM LABEL STOP RUN . LABEL . DISPLAY A IF A  3 ADD 1 TO A PERFORM LABEL END-IF DISPLAY END  . One might expect that the output is 1 2 3 END END END, and in fact that is what some COBOL compilers will produce. But some compilers, like IBM COBOL, will produce code that prints 1 2 3 END END END END ... and so on, printing END over and over in an endless loop. Since there is limited space to store backup continuation addresses, the backups get overwritten in the course of recursive invocations, and all that can be restored is the jump back to DISPLAY END  . 130  Statements  edit  COBOL 2014 has 47 statements also called verbs , 131  which can be grouped into the following broad categories control flow, IO, data manipulation and the report writer. The report writer statements are covered in the report writer section . Control flow  edit  COBOLs conditional statements are IF and EVALUATE . EVALUATE is a switch-like statement with the added capability of evaluating multiple values and conditions. This can be used to implement decision tables . For example, the following might be used to control a CNC lathe  EVALUATE TRUE ALSO desired-speed ALSO current-speed WHEN lid-closed ALSO min-speed THRU max-speed ALSO LESS THAN desired-speed PERFORM speed-up-machine WHEN lid-closed ALSO min-speed THRU max-speed ALSO GREATER THAN desired-speed PERFORM slow-down-machine WHEN lid-open ALSO ANY ALSO NOT ZERO PERFORM emergency-stop WHEN OTHER CONTINUE END-EVALUATE The PERFORM statement is used to define loops which are executed until a condition is true not while true, which is more common in other languages. It is also used to call procedures or ranges of procedures see the procedures section for more details. CALL and INVOKE call subprograms and methods, respectively. The name of the subprogrammethod is contained in a string which may be a literal or a data item. 132  Parameters can be passed by reference , by content where a copy is passed by reference or by value but only if a prototype is available. 133  CANCEL unloads subprograms from memory. GO TO causes the program to jump to a specified procedure. The GOBACK statement is a return statement and the STOP statement stops the program. The EXIT statement has six different formats it can be used as a return statement, a break statement , a continue statement , an end marker or to leave a procedure. 134  Exceptions are raised by a RAISE statement and caught with a handler, or declarative , defined in the DECLARATIVES portion of the procedure division. Declaratives are sections beginning with a USE statement which specify the errors to handle. Exceptions can be names or objects. RESUME is used in a declarative to jump to the statement after the one that raised the exception or to a procedure outside the DECLARATIVES . Unlike other languages, uncaught exceptions may not terminate the program and the program can proceed unaffected. IO  edit  File IO is handled by the self-describing OPEN , CLOSE , READ , and WRITE statements along with a further three REWRITE , which updates a record START , which selects subsequent records to access by finding a record with a certain key and UNLOCK , which releases a lock on the last record accessed. User interaction is done using ACCEPT and DISPLAY . Data manipulation  edit  The following verbs manipulate data INITIALIZE , which sets data items to their default values. MOVE , which assigns values to data items   MOVE CORRESPONDING assigns corresponding like-named fields . SET , which has 15 formats it can modify indices, assign object references and alter table capacities, among other functions. 135  ADD , SUBTRACT , MULTIPLY , DIVIDE , and COMPUTE , which handle arithmetic with COMPUTE assigning the result of a formula to a variable. ALLOCATE and FREE , which handle dynamic memory . VALIDATE , which validates and distributes data as specified in an items description in the data division. STRING and UNSTRING , which concatenate and split strings , respectively. INSPECT , which tallies or replaces instances of specified substrings within a string. SEARCH , which searches a table for the first entry satisfying a condition. Files and tables are sorted using SORT and the MERGE verb merges and sorts files. The RELEASE verb provides records to sort and RETURN retrieves sorted records in order. Scope termination  edit  Some statements, such as IF and READ , may themselves contain statements. Such statements may be terminated in two ways by a period  implicit termination , which terminates all unterminated statements contained, or by a scope terminator, which terminates the nearest matching open statement.   Terminator period  implicit termination  IF invalid-record IF no-more-records NEXT SENTENCE ELSE READ record-file AT END SET no-more-records TO TRUE .   Scope terminators  explicit termination  IF invalid-record IF no-more-records CONTINUE ELSE READ record-file AT END SET no-more-records TO TRUE END-READ END-IF END-IF Nested statements terminated with a period are a common source of bugs. 136  137  For example, examine the following code IF x DISPLAY y . DISPLAY z . Here, the intent is to display y and z if condition x is true. However, z will be displayed whatever the value of x because the IF statement is terminated by an erroneous period after DISPLAY y . Another bug is a result of the dangling else problem , when two IF statements can associate with an ELSE . IF x IF y DISPLAY a ELSE DISPLAY b . In the above fragment, the ELSE associates with the   IF y   statement instead of the   IF x   statement, causing a bug. Prior to the introduction of explicit scope terminators, preventing it would require   ELSE NEXT SENTENCE   to be placed after the inner IF . 137  Self-modifying code  edit  The original 1959 COBOL specification supported the infamous   ALTER X TO PROCEED TO Y   statement, for which many compilers generated self-modifying code . X and Y are procedure labels, and the single   GO TO   statement in procedure X executed after such an ALTER statement means   GO TO Y   instead. Many compilers still support it, 138  but it was deemed obsolete in the COBOL 1985 standard and deleted in 2002. 139  Hello, world  edit  A  Hello, world  program in COBOL IDENTIFICATION DIVISION . PROGRAM-ID . hello-world . PROCEDURE DIVISION . DISPLAY Hello, world  . When the  now famous  Hello, World program example in The C Programming Language was first published in 1978 a similar mainframe COBOL program sample would have been submitted through JCL , very likely using a punch card reader, and 80 column punch cards. The listing below, with an empty DATA DIVISION , was tested using GNULinux and the System370 Hercules emulator running MVS 3.8J. The JCL, written in July 2015, is derived from the Hercules tutorials and samples hosted by Jay Moseley. 140  In keeping with COBOL programming of that era, HELLO, WORLD is displayed in all capital letters.  COBUCLG JOB  001 , COBOL BASE TEST  , 00010000  CLASS  A , MSGCLASS  A , MSGLEVEL   1 , 1  00020000  BASETEST EXEC COBUCLG 00030000  COB . SYSIN DD  00040000 00000  VALIDATION OF BASE COBOL INSTALL 00050000 01000 IDENTIFICATION DIVISION . 00060000 01100 PROGRAM-ID . HELLO  . 00070000 02000 ENVIRONMENT DIVISION . 00080000 02100 CONFIGURATION SECTION . 00090000 02110 SOURCE-COMPUTER . GNULINUX . 00100000 02120 OBJECT-COMPUTER . HERCULES . 00110000 02200 SPECIAL-NAMES . 00120000 02210 CONSOLE IS CONSL . 00130000 03000 DATA DIVISION . 00140000 04000 PROCEDURE DIVISION . 00150000 04100 00 - MAIN . 00160000 04110 DISPLAY HELLO, WORLD  UPON CONSL . 00170000 04900 STOP RUN . 00180000  LKED . SYSLIB DD DSNAME  SYS1 . COBLIB , DISP  SHR 00190000  DD DSNAME  SYS1 . LINKLIB , DISP  SHR 00200000  GO . SYSPRINT DD SYSOUT  A 00210000  00220000 After submitting the JCL, the MVS console displayed 19.52.48 JOB 3 HASP100 COBUCLG ON READER1 COBOL BASE TEST 19.52.48 JOB 3 IEF677I WARNING MESSAGES FOR JOB COBUCLG ISSUED 19.52.48 JOB 3 HASP373 COBUCLG STARTED - INIT 1 - CLASS A - SYS BSP1 19.52.48 JOB 3 IEC130I SYSPUNCH DD STATEMENT MISSING 19.52.48 JOB 3 IEC130I SYSLIB DD STATEMENT MISSING 19.52.48 JOB 3 IEC130I SYSPUNCH DD STATEMENT MISSING 19.52.48 JOB 3 IEFACTRT - Stepname Procstep Program Retcode 19.52.48 JOB 3 COBUCLG BASETEST COB IKFCBL00 RC 0000 19.52.48 JOB 3 COBUCLG BASETEST LKED IEWL RC 0000 19.52.48 JOB 3 HELLO, WORLD 19.52.48 JOB 3 COBUCLG BASETEST GO PGM.DD RC 0000 19.52.48 JOB 3 HASP395 COBUCLG ENDED Line 10 of the console listing above is highlighted for effect, the highlighting is not part of the actual console output . The associated compiler listing generated over four pages of technical detail and job run information, for the single line of output from the 14 lines of COBOL. Criticism and defense  edit  Lack of structure  edit  In the 1970s, adoption of the structured programming paradigm was becoming increasingly widespread. Edsger Dijkstra , a preeminent computer scientist, wrote a letter to the editor of Communications of the ACM , published 1975 entitled How do we tell truths that might hurt, in which he was critical of COBOL and several other contemporary languages remarking that the use of COBOL cripples the mind. 141  In a published dissent to Dijkstras remarks, the computer scientist Howard E. Tompkins claimed that unstructured COBOL tended to be written by programmers that have never had the benefit of structured COBOL taught well, arguing that the issue was primarily one of training. 142  One cause of spaghetti code was the GO TO statement. Attempts to remove GO TO s from COBOL code, however, resulted in convoluted programs and reduced code quality. 143  GO TO s were largely replaced by the PERFORM statement and procedures, which promoted modular programming 143  and gave easy access to powerful looping facilities. However, PERFORM could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand. 144  COBOL programs were infamous for being monolithic and lacking modularization. 145  COBOL code could only be modularized through procedures, which were found to be inadequate for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify any data item. Furthermore, there was no way to pass parameters to a procedure, an omission Jean Sammet regarded as the committees biggest mistake. 146  Another complication stemmed from the ability to PERFORM THRU a specified sequence of procedures. This meant that control could jump to and return from any procedure, creating convoluted control flow and permitting a programmer to break the single-entry single-exit rule. 147  This situation improved as COBOL adopted more features. COBOL-74 added subprograms, giving programmers the ability to control the data each part of the program could access. COBOL-85 then added nested subprograms, allowing programmers to hide subprograms. 148  Further control over data and code came in 2002 when object-oriented programming, user-defined functions and user-defined data types were included. Nevertheless, much important legacy COBOL software uses unstructured code, which has become unmaintainable. It can be too risky and costly to modify even a simple section of code, since it may be used from unknown places in unknown ways. 149  Compatibility issues  edit  COBOL was intended to be a highly portable, common language. However, by 2001, around 300 dialects had been created. 150  One source of dialects was the standard itself the 1974 standard was composed of one mandatory nucleus and eleven functional modules, each containing two or three levels of support. This permitted 104,976 official variants. 151  COBOL-85 was not fully compatible with earlier versions, and its development was controversial. Joseph T. Brophy, the CIO of Travelers Insurance , spearheaded an effort to inform COBOL users of the heavy reprogramming costs of implementing the new standard. 152  As a result, the ANSI COBOL Committee received more than 2,200 letters from the public, mostly negative, requiring the committee to make changes. On the other hand, conversion to COBOL-85 was thought to increase productivity in future years, thus justifying the conversion costs. 153  Verbose syntax  edit  COBOL kohbol, n. A weak, verbose, and flabby language used by code grinders to do boring mindless things on dinosaur mainframes. ... Its very name is seldom uttered without ritual expressions of disgust or horror. The Jargon File 4.4.8. 154  COBOL syntax has often been criticized for its verbosity. Proponents say that this was intended to make the code self-documenting , easing program maintenance. 155  COBOL was also intended to be easy for programmers to learn and use, 156  while still being readable to non-technical staff such as managers. 157  158  159  160  The desire for readability led to the use of English-like syntax and structural elements, such as nouns, verbs, clauses, sentences, sections, and divisions. Yet by 1984, maintainers of COBOL programs were struggling to deal with incomprehensible code 159  and the main changes in COBOL-85 were there to help ease maintenance. 83  Jean Sammet, a short-range committee member, noted that little attempt was made to cater to the professional programmer, in fact people whose main interest is programming tend to be very unhappy with COBOL which she attributed to COBOLs verbose syntax. 161  Isolation from the computer science community  edit  The COBOL community has always been isolated from the computer science community. No academic computer scientists participated in the design of COBOL all of those on the committee came from commerce or government. Computer scientists at the time were more interested in fields like numerical analysis, physics and system programming than the commercial file-processing problems which COBOL development tackled. 162  Jean Sammet attributed COBOLs unpopularity to an initial snob reaction due to its inelegance, the lack of influential computer scientists participating in the design process and a disdain for business data processing. 163  The COBOL specification used a unique notation, or metalanguage , to define its syntax rather than the new BackusNaur form which the committee did not know of. This resulted in severe criticism. 164  165  61  Later, COBOL suffered from a shortage of material covering it it took until 1963 for introductory books to appear with Richard D. Irwin publishing a college textbook on COBOL in 1966. 166  By 1985, there were twice as many books on Fortran and four times as many on BASIC as on COBOL in the Library of Congress . 108  University professors taught more modern, state-of-the-art languages and techniques instead of COBOL which was said to have a trade school nature. 167  Donald Nelson, chair of the CODASYL COBOL committee, said in 1984 that academics ... hate COBOL and that computer science graduates had hate COBOL drilled into them. 168  A 2013 poll by Micro Focus found that 20 of university academics thought COBOL was outdated or dead and that 55 believed their students thought COBOL was outdated or dead. The same poll also found that only 25 of academics had COBOL programming on their curriculum even though 60 thought they should teach it. 169  In contrast, in 2003, COBOL featured in 80 of information systems curricula in the United States, the same proportion as C and Java . 170  There was also significant condescension towards COBOL in the business community from users of other languages, for example FORTRAN or assembler , implying that COBOL could be used only for non-challenging problems.  citation needed  Concerns about the design process  edit  Doubts have been raised about the competence of the standards committee. Short-term committee member Howard Bromberg said that there was little control over the development process and that it was plagued by discontinuity of personnel and ... a lack of talent. 71  Jean Sammet and Jerome Garfunkel also noted that changes introduced in one revision of the standard would be reverted in the next, due as much to changes in who was in the standard committee as to objective evidence. 171  COBOL standards have repeatedly suffered from delays COBOL-85 arrived five years later than hoped, 172  COBOL 2002 was five years late, 1  and COBOL 2014 was six years late. 90  173  To combat delays, the standard committee allowed the creation of optional addenda which would add features more quickly than by waiting for the next standard revision. However, some committee members raised concerns about incompatibilities between implementations and frequent modifications of the standard. 174  Influences on other languages  edit  COBOLs data structures influenced subsequent programming languages. Its record and file structure influenced PLI and Pascal , and the REDEFINES clause was a predecessor to Pascals variant records. Explicit file structure definitions preceded the development of database management systems and aggregated data was a significant advance over Fortrans arrays. 108  PICTURE data declarations were incorporated into PLI, with minor changes. COBOLs COPY facility, although considered primitive, 175  influenced the development of include directives . 108  The focus on portability and standardization meant programs written in COBOL could be portable and facilitated the spread of the language to a wide variety of hardware platforms and operating systems. 176  Additionally, the well-defined division structure restricts the definition of external references to the Environment Division, which simplifies platform changes in particular. 177  See also  edit  Computer programming portal Alphabetical list of programming languages BLISCOBOL COBOL ReSource CODASYL Comparison of programming languages Generational list of programming languagesCOBOL based List of compilersCOBOL compilers Notes  edit   a b c Specifically influenced COBOL 2002s object-oriented features. 1  2  3   The tombstone is currently at the Computer History Museum . 56   Vendor-specific extensions cause many implementations to have far more one implementation recognizes over 1,100 keywords. 105  References  edit  Citations  edit   a b c Saade, Henry Wallace, Ann October 1995. COBOL 97 A Status Report . Dr. Dobbs Journal . Retrieved 21 April 2014 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  a b Arranga, Edmund C. Coyle, Frank P. February 1998. Object-Oriented COBOL . Cambridge University Press . p.  15. ISBN   978-0132611404 . Object-Oriented COBOLs style reflects the influence of Smalltalk and C.  Arranga, Edmund C. Coyle, Frank P. March 1997. Cobol Perception and Reality. Computer . 30 3 127. doi  10.11092.573683 . ISSN   0018-9162 .  Imajo, Tetsuji et al. September 2000. COBOL Script a business-oriented scripting language . Enterprise Distributed Object Computing Conference . Makuhari, Japan IEEE. doi  10.1109EDOC.2000.882363 . ISBN   0769508650 .  Ho, Wing Hong 7 May 2007. Introduction to EGL PDF . IBM Software Group.  Radin, George 1978. Wexelblat, Richard L. ed.. The early history and characteristics of PLI . History of Programming Languages. Academic Press published 1981. p.  572. doi  10.1145800025.1198410 . ISBN   0127450408 .  Mitchell, Robert L. 14 March 2012. Brain drain Where Cobol systems go from here . Computerworld . Retrieved 9 February 2015 .  a b c Mitchell, Robert L. 4 October 2006. Cobol Not Dead Yet . Computerworld . Retrieved 27 April 2014 .  Porter Adams, Vicki 5 October 1981. Captain Grace M. Hopper the Mother of COBOL . InfoWorld . 3 20 33. ISSN   0199-6649 .  Betts, Mitch 6 January 1992. Grace Hopper, mother of Cobol, dies . Computerworld . 26 1 14. ISSN   0010-4841 .  Lohr, Steve 2008. Go To The Story of the Math Majors, Bridge Players, Engineers, Chess Wizards, Maverick Scientists, and IconoclastsThe Programmers Who Created the Software Revolution . Basic Books . p.  52. ISBN   978-0786730766 .  Ensmenger, Nathan L. 2009. The Computer Boys Take Over Computers, Programmers, and the Politics of Technical Expertise . MIT Press . p.  100. ISBN   978-0262050937 . LCCN   2009052638 .  ISOIEC 19892014 . ISO. 26 May 2014 . Retrieved 7 June 2014 .  Ferguson, Andrew. A History of Computer Programming Languages . cs.brown.edu .  Beyer 2009 , p.  282.  Grer, Denise 1 June 2002. Pioneering Women in Computer Science. SIGCSE Bull . 34 2 175180. doi  10.1145543812.543853 . ISSN   0097-8418 .  Beyer 2009 , pp.  281282.  Sammet 1978a , p.  200.  Flahive, Paul 24 May 2019. How COBOL Still Powers The Global Economy At 60 Years Old . Texas Public Radio . Archived from the original html on 24 May 2019 . Retrieved 19 July 2019 . Grace Hopper Nicknamed Grandma Cobol, the code was based on some of her earlier work. She said  after hearing the rumors  one of her collaborators went out and bought a granite tombstone. He had the word COBOL cut in the front of it. Then he shipped it express collect to Mr. Phillips in the pentagon. The prank on Charles Phillips, a leader for the project at the defense department, got the attention of the powers that be and was a turning point she said. COBOL would go on to become the most widely used and longest lasting computer languages in history.  Beyer 2009 , p.  283.  Beyer 2009 , p.  284.  Early Meetings of the Conference on Data Systems Languages. IEEE Annals of the History of Computing . 7 4 316325. 1985. doi  10.1109MAHC.1985.10047 .  a b c d e Sammet 2004 , p.  104.  Beyer 2009 , p.  286.  a b Conner 1984 , p.  ID9.  Sammet 1978a , p.  201.  a b c d Bemer 1971 , p.  132.  Beyer 2009 , p.  288.  Sammet 1978a , p.  203.  CODASYL 1969 ,  I.2.1.1.  Sammet 1978a , p.  204.  CODASYL 1969 ,  I.1.2.  Beyer 2009 , p.  290.  Sammet, Jean 1978. The Early History of COBOL . ACM SIGPLAN Notices . 13 8 121161. doi  10.1145960118.808378 . Retrieved 14 January 2010 .  Sammet 1978a , p.  217.  a b Beyer 2009 , p.  292.  Bemer 1971 , p.  131.  Beyer 2009 , p.  296.  Sammet 1978a , p.  221.  Beyer 2009 , p.  291.  Oral History of Captain Grace Hopper PDF . Computer History Museum . December 1980. p.  37. Archived from the original PDF on 25 December 2017 . Retrieved 28 June 2014 . Cite uses deprecated parameter dead-url  help   Sammet 1978a , p.  218.  Marcotty 1978 , p.  268.  Sammet 1978a , pp.  205206.  a b Sammet 1978a , Figure 8.  Sammet 1978a , pp.  230231.  ISOIEC JTC 1SC 22WG 4 2001 , p.  846.  Sammet 1978a , p.  220.  Sammet 1978a , p.  228.  Sammet 1978a , p.  210.  Sullivan, Patricia 25 June 2004. Computer Pioneer Bob Bemer, 84 . The Washington Post . p.  B06 . Retrieved 28 June 2014 .  Bemer, Bob. Thoughts on the Past and Future . Archived from the original on 16 May 2014 . Retrieved 28 June 2014 . Cite uses deprecated parameter deadurl  help   Beyer 2009 , p.  293.  Beyer 2009 , p.  294.  a b The Story of the COBOL Tombstone PDF . The Computer Museum Report . 13  89. Summer 1985. Archived PDF from the original on 3 April 2014 . Retrieved 29 June 2014 . Cite uses deprecated parameter deadurl  help   COBOL Tombstone . Computer History Museum . Retrieved 29 June 2014 .  Bemer 1971 , p.  130.  Beyer 2009 , p.  289.  CODASYL 1969 ,  I.1.1.  Brown 1976 , p.  47.  a b c Bemer 1971 , p.  133.  a b Beyer 2009 , p.  297.  Williams, Kathleen Broome 10 November 2012. Grace Hopper Admiral of the Cyber Sea . US Naval Institute Press. ISBN   978-1612512655 . OCLC   818867202 .  Compaq Computer Corporation Compaq COBOL Reference Manual , Order Number AAQ2G0FTK October 2000, Page xviii Fujitsu Corporation Net Cobol Language Reference , Version 15, January 2009 IBM Corporation Enterprise COBOL for zOS Language Reference , Version 4 Release 1, SC23-8528-00, December 2007  Garfunkel, Jerome 11 November 1984. In defense of Cobol . Computerworld . 18 24 ID19.  a b Bemer 1971 , p.  134.  Brown 1976 , p.  48.  CODASYL 1969 ,  I.2.2.4.  CODASYL 1969 ,  I.2.3.  a b c d Follet, Robert H. Sammet, Jean E. 2003. Ralston, Anthony Reilly, Edwin D. Hemmendinger, David eds.. Programming language standards . Encyclopedia of Computer Science 4th ed.. Wiley. p.  1467. ISBN   978-0470864128 .  a b Beyer 2009 , p.  301.  a b Brown 1976 , p.  49.  Brown 1976 , p.  52.  Taylor, Alan 2 August 1972. Few Realise Wasted Resources of Local DP Schools . Computerworld . 6 31 11.  Triance, J. M. 1974. Programming in COBOL A Course of Twelve Television Lectures . Manchester University Press. p.  87. ISBN   978-0719005923 .  Klein 2010 , p.  16.  Baird, George N. Oliver, Paul May 1977. 1974 Standard X3.231974. Programming Language StandardsWho Needs Them PDF Technical report. Department of the Navy . pp.  1921. Archived PDF from the original on 7 January 2014 . Retrieved 7 January 2014 . Cite uses deprecated parameter deadurl  help   Culleton, John R., Jr. 23 July 1975.   Spotty Availability A Problem... Computerworld . 9 30 17. ISSN   0010-4841 . CS1 maint multiple names authors list  link   Simmons, Williams B. 18 June 1975. Does Cobols Report Writer Really Miss the Mark . Computerworld . 9 25 20. ISSN   0010-4841 .  Shoor, Rita 26 January 1981. User Threatens Suit Over Ansi Cobol-80 . Computerworld . 15 4 1, 8. ISSN   0010-4841 .  Shoor, Rita 26 October 1981. DPMA Takes Stand Against Cobol Draft . Computerworld . 15 43 12. ISSN   0010-4841 .  a b c Gallant, John 16 September 1985. Revised Cobol standard may be ready in late 85 . Computerworld . 19 37 1, 8. ISSN   0010-4841 .  a b Expert addresses Cobol 85 standard . Computerworld . 19 37 41, 48. 16 September 1985. ISSN   0010-4841 .  Paul, Lois 15 March 1982. Responses to Cobol-80 Overwhelmingly Negative . Computerworld . 16 11 1, 5. ISSN   0010-4841 .  Paul, Lois 25 April 1983. Study Sees Few Problems Switching to Cobol-8X . Computerworld . 17 17 1, 6.  Gillin, Paul 19 November 1984. DEC users get head start implementing Cobol-80 . Computerworld . 18 47 1, 6. ISSN   0010-4841 .  Garfunkel 1987 , p.  150.  Roy, M. K. Dastidar, D. Ghost 1 June 1989. Features of COBOL-85. COBOL Programming Problems and Solutions 2nd ed.. McGraw-Hill Education. pp.  438451. ISBN   978-0074603185 .  Robinson, Brian 9 July 2009. Cobol remains old standby at agencies despite showing its age . FCW . Public Sector Media Group . Retrieved 26 April 2014 .  a b COBOL Standards . Micro Focus. Archived from the original on 31 March 2004 . Retrieved 2 September 2014 . Cite uses deprecated parameter deadurl  help   NetCOBOL for .Net . netcobol.com . GTSoftware. 2013. Archived from the original on 8 July 2014 . Retrieved 29 January 2014 . Cite uses deprecated parameter deadurl  help   A list of Codasyl Cobol features . Computerworld . 10 September 1984. p.  ID28. ISSN   0010-4841 . Retrieved 8 June 2014 .  ISOIEC JTC 1SC 22WG 4 2001 , Annex F.  Klein 2010 , p.  21.  a b JTC1SC22WG4  COBOL . ISO. 30 June 2010. Archived from the original on 14 February 2014 . Retrieved 27 April 2014 . Cite uses deprecated parameter deadurl  help   Billman, John Klink, Huib 27 February 2008. Thoughts on the Future of COBOL Standardization PDF . Archived from the original PDF on 11 July 2009 . Retrieved 14 August 2014 . Cite uses deprecated parameter deadurl  help   ISOIEC JTC 1SC 22WG 4 2014 , Annex E.  Schricker, Don 2 December 1998. J4 COBOL Standardization . Micro Focus. Archived from the original on 24 February 1999 . Retrieved 12 July 2014 . Cite uses deprecated parameter deadurl  help   Kizior, Ronald J. Carr, Donald Halpern, Paul. Does COBOL Have a Future PDF . The Proceedings of the Information Systems Education Conference 2000 . 17 126. Archived from the original PDF on 17 August 2016 . Retrieved 30 September 2012 . Cite uses deprecated parameter deadurl  help   Carr  Kizior 2003 , p.  16.  Carr  Kizior 2003 , p.  10.  Cobol brain drain Survey results . Computerworld . 14 March 2012 . Retrieved 27 April 2014 .  Powner, David A. 25 May 2016. Federal Agencies Need to Address Aging Legacy Systems PDF . Government Accountability Office . p.  18. Archived from the original pdf on 15 June 2019 . Retrieved 19 July 2019 . Several agencies, such as the Department of Agriculture USDA, DHS, HHS, Justice, Treasury, and VA, reported using Common Business Oriented Language COBOLa programming language developed in the late 1950s and early 1960sto program their legacy systems. It is widely known that agencies need to move to more modern, maintainable languages, as appropriate and feasible.  ISOIEC JTC 1SC 22WG 4 2014 ,  8.9.  Reserved Words Table . Micro Focus Visual COBOL 2.2 COBOL Language Reference . Micro Focus . Retrieved 3 March 2014 .  ISOIEC JTC 1SC 22WG 4 2014 ,  8.3.1.2.  ISOIEC JTC 1SC 22WG 4 2014 ,  8.3.2.  a b c d Shneiderman 1985 , p.  349.  a b ISOIEC JTC 1SC 22WG 4 2001 ,  F.2.  ISOIEC JTC 1SC 22WG 4 2014 ,  D.18.2.  ISOIEC JTC 1SC 22WG 4 2014 ,  D.18.  ISOIEC JTC 1SC 22WG 4 2014 , p.  108.  ISOIEC JTC 1SC 22WG 4 2014 , p.  896.  ISOIEC JTC 1SC 22WG 4 2014 ,  D.2.1.  File Organizations . File Handling . Micro Focus. 1998 . Retrieved 27 June 2014 .  ISOIEC JTC 1SC 22WG 4 2014 ,  8.5.1.2.  Cutler 2014 , Appendix A.  Hubbell, Thane 1999. Sams Teach Yourself COBOL in 24 hours . SAMS Publishing . p.  40. ISBN   978-0672314537 . LCCN   98087215 .  McCracken  Golden 1988 ,  19.9.  Cutler 2014 ,  5.8.5.  ISOIEC JTC 1SC 22WG 4 2014 ,  8.5.2.  a b ISOIEC JTC 1SC 22WG 4 2014 ,  14.9.24.  ISOIEC JTC 1SC 22WG 4 2014 ,  14.9.35.  ISOIEC JTC 1SC 22WG 4 2014 ,  13.18.40.  ISOIEC JTC 1SC 22WG 4 2014 ,  13.18.60.3.  ISOIEC JTC 1SC 22WG 4 2014 , p.  855.  ISOIEC JTC 1SC 22WG 4 2014 ,  14.4.  ISOIEC JTC 1SC 22WG 4 2014 ,  14.6.3.  Field, John Ramalingam, G. September 1999. Identifying Procedural Structure in Cobol Programs PDF . PASTE 99 . doi  10.1145381788.316163 . ISBN   1581131372 .  a b c Veerman, Niels Verhoeven, Ernst-Jan November 2006. Cobol minefield detection PDF . SoftwarePractice and Experience . 36 14. doi  10.1002spe.v3614 . Archived from the original PDF on 6 March 2007. Cite uses deprecated parameter deadurl  help   ISOIEC JTC 1SC 22WG4 2014 ,  14.9.  ISOIEC JTC 1SC 22WG 4 2014 ,  14.9.4, 14.9.22.  ISOIEC JTC 1SC 22WG 4 2014 ,  D.6.5.2.2.  ISOIEC JTC 1SC 22WG 4 2014 ,  14.9.13.1.  ISOIEC JTC 1SC 22WG 4 2014 , 14.9.35.1.  ISOIEC JTC 1SC 22WG 4 2014 , p.  899.  a b McCracken  Golden 1988 ,  8.4.  Examples of compiler support for ALTER can be seen in the following Tiffin, Brian 18 September 2013. September 2014 . GNU Cobol . Retrieved 5 January 2014 . The ALTER Statement . Micro Focus Visual COBOL 2.2 for Visual Studio 2013 COBOL Language Reference . Micro Focus . Retrieved 5 January 2014 . ALTER Statement Nucleus PDF . COBOL85 Reference Manual . Fujitsu. November 1996. p.  555. Archived from the original PDF on 6 January 2014 . Retrieved 5 January 2014 . Cite uses deprecated parameter deadurl  help  ALTER Statement . Enterprise COBOL for zOS Language Reference . IBM. June 2013 . Retrieved 5 January 2014 .  ISOIEC JTC 1SC 22WG 4 2001 ,  F.1.  Moseley, Jay 17 January 2015. COBOL Compiler from MVT . Retrieved 19 July 2015 .  Dijkstra, Edsger W. 18 June 1975. How do we tell truths that might hurt . University of Texas at Austin. EWD498 . Retrieved 29 August 2007 .  Tompkins, H. E. 1983. In defense of teaching structured COBOL as computer science. ACM SIGPLAN Notices . 18 4 8694. doi  10.1145948176.948186 .  a b Riehle 1992 , p.  125.  Shneiderman 1985 , pp.  349350.  Coughlan, Michael 16 March 2014. Beginning COBOL for Programmers . Apress. p.  4. ISBN   978-1430262534 . Retrieved 13 August 2014 .  Sammet 1978b , p.  258.  Riehle 1992 , p.  126.  Riehle 1992 , p.  127.  COBOL and Legacy Code as a Systemic Risk  naked capitalism . 19 July 2016 . Retrieved 23 July 2016 .  Lmmel, Ralf Verhoef, Chris NovemberDecember 2001. Cracking the 500-language problem PDF . IEEE Software . 18 6 79. doi  10.110952.965809 . Archived from the original PDF on 19 August 2014. Cite uses deprecated parameter deadurl  help   Howkins, T. J. Harandi, M. T. April 1979. Towards more portable COBOL . The Computer Journal . 22 4 290. doi  10.1093comjnl22.4.290 .  Garfunkel 1987 , p.  11.  Garfunkel 1987 , p.  15.  Raymond, Eric S. 1 October 2004. COBOL . The Jargon File, version 4.4.8 . Archived from the original on 30 August 2014 . Retrieved 13 December 2014 . Cite uses deprecated parameter deadurl  help   Brown 1976 , p.  53.  CODASYL 1969 ,  II.1.1.  Shneiderman 1985 , p.  350.  Sammet 1961 , p.  381.  a b Conner 1984 , p.  ID10.  Marcotty 1978 , p.  263.  Conner 1984 , p.  ID14.  Sammet 1961 , p.  380.  Marcotty 1978 , p.  266.  Sammet 1978b , p.  255.  Shneiderman 1985 , pp.  348349.  httpsbooks.bibliopolis.commainfind2200821COBOL-Logic-and-Programming-third-edition-1974-McCameron-Fritz-oldcomputerbooks-com.html  Shneiderman 1985 , p.  351.  An interview Cobol defender . Computerworld . 10 September 1984. pp.  ID29ID32. ISSN   0010-4841 . Retrieved 8 June 2014 .  Academia needs more support to tackle the IT skills gap Press release. Micro Focus. 7 March 2013 . Retrieved 4 August 2014 .  Carr  Kizior 2003 , p.  13.  Sammet, Jean Garfunkel, Jerome October 1985. Summary of Changes in COBOL, 19601985. Annals of the History of Computing . 7 4 342. doi  10.1109MAHC.1985.10033 .  Cook, Margaret M. June 1978. Ghosh, Sakti P. Liu, Leonard Y. eds.. Data Base Facility for COBOL 80 PDF . 1978 National Computer Conference. Anaheim, California AFIPS Press. pp.  11071112. doi  10.1109AFIPS.1978.63 . LCCN   55-44701 . Retrieved 2 September 2014 . The earliest date that a new COBOL standard could be developed and approved is the year 1980 ....  Resolutions from WG4 meeting 24  June 2628, 2003 Las Vegas, Nevada, USA . 11 July 2003. p.  1. Archived from the original doc on 8 March 2016 . Retrieved 29 June 2014 . a June 2008 revision of the COBOL standard Cite uses deprecated parameter deadurl  help   Babcock, Charles 14 July 1986. Cobol standard add-ons flayed . Computerworld . 20 28 1, 12.  Marcotty, Michael 1978. Wexelblat, Richard L. ed.. Full text of all questions submitted . History of Programming Languages. Academic Press published 1981. p.  274. doi  10.1145800025.1198371 . ISBN   0127450408 .  This can be seen in Visual COBOL . IBM PartnerWorld . IBM . 21 August 2013. Archived from the original on 12 July 2014 . Retrieved 5 February 2014 . Micro Focus Visual COBOL delivers the next generation of COBOL development and deployment for Linux x86-64, Linux for System z, AIX, HPUX, Solaris, and Windows. Cite uses deprecated parameter deadurl  help  COBOL Compilers family . ibm.com . IBM . Archived from the original on 23 February 2014 . Retrieved 5 February 2014 . Cite uses deprecated parameter deadurl  help  Tiffin, Brian 4 January 2014. What platforms are supported by GNU Cobol . Archived from the original on 14 December 2013 . Retrieved 5 February 2014 . Cite uses deprecated parameter deadurl  help   Coughlan, Michael 2002. Introduction to COBOL . Retrieved 3 February 2014 . Sources  edit  .mw-parser-output .refbeginfont-size90margin-bottom0.5em.mw-parser-output .refbegin-hanging-indentsullist-style-typenonemargin-left0.mw-parser-output .refbegin-hanging-indentsulli,.mw-parser-output .refbegin-hanging-indentsdlddmargin-left0padding-left3.2emtext-indent-3.2emlist-stylenone.mw-parser-output .refbegin-100font-size100 Bemer, Bob 1971. A View of the History of COBOL PDF . Honeywell Computer Journal . 5 3. Archived from the original PDF on 22 January 2016 . Retrieved 28 June 2014 . Cite uses deprecated parameter dead-url  help  Beyer, Kurt 2009. Grace Hopper and the Invention of the Information Age . MIT Press. ISBN   978-0262013109 . LCCN   2008044229 . Brown, William R. 1 December 1976. COBOL. In Belzer, Jack Holzman, Albert G. Kent, Allen eds.. Encyclopedia of Computer Science and Technology Volume 5 . CRC Press . ISBN   978-0824722555 . Carr, Donald E. Kizior, Ronald J. 31 December 2003. Continued Relevance of COBOL in Business and Academia Current Situation and Comparison to the Year 2000 Study PDF . Information Systems Education Journal . 1 52. ISSN   1545-679X . Retrieved 4 August 2014 . CODASYL July 1969. CODASYL COBOL Journal of Development 1968 . National Bureau of Standards . ISSN   0591-0218 . LCCN   73601243 . Cite journal requires journal  help  Conner, Richard L. 14 May 1984. Cobol, your age is showing . Computerworld . 18 20 ID7ID18. ISSN   0010-4841 . Cutler, Gary 9 April 2014. GNU COBOL Programmers Guide PDF 3rd ed. . Retrieved 25 February 2014 . Garfunkel, Jerome 1987. The COBOL 85 Example Book . Wiley . ISBN   978-0471804611 . ISOIEC JTC 1SC 22WG 4 4 December 2001. ISOIEC IS 19892001  Programming language COBOL . ISO . Archived from the original ZIP of PDF on 24 January 2002 . Retrieved 2 September 2014 . Cite uses deprecated parameter deadurl  help  ISOIEC JTC 1SC 22WG 4 31 October 2014. INCITSISOIEC 19892014 2014  Programming language COBOL . INCITS . Klein, William M. 4 October 2010. The History of COBOL PDF . Archived from the original PDF on 7 January 2014 . Retrieved 7 January 2014 . Cite uses deprecated parameter deadurl  help  Marcotty, Michael 1978. Wexelblat, Richard L. ed.. Transcript of question and answer session . History of Programming Languages. Academic Press published 1981. p.  263. doi  10.1145800025.1198370 . ISBN   0127450408 . McCracken, Daniel D.  Golden, Donald G. 1988. A Simplified Guide to Structured COBOL Programming 2nd ed.. Wiley. ISBN   978-0471610540 . LCCN   87034608 . Riehle, Richard L. August 1992. PERFORM considered harmful. Communications of the ACM . 35 8 125128. doi  10.1145135226.376106 . Sammet, Jean E. May 1961. A method of combining ALGOL and COBOL . Papers presented at the 911 May 1961, western joint IREAIEEACM computer conference. ACM . pp.  379387. doi  10.11451460690.1460734 . Sammet, Jean E. 1978a. Wexelblat, Richard L. ed.. The early history of COBOL . History of Programming Languages. Academic Press published 1981. doi  10.1145800025.1198367 . ISBN   0127450408 . Sammet, Jean E. 1978b. Wexelblat, Richard L. ed.. Transcript of presentation . History of Programming Languages. Academic Press published 1981. doi  10.1145800025.1198368 . ISBN   0127450408 . Sammet, Jean E. 23 July 2004. COBOL. In Reilly, Edwin D. ed.. Concise Encyclopedia of Computer Science . Wiley. ISBN   978-0470090954 . OCLC   249810423 . Shneiderman, B. October 1985. The Relationship Between COBOL and Computer Science. Annals of the History of Computing . 7 4 348352. doi  10.1109MAHC.1985.10041 . External links  edit  COBOL at Wikipedias sister projects Definitions from Wiktionary Media from Wikimedia Commons Textbooks from Wikibooks Resources from Wikiversity Data from Wikidata COBOL at Curlie v t e Programming languages Comparison Timeline History APL Assembly BASIC C C C COBOL Elixir Fortran Go Groovy Haskell Java JavaScript JS Julia Kotlin Lisp Lua MATLAB Objective-C OCaml Pascal Perl PHP Python R Ruby Rust Scala Shell Smalltalk Swift TypeScript Visual Basic .NET VB.NET more... Category Lists Alphabetical Categorical Generational Non-English-based v t e ISO standards .mw-parser-output .noboldfont-weightnormal by standard number List of ISO standards   ISO romanizations   IEC standards 19999 1 2 3 4 5 6 7 9 16 17 31 -0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 128 216 217 226 228 233 259 269 302 306 361 428 500 518 519 639 -1 -2 -3 -5 -6 646 657 668 690 704 732 764 838 843 860 898 965 999 1000 1004 1007 1073-1 1155 1413 1538 1629 1745 1989 2014 2015 2022 2033 2047 2108 2145 2146 2240 2281 2533 2709 2711 2720 2788 2848 2852 3029 3103 3166 -1 -2 -3 3297 3307 3601 3602 3864 3901 3950 3977 4031 4157 4165 4217 4909 5218 5426 5427 5428 5725 5775 5776 5800 5807 5964 6166 6344 6346 6385 6425 6429 6438 6523 6709 6943 7001 7002 7010 7027 7064 7098 7185 7200 7498 -1 7637 7736 7810 7811 7812 7813 7816 7942 8000 8093 8178 8217 8373 8501-1 8571 8583 8601 8613 8632 8651 8652 8691 88058806 8807 8820-5 8859 -1 -2 -3 -4 -5 -6 -7 -8 -8-I -9 -10 -11 -12 -13 -14 -15 -16 8879 90009001 9036 9075 9126 9141 9227 9241 9293 9314 9362 9407 9506 9529 9564 95929593 9594 9660 9797-1 9897 9899 9945 9984 9985 9995 1000019999 10005 10006 10007 10116 10118-3 10160 10161 10165 10179 10206 10218 10303 -11 -21 -22 -28 -238 10383 10487 10585 10589 10646 10664 10746 10861 10957 10962 10967 11073 11170 11179 11404 11544 11783 11784 11785 11801 11898 11940  -2  11941 11941 TR 11992 12006 12182 12207 12234-2 13211 -1 -2 13216 13250 13399 13406-2 13450 13485 13490 13567 13568 13584 13616 14000 14031 14224 14289 14396 14443 14496 -2 -3 -6 -10 -11 -12 -14 -17 -20 14644 14649 14651 14698 14750 14764 14882 14971 15022 15189 15288 15291 15292 15398 15408 15444 -3 15445 15438 15504 15511 15686 15693 15706 -2 15707 15897 15919 15924 15926 15926 WIP 15930 16023 16262 16355-1 16612-2 16750 16949 TS 17024 17025 17100 17203 17369 17442 17799 18000 18004 18014 18245 18629 18916 19005 19011 19092 -1 -2 19114 19115 19125 19136 19407 19439 19500 19501 19502 19503 19505 19506 19507 19508 19509 19510 19600 19752 19757 19770 19775-1 19794-5 19831 20000 20000 20022 20121 20400 21000 21047 21500 218272002 22000 23270 23271 23360 24517 24613 24617 24707 25178 25964 26000 26262 26300 26324 27000 series 27000 27001 27002 27006 27729 28000 29110 29148 29199-2 29500 30170 31000 32000 37001 38500 40500 42010 45001 50001 55000 80000 -1 -2 -3 Category Authority control BNF  cb11941315s data GND  4010323-7 LCCN  sh85027548 Retrieved from  httpsen.wikipedia.orgwindex.phptitleCOBOL oldid912344478  Categories  COBOL .NET programming languages 1959 software Class-based programming languages Computer-related introductions in 1959 Cross-platform software Object-oriented programming languages Procedural programming languages Programming languages created by women Programming languages created in 1959 Programming languages with an ISO standard Statically typed programming languages Structured programming languages Hidden categories CS1 errors deprecated parameters CS1 maint multiple names authors list Articles with short description Use dmy dates from April 2019 Good articles Use American English from October 2014 All Wikipedia articles written in American English All articles with unsourced statements Articles with unsourced statements from October 2017 Articles with unsourced statements from March 2014 All articles lacking reliable references Articles lacking reliable references from January 2015 Articles with specifically marked weasel-worded phrases from March 2014 Articles with unsourced statements from March 2017 CS1 errors missing periodical Articles with Curlie links Wikipedia articles with BNF identifiers Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers