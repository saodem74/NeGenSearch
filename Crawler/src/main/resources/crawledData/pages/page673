PLI From Wikipedia, the free encyclopedia Jump to navigation Jump to search New programming language redirects here. For the process of implementing new programming languages, see Programming language design   Design and implementation . PLI Paradigm Procedural , imperative , structured Designed  by IBM and the SHARE Language Development Committee Developer IBM First  appeared 1964 Stable release IBM Enterprise PLI for zOS 5.2 1   September 2017 Website bitsavers .trailing-edge .com pdf ibm 360 pli  Dialects PLM , XPL , PLP , PLC , PLS , PLAS , PLX , PL-6 , PL8, EPL Influenced by COBOL , Fortran , ALGOL Influenced CMS-2 , SPk , B , REXX , AS400 Control Language PLI at Wikibooks PLI  Programming Language One , pronounced  p i  l w  n   is a procedural , imperative computer programming language developed and published by IBM . It is designed for scientific, engineering, business and system programming. It has been used by academic, commercial and industrial organizations since it was introduced in the 1960s, and is still used. 2  PLIs main domains are data processing , numerical computation , scientific computing , and system programming . It supports recursion , structured programming , linked data structure handling, fixed-point , floating-point , complex , character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them. Contents 1 Early history 2 Goals and principles 3 Language summary 4 Standardization 5 Implementations 5.1 IBM PLI F and D compilers 5.2 Multics PLI and derivatives 5.3 IBM PLI optimizing and checkout compilers 5.4 Digital PLI 5.5 Teaching subset compilers 5.6 IBM PLI for OS2, AIX, Linux, zOS 5.6.1 Object orientation 5.6.2 Competitiveness on PC and with C 5.6.3 Program readability  making intentions explicit 5.6.4 Structured programming additions 5.6.5 Interrupt handling 5.7 Other mainframe and minicomputer compilers 5.8 PLI compilers for Microsoft .NET 5.9 PLI compilers for personal computers and Unix 5.10 Special purpose and system PLI compilers 5.11 PLI dialect compilers 6 Usage 7 Evolution of the PLI language 7.1 Significant features omitted from the standard 7.1.1 Multi tasking 7.1.2 Preprocessor 7.1.3 Structured programming additions 7.1.4 Debug facilities 7.2 Significant features developed since the standard 8 Criticisms 8.1 Implementation issues 8.2 Programmer issues 9 Special topics in PLI 9.1 Storage classes 9.2 Storage type sharing 9.3 ON-units and exception handling 10 Sample programs 10.1 Hello world program 10.2 Search for a string 11 See also 12 Notes 13 References 13.1 Textbooks 13.2 Standards 13.3 Reference manuals 14 External links Early history  edit  In the 1950s and early 1960s, business and scientific users programmed for different computer hardware using different programming languages. Business users were moving from Autocoders via COMTRAN to COBOL , while scientific users programmed in General Interpretive Programme GIP, Fortran , ALGOL , GEORGE , and others. The IBM System360 3  announced in 1964 and delivered in 1966 was designed as a common machine architecture for both groups of users, superseding all existing IBM architectures. Similarly, IBM wanted a single programming language for all users. It hoped that Fortran could be extended to include the features needed by commercial programmers. In October 1963 a committee was formed 4  composed originally of three IBMers from New York and three members of SHARE , the IBM scientific users group, to propose these extensions to Fortran. Given the constraints of Fortran, they were unable to do this and embarked on the design of a new programming language based loosely on ALGOL labeled NPL. This acronym conflicted with that of the UKs National Physical Laboratory and was replaced briefly by MPPL MultiPurpose Programming Language and, in 1965, with PLI with a Roman numeral I. The first definition appeared in April 1964. 5  6  IBM took NPL as a starting point and completed the design to a level that the first compiler could be written the NPL definition was incomplete in scope and in detail. 7  Control of the PLI language 8  was vested initially in the New York Programming Center and later at the IBM UK Laboratory at Hursley . The SHARE and GUIDE user groups were involved in extending the language and had a role in IBMs process for controlling the language through their PLI Projects. The experience of defining such a large language showed the need for a formal definition of PLI. A project was set up in 1967 in IBM Laboratory Vienna to make an unambiguous and complete specification. 9  This led in turn to one of the first large scale Formal Methods for development, VDM . Fred Brooks is credited with ensuring PLI had the CHARACTER data type. 10  The language was first specified in detail in the manual PLI Language Specifications. C28-6571 written in New York from 1965 and superseded by PLI Language Specifications. GY33-6003 written in Hursley from 1967. IBM continued to develop PLI in the late sixties and early seventies, publishing it in the GY33-6003 manual. These manuals were used by the Multics group and other early implementers. The first compiler was delivered in 1966. The Standard for PLI was approved in 1976. Goals and principles  edit  The goals for PLI evolved during the early development of the language. Competitiveness with COBOLs record handling and report writing was required. The languages scope of usefulness grew to include system programming and event-driven programming . Additional goals for PLI were 3  Performance of compiled code competitive with that of Fortran but this was not achieved  citation needed  Extensibility for new hardware and new application areas Improved productivity of the programming process, transferring effort from the programmer to the compiler Machine independence to operate effectively on the main computer hardware and operating systems To achieve these goals, PLI borrowed ideas from contemporary languages while adding substantial new capabilities and casting it with a distinctive concise and readable syntax. Many principles and capabilities combined to give the language its character and were important in meeting the languages goals Block structure , with underlying semantics including recursion , similar to Algol 60 . Arguments are passed using call by reference , using dummy variables for values where needed  call by value . A wide range of computational data types, program control data types, and forms of data structure  strong typing . Dynamic extents for arrays and strings with inheritance of extents by procedure parameters. Concise syntax for expressions, declarations, and statements with permitted abbreviations. Suitable for a character set of 60 glyphs and sub-settable to 48. An extensive structure of defaults in statements, options, and declarations to hide some complexities and facilitate extending the language while minimizing keystrokes. Powerful iterative processing with good support for structured programming . There were to be no reserved words although the function names DATE and TIME , proved to be impossible to meet this goal. New attributes, statements and statement options could be added to PLI without invalidating existing programs. Not even IF, THEN, ELSE , and DO were reserved. 11  Orthogonality  each capability to be independent of other capabilities and freely combined with other capabilities wherever meaningful. Each capability to be available in all contexts where meaningful, to exploit it as widely as possible and to avoid arbitrary restrictions. Orthogonality helps makes the language large.  clarification needed  Exception handling capabilities for controlling and intercepting exceptional conditions at run time. Programs divided into separately compilable sections, with extensive compile-time facilities a.k.a. macros , not part of the standard, for tailoring and combining sections of source code into complete programs. External names to bind separately compiled procedures into a single program. Debugging facilities integrated into the language. Language summary  edit  The language is designed to be all things to all programmers. 12  The summary is extracted from the ANSI PLI Standard 13  and the ANSI PLI General-Purpose Subset Standard. 14  A PLI program consists of a set of procedures, each of which is written as a sequence of statements. The INCLUDE construct is used to include text from other sources during program translation. All of the statement types are summarized here in groupings which give an overview of the language the Standard uses this organization. Category Statement Structural PROCEDURE or PROC  ENTRY BEGIN DO END Declarative DECLARE or DCL  DEFAULT or DFT  FORMAT Flow of control CALL IF SELECT GO TO RETURN STOP Null statement Category Statement Interrupt handling ON SIGNAL REVERT Storage ALLOCATE or ALLOC  FREE Assignment statement InputOutput OPEN CLOSE Stream inputoutput GET PUT Record inputoutput READ WRITE REWRITE LOCATE DELETE Features such as multi-tasking and the PLI preprocessor are not in the Standard but are supported in the PLI F compiler and some other implementations are discussed in the Language evolution section. Names may be declared to represent data of the following types, either as single values, or as aggregates in the form of arrays, with a lower-bound and upper-bound per dimension, or structures comprising nested structure, array and scalar variables Arithmetic expanded below CHARACTER PICTURE for Arithmetic data PICTURE for Character data AREA BIT ENTRY FILE FORMAT LABEL OFFSET POINTER The arithmetic type comprises these attributes a base  BINARY or DECIMAL , and a scale  FIXED or FLOAT , and a mode  REAL or COMPLEX , and a PRECISION  number of digits , and for fixed point numbers, a scale factor  The base, scale, precision and scale factor of the Picture-for-arithmetic type is encoded within the picture-specification . The mode is specified separately, with the picture specification applied to both the real and the imaginary parts. Values are computed by expressions written using a specific set of operations and builtin functions, most of which may be applied to aggregates as well as to single values, together with user-defined procedures which, likewise, may operate on and return aggregate as well as single values. The assignment statement assigns values to one or more variables. There are no reserved words in PLI. A statement is terminated by a semi-colon. The maximum length of a statement is implementation defined. A comment may appear anywhere in a program where a space is permitted and is preceded by the characters forward slash, asterisk and is terminated by the characters asterisk, forward slash i.e.  This is a comment.  . Statements may have a label-prefix introducing an entry name  ENTRY and PROCEDURE statements or label name, and a condition prefix enabling or disabling a computational condition    e.g. NOSIZE . Entry and label names may be single identifiers or identifiers followed by a subscript list of constants as in L12,2A0 . A sequence of statements becomes a group when preceded by a DO statement and followed by an END statement. Groups may include nested groups and begin blocks. The IF statement specifies a group or a single statement as the THEN part and the ELSE part see the sample program. The group is the unit of iteration. The begin block  BEGIN stmt-list END  may contain declarations for names and internal procedures local to the block. A procedure starts with a PROCEDURE statement and is terminated syntactically by an END statement. The body of a procedure is a sequence of blocks, groups, and statements and contains declarations for names and procedures local to the procedure or EXTERNAL to the procedure. An ON-unit is a single statement or block of statements written to be executed when one or more of these conditions occur a computational condition , CONVERSION CONV FIXEDOVERFLOW FOFL OVERFLOW OFL SIZE STRINGRANGE STRG STRINGSIZE STRZ SUBSCRIPTRANGE SUBRG UNDERFLOW UFL ZERODIVIDE ZDIV or an InputOutput condition, ENDFILEfile ENDPAGEfile KEYfile NAMEfile RECORDfile TRANSMITfile UNDEFINEDFILEfile UNDF or one of the conditions AREA , CONDITION identifier , ERROR , FINISH A declaration of an identifier may contain one or more of the following attributes but they need to be mutually consistent Data Attributes InputOutput Attributes Other Attributes ALIGNED DIRECT AUTOMATIC or AUTO AREAarea-size ENVIRONMENToptions or ENV... BASEDreference BINARY precision or BIN... INPUT BUILTIN BIT maximum-length KEYED CONDITION or COND CHARACTERmaximum-length or CHAR... OUTPUT CONSTANT COMPLEX precision or CPLX... PRINT CONTROLLED or CTL DECIMAL precision or DEC... SEQUENTIAL or SEQL DEFINEDreference or DEF... dimension-attribute STREAM EXTERNAL or EXT ENTRYparameter descriptor list UPDATE GENERICcriteria list FILE RECORD INITIALvalue-list or INIT... FIXED precision INTERNAL or INT FLOAT number of digits LIKE unsubscripted reference FORMAT LOCAL LABEL OPTIONSoptions MEMBER PARAMETER or PARM NONVARYING or NONVAR POSITION expression or POS... OFFSETreference STATIC PICTURE picture-specification or PIC... VARIABLE POINTER or PTR STRUCTURE UNALIGNED or UNAL VARYING or VAR Current compilers from Kednos, Micro Focus , and particularly that from IBM implement many extensions over the standardized version of the language. The IBM extensions are summarised in the Implementation sub-section for the compiler later. Although there are some extensions common to these compilers the lack of a current standard means that compatibility is not guaranteed. Standardization  edit  Language standardization began in April 1966 in Europe with ECMA TC10. In 1969 ANSI established a Composite Language Development Committee, nicknamed Kludge, later renamed X3J1 PLI. 15  Standardization became a joint effort of ECMA TC10 and ANSI X3J1. A subset of the GY33-6003 16  document was offered to the joint effort by IBM and became the base document for standardization. The major features omitted from the base document were multitasking and the attributes for program optimization e.g. NORMAL and ABNORMAL . Proposals to change the base document were voted upon by both committees. In the event that the committees disagreed, the chairs, initially Michael Marcotty of General Motors and C.A.R. Hoare representing ICL had to resolve the disagreement. In addition to IBM, Honeywell , CDC , Data General , Digital Equipment , Prime Computer , Burroughs , RCA , and Univac served on X3J1 along with major users Eastman Kodak , MITRE , Union Carbide , Bell Laboratories , and various government and university representatives. Further development of the language occurred in the standards bodies, with continuing improvements in structured programming and internal consistency, and with the omission of the more obscure or contentious features. As language development neared an end, X3J1TC10 realized that there were a number of problems with a document written in English text. Discussion of a single item might appear in multiple places which might or might not agree. It was difficult to determine if there were omissions as well as inconsistencies. Consequently, David Beech IBM, Robert Freiburghouse Honeywell, Mil ton Barber CDC, M. Donald MacLaren  Argonne National Laboratory , Craig Franklin Data General, Lois Frampton Digital Equipment, and editor, D.J. Andrews of IBM undertook to rewrite the entire document, each producing one or more complete chapters. The standard is couched as a formal definition 13  using a PLI Machine 17  to specify the semantics. It was the first, and possibly the only, programming language standard to be written as a semi-formal definition. A PLI General-Purpose Subset Subset-G standard was issued by ANSI in 1981 14  and a revision published in 1987. 18  The General Purpose subset was widely adopted as the kernel for PLI implementations. Implementations  edit  IBM PLI F and D compilers  edit  PLI was first implemented by IBM, at its Hursley Laboratories in the United Kingdom, as part of the development of System360 . The first production PLI compiler was the PLI F compiler for the OS360 Operating System, built by John Nashs team at Hursley in the UK the runtime library team was managed by I.M. Nobby Clarke. The PLI F compiler was written entirely in System360 assembly language. 19  Release 1 shipped in 1966. OS360 is a real-memory environment and the compiler was designed for systems with as little as 64 kilobytes of real storage  F being 64 kB in S360 parlance. To fit a large compiler into the 44 kilobytes of memory available on a 64-kilobyte machine, the compiler consists of a control phase and a large number of compiler phases approaching 100. The phases are brought into memory from disk, one at a time, to handle particular language features and aspects of compilation. Each phase makes a single pass over the partially-compiled program, usually held in memory. 20  Aspects of the language were still being designed as PLI F was implemented, so some were omitted until later releases. PLI RECORD IO was shipped with PLI F Release 2. The list processing functions 21     Based Variables, Pointers, Areas and Offsets and LOCATE-mode IO    were first shipped in Release 4. In a major attempt to speed up PLI code to compete with Fortran object code, PLI F Release 5 does substantial program optimization of DO-loops facilitated by the REORDER option on procedures. A version of PLI F was released on the TSS360 timesharing operating system for the System360 Model 67 , adapted at the IBM Mohansic Lab. The IBM La Gaude Lab in France developed Language Conversion Programs 22  to convert Fortran, Cobol, and Algol programs to the PLI F level of PLI. The PLI D compiler, using 16 kilobytes of memory, was developed by IBM Germany for the DOS360 low end operating system. It implements a subset of the PLI language requiring all strings and arrays to have fixed extents, thus simplifying the run-time environment. Reflecting the underlying operating system, it lacks dynamic storage allocation and the controlled storage class. 23  It was shipped within a year of PLI F. Multics PLI and derivatives  edit  Compilers were implemented by several groups in the early 1960s. The Multics project at MIT , one of the first to develop an operating system in a high-level language, used Early PLI EPL, a subset dialect of PLI, as their implementation language in 1964. EPL was developed at Bell Labs and MIT by Douglas McIlroy , Robert Morris , and others. The influential Multics PLI compiler 24  was the source of compiler technology used by a number of manufacturers and software groups. The Honeywell PLI compiler for Series 60 is an implementation of the full ANSI X3J1 standard. 25  IBM PLI optimizing and checkout compilers  edit  The PLI Optimizer and Checkout compilers produced in Hursley support a common level of PLI language 26  and aimed to replace the PLI F compiler. The checkout compiler is a rewrite of PLI F in BSL, IBMs PLI-like proprietary implementation language later PLS . 19  The performance objectives set for the compilers are shown in an IBM presentation to the BCS. 27  The compilers had to produce identical results    the Checkout Compiler is used to debug programs that would then be submitted to the Optimizer. Given that the compilers had entirely different designs and were handling the full PLI language this goal was challenging it was achieved. The PLI optimizing compiler took over from the PLI F compiler and was IBMs workhorse compiler from the 1970s to the 1990s. Like PLI F, it is a multiple pass compiler with a 44 kilobyte design point, but it is an entirely new design. Unlike the F compiler, it has to perform compile time evaluation of constant expressions using the run-time library, reducing the maximum memor y for a compiler phase to 28 kilobytes. A second-time around design, it succeeded in eliminating the annoyances of PLI F such as cascading diagnostics. It was written in S360 Macro Assembler by a team, led by Tony Burbridge, most of whom had worked on PLI F. Macros were defined to automate common compiler services and to shield the compiler writers from the task of managing real-mode storage, allowing the compiler to be moved easily to other memory models. The gamut of program optimization techniques developed for the contemporary IBM Fortran H compiler were deployed the Optimizer equaled Fortran execution speeds in the hands of good programmers. Announced with IBM S370 in 1970, it shipped first for the DOS360 operating system in August 1971, and shortly afterward for OS360, and the first virtual memory IBM operating systems OSVS1 , MVS , and VMCMS . The developers were unaware that while they were shoehorning the code into 28 kb sections, IBM Poughkeepsie was finally ready to ship virtual memory support in OS360. It supported the batch programming environments and, under TSO and CMS, it could be run interactively. This compiler went through many versions covering all mainframe operating systems including the operatin g systems of the Japanese plug-compatible machines PCMs. The compiler has been superseded by IBM PLI for OS2, AIX, Linux, zOS below. The PLI checkout compiler, 28  29  colloquially The Checker announced in August 1970 was designed to speed and improve the debugging of PLI programs. The team was led by Brian Marks. The three-pass design cut the time to compile a program to 25 of that taken by the F Compiler. It can be run from an interactive terminal, converting PLI programs into an internal format, H-text. This format is interpreted by the Checkout compiler at run-time, detecting virtually all types of errors. Pointers are represented in 16 bytes, containing the target address and a description of the referenced item, thus permitting bad pointer use to be diagnosed. In a conversational environment when an error is detected, control is passed to the user who can inspect any variables, introduce debugging statements and edit the source program. Over time the debugging capability of mainframe programming environments developed most of the functions offered by this compiler and it was withdrawn in the 1990s Digital PLI  edit  Perhaps the most commercially successful implementation aside from IBMs was Digital Equipments 1988 release of the ANSI PLI 1987 subset. The implementation is a strict superset of the ANSI X3.4-1981 PLI General Purpose Subset and provides most of the features of the new ANSI X3.74-1987 PLI General Purpose Subset. 30  The front end was designed by Robert Freiburghouse, and the code generator was implemented by Dave Cutler , who managed the design and implementation of VAXVMS . It runs on VMS on VAX and Alpha and on Tru64 . UniPrise Systems , Inc., was responsible for the compiler 31  Teaching subset compilers  edit  In the late 1960s and early 1970s, many US and Canadian universities were establishing time-sharing services on campus and needed conversational compilerinterpreters for use in teaching science, mathematics, engineering, and computer science. Dartmouth were developing BASIC , but PLI was a popular choice, as it was concise and easy to teach. As the IBM offerings were unsuitable, 32  a number of schools built their own subsets of PLI and their own interactive support. Examples are A compiler developed at Cornell University for teaching a dialect called PLC , which had the unusual capability of never failing to compile any program through the use of extensive automatic correction of many syntax errors and by converting any remaining syntax errors to output statements. The language was almost all of PLI as implemented by IBM. 33  PLC was a very fast compiler. PLAGO, created at the Polytechnic Institute of Brooklyn , used a simplified subset of the PLI language 34  and focused on good diagnostic error messages and fast compilation times. The Computer Systems Research Group of the University of Toronto produced the SPk compilers which supported a sequence of subsets of PLI called SP1, SP2, SP3, ..., SP8 for teaching programming. Programs that ran without errors under the SPk compilers produced the same results under other contemporary PLI compilers such as IBMs PLI F compiler, IBMs checkout compiler or Cornell Universitys PLC compiler. 35  Other examples are PL0 by P. Grouse at the University of New South Wales, PLUM by Marvin Zelkowitz at the University of Maryland., 36  and PLUTO from the University of Toronto. IBM PLI for OS2, AIX, Linux, zOS  edit  In a major revamp of PLI, IBM Santa Teresa in California launched an entirely new compiler in 1992. The initial shipment was for OS2 and included most ANSI-G features and many new PLI features. 37  Subsequent releases covered additional platforms  MVS , VM , OS390 , AIX and Windows -although support for Windows has since been withdrawn 38  and continued to add functions to make PLI fully competitive with other languages offered on the PC particularly C and C in areas where it had been overtaken. The corresponding IBM Language Environment supports inter-operation of PLI programs with Database and Transaction systems, and with programs written in C, C, and COBOL, the compiler supports all the data types needed for intercommunication with these languages. The PLI design principles were retained and withstood this major extension comprising several new data types, new statements and statement options, new exception conditions, and new organisations of program source. The resulting language is a compatible super-set of the PLI Standard and of the earlier IBM compilers. Major topics added to PLI were New attributes for better support of object-oriented programming  the DEFINE ALIAS , ORDINAL , and DEFINE STRUCTURE statement to introduce user-defined types, the HANDLE locator data type, the TYPE data type itself, the UNION data type, and built-in functions for manipulating the new types. Additional data types and attributes corresponding to common PC data types e.g. UNSIGNED , VARYINGZ . Improvements in readability of programs  often rendering implied usages explicit e.g. BYVALUE attribute for parameters Additional structured programming constructs. Interrupt handling additions. Compile time preprocessor extended to offer almost all PLI string handling features and to interface with the Application Development Environment The latest series of PLI compilers for zOS, called Enterprise PLI for zOS, leverage code generation for the latest zArchitecture processors z14, z13, zEC12, zBC12, z196, z114 via the use of ARCHLVL parm control passed during compilation, and was the second High level language supported by zOS Language Environment to do so XL CC being the first, and Enterprise COBOL v5 the last. Object orientation  edit  ORDINAL is a new computational data type. The ordinal facilities are like those in Pascal , e.g. DEFINE ORDINAL Colour red, yellow, green, blue, violet but in addition the name and internal values are accessible via built-in functions. Built-in functions provide access to an ordinal values predecessor and successor. The DEFINE-statement see below allows additional TYPE s to be declared composed from PLIs built-in attributes. The HANDLEdata structure locator data type is similar to the POINTER data type, but strongly typed to bind only to a particular data structure. The   operator is used to select a data structure using a handle. The UNION attribute equivalent to CELL in early PLI specifications permits several scalar variables, arrays, or structures to share the same storage in a unit that occupies the amount of storage needed for the largest alternative. Competitiveness on PC and with C  edit  These attributes were added The string attributes VARYINGZ for zero-terminated character strings, HEXADEC , WIDECHAR , and GRAPHIC . The optional arithmetic attributes UNSIGNED and SIGNED , BIGENDIAN and LITTLEENDIAN . UNSIGNED necessitated the UPTHRU and DOWNTHRU option on iterative groups enabling a counter-controlled loop to be executed without exceeding the limit value also essential for ORDINAL s and good for documenting loops. The DATEpattern attribute for controlling date representations and additions to bring time and date to best current practice. New functions for manipulating dates include    DAYS and DAYSTODATE for converting between dates and number of days, and a general DATETIME function for changing date formats. New string-handling functions were added    to centre text, to edit using a picture format, and to trim blanks or selected characters from the head or tail of text, VERIFYR to VERIFY from the right. and SEARCH and TALLY functions. Compound assignment operators a la C e.g.  ,  , - ,  were added. A1 is equivalent to AA1 . Additional parameter descriptors and attributes were added for omitted arguments and variable length argument lists. Program readability  making intentions explicit  edit  The VALUE attribute declares an identifier as a constant derived from a specific literal value or restricted expression. Parameters can have the BYADDR pass by address or BYVALUE pass by value attributes. The ASSIGNABLE and NONASSIGNABLE attributes prevent unintended assignments. DO FOREVER obviates the need for the contrived construct DO WHILE  1B  . The DEFINE-statement introduces user-specified names e.g. INTEGER  for combinations of built-in attributes e.g. FIXED BINARY31,0 . Thus DEFINE ALIAS INTEGER FIXED BINARY31.0 creates the TYPE name INTEGER as an alias for the set of built-in attributes FIXED BINARY31.0. DEFINE STRUCTURE applies to structures and their members it provides a TYPE name for a set of structure attributes and corresponding substructure member declarations for use in a structure declaration a generalisation of the LIKE attribute. Structured programming additions  edit  A LEAVE statement to exit a loop, and an ITERATE to continue with the next iteration of a loop. UPTHRU and DOWNTHRU options on iterative groups. The package construct consisting of a set of procedures and declarations for use as a unit. Variables declared outside of the procedures are local to the package, and can use STATIC , BASED or CONTROLLED storage. Procedure names used in the package also are local, but can be made external by means of the EXPORTS option of the PACKAGE-statement . Interrupt handling  edit  The RESIGNAL-statement executed in an ON-unit terminates execution of the ON-unit, and raises the condition again in the procedure that called the current one thus passing control to the corresponding ON-unit for that procedure. The INVALIDOP condition handles invalid operation codes detected by the PC processor, as well as illegal arithmetic operations such as subtraction of two infinite values. The ANYCONDITION condition is provided to intercept conditions for which no specific ON-unit has been provided in the current procedure. The STORAGE condition is raised when an ALLOCATE statement is unable to obtain sufficient storage. Other mainframe and minicomputer compilers  edit  A number of vendors produced compilers to compete with IBM PLI F or Optimizing compiler on mainframes and minicomputers in the 1970s. In the 1980s the target was usually the emerging ANSI-G subset. In 1974 Burroughs Corporation announced PLI for the B6700 and B7700. 39  UNIVAC released a UNIVAC PLI, 40  and in the 1970s also used a variant of PLI, PLI PLUS, for system programming. From 1978 Data General provided PLI on its Eclipse and Eclipse MV platforms running the AOS , AOSVS  AOSVS II operating systems. 41  A number of operating system utility programs were written in the language. CDC delivered an optimizing subset PLI compiler for Cyber 70, 170 and 6000 series. 42  Fujitsu delivered a PLI compiler equivalent to the PLI Optimizer. Stratus Technologies PLI is an ANSI G implementation. 43  PLG Subset for IBM Series1 Mini Computer with Real Time extensions PLI Language Reference GC34-0085-0 PLI compilers for Microsoft .NET  edit  In 2011, Raincode designed a full legacy compiler for the Microsoft .NET platform, named Raincode PLI. PLI compilers for personal computers and Unix  edit  in the 1970s Digital Research sold a PLI compiler 44  for the Personal Computer written in PLM . Micro Focus implemented Open PLI for Windows 45  and UNIXLinux systems, 46  which they acquired from Liant. IBM delivered PLI for OS2 37  1994 and PLI for AIX 47  1995. Iron Spring PLI for OS2 and later Linux was introduced in 2007. Special purpose and system PLI compilers  edit  Prime Computer used two different PLI dialects as the system programming language of the PRIMOS operating system  PLP , starting from version 18, and then SPL, starting from version 19. IBM delivered PLI for the Series1 computer family in the 1970s. 48  Paul Abrahams of NYUs Courant Institute of Mathematical Sciences wrote CIMS PLI in 1972 in PLI, bootstrapping via PLI F. It supported about 70 of PLI compiling to the CDC 6600 49  PL8 or PL.8, so-called because it was about 80 of PLI, was developed by IBM Research in the 1970s, and is used for several IBM internal systems development tasks e.g. millicode for zArchitecture  Honeywell, Inc. developed PL-6 for use in creating the CP-6 operating system. PLI dialect compilers  edit  PLS , a dialect of PLI, initially called BSL was developed in the late 1960s and became the IBM system programming language. Almost all IBM mainframe system software in the 1970s and 1980s was written in PLS. It differed from PLI in that there were no data type conversions, no run-time environment, structures were mapped differently, and assignment was a byte by byte copy. All strings and arrays had fixed extents, or used the REFER option. IBM uses an improved and renamed PLS PLX for internal work on current operating systems, OS390 and now zOS . It is also used for some zVSE and zVM components. XPL is a dialect of PLI used to write other compilers using the XPL compiler techniques. XPL added a heap string datatype to its small subset of PLI. HALS is a real-time aerospace programming language, best known for its use in the Space Shuttle program. It was designed by Intermetrics in the 1970s for NASA. HALS was implemented in XPL. IBM and various subcontractors also developed another PLI variant in the early 1970s to support signal processing for the Navy called SPLI. SabreTalk , a real-time dialect of PLI used to program the Sabre airline reservation system. Usage  edit  PLI implementations were developed for mainframes from the late 1960s, mini computers in the 1970s, and personal computers 44  in the 1980s and 1990s. Although its main use has been on mainframes , there are PLI versions for DOS , Microsoft Windows , OS2 , AIX , OpenVMS , and Unix . It has been widely used in business data processing 50  and for system use for writing operating systems on certain platforms. Very complex and powerful systems have been built with PLI The SAS System was initially written in PLI the SAS data step is still modeled on PLI syntax. The pioneering online airline reservation system Sabre was originally written for the IBM 7090 in assembler. The S360 version was largely written using SabreTalk , a purpose built subset PLI compiler for a dedicated control program. PLI was used to write an executable formal definition 51  to interpret IBMs System Network Architecture PLI did not fulfill its supporters hopes that it would displace Fortran and COBOL and become the major player on mainframes. It remained a minority but significant player. There cannot be a definitive explanation for this, but some trends in the 1970s and 1980s militated against its success by progressively reducing the territory on which PLI enjoyed a competitive advantage. First, the nature of the mainframe software environment changed. Application subsystems for database and transaction processing  CICS and IMS and Oracle on System 370 and application generators became the focus of mainframe users application development. Significant parts of the language became irrelevant because of the need to use the corresponding native features of the subsystems such as tasking and much of inputoutput. Fortran was not used in these application areas, confining PLI to COBOLs territory most users sta yed with COBOL. But as the PC became the dominant environment for program development, Fortran, COBOL and PLI all became minority languages overtaken by C , Java and the like. Second, PLI was overtaken in the system programming field. The IBM system programming community was not ready to use PLI instead, IBM developed and adopted a proprietary dialect of PLI for system programming.  PLS . 52  With the success of PLS inside IBM, and of C outside IBM, the unique PLI strengths for system programming became less valuable. Third, the development environments grew capabilities for interactive software development that, again, made the unique PLI interactive and debugging strengths less valuable. Fourth, COBOL and Fortran added features such as structured programming, character string operations, and object orientation, that further reduced PLIs relative advantages. On mainframes there were substantial business issues at stake too. IBMs hardware competitors had little to gain and much to lose from success of PLI. Compiler development was expensive, and the IBM compiler groups had an in-built competitive advantage. Many IBM users wished to avoid being locked into proprietary solutions. With no early support for PLI by other vendors it wa s best to avoid PLI. Evolution of the PLI language  edit  This article uses the PLI standard as the reference point for language features. But a number of features of significance in the early implementations were not in the Standard and some were offered by non-IBM compilers. And the de facto language continued to grow after the standard, ultimately driven by developments on the Personal Computer. Significant features omitted from the standard  edit  Multi tasking  edit  Multi tasking was implemented by PLI F, the Optimizer and the newer AIX and ZOS compilers. It comprised the data types EVENT and TASK , the TASK-option on the CALL-statement  Fork , the WAIT-statement  Join , the DELAYdelay-time , EVENT-option s on the record IO statements and the UNLOCK statement to unlock locked records on EXCLUSIVE files. Event data identify a particular event and indicate whether it is complete 1B or incomplete 0B task data items identify a particular task or process  and indicate its priority relative to other tasks. Preprocessor  edit  Further information PLI preprocessor The first IBM Compile time preprocessor was built by the IBM Boston Advanced Programming Center located in Cambridge, Mass, and shipped with the PLI F compiler. The INCLUDE statement was in the Standard, but the rest of the features were not. The DEC and Kednos 53  PLI compilers implemented much the same set of features as IBM, with some additions of their own. IBM has continued to add preprocessor features to its compilers. The preprocessor treats the written source program as a sequence of tokens, copying them to an output source file or acting on them. When a   token is encountered the following compile time statement is executed when an identifier token is encountered and the identifier has been DECLARE d, ACTIVATE d, and assigned a compile time value, the identifier is replaced by this value. Tokens are added to the output stream if they do not require action e.g.  , as are the values of ACTIVATEd compile time expressions. Thus a compile time variable PI could be declared, activated, and assigned using PI3.14159265 . Subsequent occurrences of PI would be replaced by 3.14159265 . The data type supported are FIXED DECIMAL integers and CHARACTER strings of varying length with no maximum length. The structure statements are label-listDO iteration statements  label-listEND procedure-name PROCEDURE parameter list RETURNS type statements... label-listEND label-listIF...THEN...ELSE.. and the simple statements, which also may have a label-list ACTIVATEidentifier-list and DEACTIVATE assignment statement DECLARE identifier-attribute-list GO TO label INCLUDE null statement The feature allowed programmers to use identifiers for constants    e.g. product part numbers or mathematical constants    and was superseded in the standard by named constants for computational data. Conditional compiling and iterative generation of source code, possible with compile-time facilities, was not supported by the standard. Several manufacturers implemented these facilities. Structured programming additions  edit  Structured programming additions were made to PLI during standardization but were not accepted into the standard. These features were the LEAVE-statement to exit from an iterative DO , the UNTIL-option and REPEAT-option added to DO , and a case statement of the general form SELECT expression WHEN expression group... OTHERWISE group These features were all included in DEC PLI. 54  Debug facilities  edit  PLI F had offered some debug facilities that were not put forward for the standard but were implemented by others    notably the CHECKvariable-list condition prefix, CHECK on-condition and the SNAP option. The IBM Optimizing and Checkout compilers added additional features appropriate to the conversational mainframe programming environment e.g. an ATTENTION condition. Significant features developed since the standard  edit  Several attempts had been made to design a structure member type that could have one of several datatypes  CELL in early IBM. With the growth of classes in programming theory, approaches to this became possible on a PLI base    UNION , TYPE etc. have been added by several compilers. PLI had been conceived in a single-byte character world. With support for Japanese and Chinese language becoming essential, and the developments on International Code Pages, the character string concept was expanded to accommodate wide non-ASCIIEBCDIC strings. Time and date handling were overhauled to deal with the millennium problem , with the introduction of the DATETIME function that returned the date and time in one of about 35 different formats. Several other date functions deal with conversions to and from days and seconds. Criticisms  edit  This section needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources   PLI     news    newspapers    books    scholar    JSTOR  March 2012   Learn how and when to remove this template message  Implementation issues  edit  Though the language is easy to learn and use, implementing a PLI compiler is difficult and time-consuming. A language as large as PLI needed subsets that most vendors could produce and most users master. This was not resolved until ANSI G was published. The compile time facilities, unique to PLI, took added implementation effort and additional compiler passes. A PLI compi ler was two to four times as large as comparable Fortran or COBOL compilers, and also that much slowersupposedly offset by gains in programmer productivity. This was anticipated in IBM before the first compilers were written. 7  Some argue that PLI is unusually hard to parse. 55  The PLI keywords are not reserved so programmers can use them as variable or procedure names in programs. Because the original PLIF compiler attempts auto-correction when it encounters a keyword used in an incorrect context, it often assumes it is a variable name. This leads to cascading diagnostics, a problem solved by later compilers. The effort needed to produce good object code was perhaps underestimated during the initial design of the language. Program optimization needed to compete with the excellent program optimization carried out by available Fortran compilers is unusually complex owing to side effects and pervasive problems with aliasing of variables. Unpredictable modification can occur asynchronously in exception handlers , which may be provided by ON statements in unseen callers. Together, these make it difficult to reliably predict when a programs variables might be modified at runtime. In typical use, however, user-written error handlers the ON-unit  often do not make assignments to variables. In spite of the aforementioned difficulties, IBM produced its PLI optimising compiler in 1971. PLI contains many rarely-used features, such as multitasking support an IBM extension to the language which add cost and complexity to the compiler, and its co-processing facilities require a multi-programming environment with support for non-blocking multiple threads for processes by the operating system . Compiler writers were free to select whether to implement these features. An undeclared variable is, by default, declared by first occurrencethus misspelling might lead to unpredictable results. This implicit declaration is no different from FORTRAN programs. For PLIF, however, an attribute listing enables the programmer to detect any misspelled or undeclared variable. Programmer issues  edit  Many programmers were slow to move from COBOL or Fortran due to a perceived complexity of the language and immaturity of the PLI F compiler. Programmers were sharply divided into scientific programmers who used Fortran and business programmers who used COBOL, with significant tension and even dislike between the groups. PLI syntax borrowed from both COBOL and Fortran syntax. So instead of noticing features that would make thei r job easier, Fortran programmers of the time noticed COBOL syntax and had the opinion that it was a business language, while COBOL programmers noticed Fortran syntax and looked upon it as a scientific language. Both COBOL and Fortran programmers viewed it as a bigger version of their own language, and both were somewhat intimidated by the language and disinclined to adopt it. Another factor was pseudo -similarities to COBOL, Fortran, and ALGOL. These were PLI elements that looked similar to one of those languages, but worked differently in PLI. Such frustrations left many experienced programmers with a jaundiced view of PLI, and often an active dislike for the language. An early UNIX fortune file contained the following tongue-in-cheek description of the language Speaking as someone who has delved into the intricacies of PLI, I am sure that only Real Men could have written such a machine-hogging, cycle-grabbing, all-encompassing monster. Allocate an array and free the middle third Sure Why not Multiply a character string times a bit string and assign the result to a float decimal Go ahead Free a controlled variable procedure parameter and reallocate it before passing it back Overlay three different types of variable on the same memory location Anything you say Write a recursive macro Well, no, but Real Men use rescan. How could a language so obviously designed and written by Real Men not be intended for Real Man use On the positive side, full support for pointers to all data types including pointers to structures, recursion , multitasking , string handling, and extensive built-in functions PLI was indeed quite a leap forward compared to the programming languages of its time. However, these were not enough to persuade a majority of programmers or shops to switch to PLI. The PLI F compilers compile time preprocessor was unusual outside the Lisp world 56   in using its target languages syntax and semantics  e.g. as compared to the C preprocessor s  directives. Special topics in PLI  edit  Storage classes  edit  PLI provides several storage classes to indicate how the lifetime of variables storage is to be managed    STATIC, AUTOMATIC, CONTROLLED and BASED . The simplest to implement is STATIC , which indicates that memory is allocated and initialized at load-time, as is done in COBOL working-storage and early Fortran . This is the default for EXTERNAL variables. PLIs default storage class for INTERNAL variables is AUTOMATIC , similar to that of other block-structured languages influenced by ALGOL , like the auto storage class in the C language, and default storage allocation in Pascal and local-storage in IBM COBOL. Storage for AUTOMATIC variables is allocated upon entry into the BEGIN-block , procedure, or ON-unit in which they are declared. The compiler and runtime system allocate memory for a stack frame to contain them and other housekeeping information. If a variable is declared with an INITIAL-attribute , code to set it to an initial value is executed at this time. Care is required to manage the use of initialization properly. Large amounts of code can be executed to initialize variables every time a scope is entered, especially if the variable is an array or structure. Storage for AUTOMATIC variables is freed at block exit STATIC, CONTROLLED or BASED variables are used to retain variables contents between invocations of a procedure or block. CONTROLLED storage is also managed using a stack, but the pushing and popping of allocations on the stack is managed by the programmer, using ALLOCATE and FREE statements. Storage for BASED variables is managed using ALLOCATEFREE , but instead of a stack these allocations have independent lifetimes and are addressed through OFFSET or POINTER variables. The AREA attribute is used to declare programmer-defined heaps . Data can be allocated and freed within a specific area, and the area can be deleted, read, and written as a unit. 57   pp.235 274 Storage type sharing  edit  There are several ways of accessing allocated storage through different data declarations. Some of these are well defined and safe, some can be used safely with careful programming, and some are inherently unsafe andor machine dependent. 57   pp.262267,178180 Passing a variable as an argument to a parameter by reference allows the arguments allocated storage to be referenced using the parameter. The DEFINED attribute e.g. DCL A10,10, B29,29 DEFINED A  allows part or all of a variables storage to be used with a different, but consistent, declaration. The language definition includes a CELL attribute later renamed UNION  to allow different definitions of data to share the same storage. This was not supported by many early IBM compilers. These usages are safe and machine independent. Record IO and list processing produce situations where the programmer needs to fit a declaration to the storage of the next record or item, before knowing what type of data structure it has. Based variables and pointers are key to such programs. The data structures must be designed appropriately, typically using fields in a data structure to encode information about its type a nd size. The fields can be held in the preceding structure or, with some constraints, in the current one. Where the encoding is in the preceding structure, the program needs to allocate a based variable with a declaration that matches the current item using expressions for extents where needed. Where the type and size information are to be kept in the current structure self defining structures the type-defining fields must be ahead of the type dependent items and in the same place in every version of the data structure. The REFER -option is used for self-defining extents e.g. string lengths as in DCL 1 A BASED, 2 N BINARY, 2 B CHARLENGTH REFER A.N., etc    where LENGTH is used to allocate instances of the data structure. For self-defining structures, any typing and REFERed fields are placed ahead of the real data. If the records in a data set, or the items in a list of data structures, are organised this way they can be handled safely in a machine independent way. PLI implementations do not except for the PLI Checkout compiler keep track of the data structure used when storage is first allocated. Any BASED declaration can be used with a pointer into the storage to access the storage    inherently unsafe and machine dependent. However, this usage has become important for pointer arithmetic typically adding a certain amount to a known address. This has been a contentious subject in computer science. In addition to the problem of wild references and buffer overruns, issues arise due to the alignment and length for data types used with particular machines a nd compilers. Many cases where pointer arithmetic might be needed involve finding a pointer to an element inside a larger data structure. The ADDR function computes such pointers, safely and machine independently. Pointer arithmetic may be accomplished by aliasing a binary variable with a pointer as in DCL P POINTER, N FIXED BINARY31 BASEDADDRP NN255 It relies on pointers being the same length as FIXED BINARY31 integers and aligned on the same boundaries. With the prevalence of C and its free and easy attitude to pointer arithmetic, recent IBM PLI compilers allow pointers to be used with the addition and subtraction operators to giving the simplest syntax but compiler options can disallow these practices where safety and machine independence are paramount. ON-units and exception handling  edit  When PLI was designed, programs only ran in batch mode, with no possible intervention from the programmer at a terminal. An exceptional condition such as division by zero would abort the program yielding only a hexadecimal core dump. PLI exception handling, via ON-units, allowed the program to stay in control in the face of hardware or operating system exceptions and to recov er debugging information before closing down more gracefully. As a program became properly debugged, most of the exception handling could be removed or disabled this level of control became less important when conversational execution became commonplace. Computational exception handling is enabled and disabled by condition prefixes on statements, blocksincluding ON-units and procedures.  e.g. SIZE, NOSUBSCRIPTRANGE AIBIC . Operating system exceptions for InputOutput and storage management are always enabled. The ON-unit is a single statement or BEGIN -block introduced by an ON-statement . Executing the ON statement enables the condition specified, e.g., ON ZERODIVIDE ON-unit . When the exception for this condition occurs and the condition is enabled, the ON-unit for the condition is executed. ON-units are inherited down the call chain. When a block, procedure or ON-unit is activated, the ON-units established by the invoking activation are inherited by the new activation. They may be over-ridden by another ON-statement and can be reestablished by the REVERT-statement . The exception can be simulated using the SIGNAL-statement  e.g. to help debug the exception handlers. The dynamic inheritance principle for ON-units allows a routine to handle the exceptions occurring within the subroutines it uses. If no ON-unit is in effect when a condition is raised a standard system action is taken often this is to raise the ERROR condition. The system action can be reestablished using the SYSTEM option of the ON-statement . With some conditions it is possible to complete executing an ON-unit and return to the point of interrupt e.g., the STRINGRANGE, UNDERFLOW, CONVERSION, OVERFLOW, AREA and FILE conditions and resume normal execution. With other conditions such as SUBSCRIPTRANGE , the ERROR condition is raised when this is attempted. An ON-unit may be terminated with a GO TO preventing a return to the point of interrupt, but permitting the program to continue execution elsewhere as determined by the programmer. An ON-unit needs to be designed to deal with exceptions that occur in the ON-unit itself. The ON ERROR SYSTEM statement allows a nested error trap if an error occurs within an ON-unit, control might pass to the operating system where a system dump might be produced, or, for some computational conditions, continue execution as mentioned above. The PLI RECORD IO statements have relatively simple syntax as they do not offer options for the many situations from end-of-file to record transmission errors that can occur when a record is read or written. Instead, these complexities are handled in the ON-units for the various file conditions. The same approach was adopted for AREA sub-allocation and the AREA condition. The existence of exception handling ON-units can have an effect on optimization, because variables can be inspected or altered in ON-units. Values of variables that might otherwise be kept in registers between statements, may need to be returned to storage between statements. This is discussed in the section on Implementation Issues above. 57   pp.249376 Sample programs  edit  Hello world program  edit  Hello2  proc options  main   put list  Hello, world    end Hello2  Search for a string  edit   Read in a line, which contains a string,  and then print every subsequent line that contains that string.  find_strings  procedure options  main   declare pattern character  100  varying  declare line character  100  varying  declare line_no fixed binary  on endfile  sysin  stop  get edit  pattern   L   line_no  1  do forever  get edit  line   L   if index  line , pattern   0 then put skip list  line_no , line   line_no  line_no  1  end  end find_strings  See also  edit  List of programming languages Timeline of programming languages Notes  edit   IBM Corporation. IBM Enterprise PLI for zOS, V5.2 . IBM . Retrieved October 10, 2017 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Sturm, Eberhard 2009. The New PLI . ViewegTeubner. ISBN   978-3-8348-0726-7 .  a b Pugh, Emerson W. Johnson, Lyle R. Palmer, John H. 1991. IBMs 360 and early 370 systems . Cambridge, Mass. MIT Press . ISBN   9780262161237 .  The committee actually had 8 members at the time the report was released. They were Hans Berg, Lockheed Burbank George Radin , IBM James Cox, Union Carbide Bruce Rosenblatt, Standard Oil of California , Chair. Douglas McIlroy , Bell Laboratories Robert Sheppard, Procter  Gamble . From the GUIDE organization C.W. Medlock, IBM Bernice Weitzenhoffer, IBM.  Report II of the SHARE Advanced Language Development Committee, June 25, 1964  Radin, G.  H. Paul Rogoway January 1965. Highlights of a New Programming Language. Communications of the ACM . 8 1 917. doi  10.1145363707.363708 .  a b Radin, G. August 1978. The Early History and Characteristics of PLI. ACM SIGPLAN Notices . 13 8.  Control of the language was vested in a dedicated Language Control group and a Language Control Board that included representatives of the compiler groups 6 by 1973 in three countries. Daily communication was by telex . Changes and extensions were made through a Language Log that reached several thousand detailed points. A management level Language Review Board resolved issues escalated to it by the Control Board.  The Universal Language Document ULD. Technical reports TR25.081, TR25.082, TR25.083, TR25.0S4, TR25.085, TR25.086 and TR25.087, IBM Corp Vienna Austria June 1968  Frederick P. Brooks Jr. - IEEE Computer Society . IEEE Computer Society . 1989.  Some compilers chose to reserve these identifiers, or issue warnings if they found them used as identifiers. But the subsequent introduction of a case statement shows the value of the principle.  Vowels, Robin 2001. Introduction to PLI . pp.  x. ISBN   978-0-9596384-9-3 . PLI is the first language to provide adequate facilities for scientific computations, business data processing and systems programming in a single language - Jean Sammet , Some Approaches to, and Illustrations of, Programming Language History  a b ANS Programming Language PLI. X3.53-1976  a b ANSI X3.74-1981 R1998 Information Systems - Programming Language - PLI General-Purpose Subset  Reacting to IBMs involvement, a number of manufacturers had been reluctant to endorse an effort on a Standard. The initial remit of CLDGX3J1 was to investigate whether PLI was a suitable candidate for standardization. The joint effort processed over 3500 proposals for language or textual changes.  PLI Language Specifications. GY33-6003  The PLI machine defined in the standard is covered in The Definition Mechanism for Standard PLI . Michael Marcotty, Frederick G Sayward.  1987 PLI General-Purpose Subset ANSI X3.74-1987  a b Krasun, Andy. The first 35 years of Hursley software 1958-1993 . Retrieved September 18, 2012 .  IBM System360 Operating System PLI F Compiler Program Logic Manual PDF . December 1966. SECTION 2 COMPILER PHASES. Y28-6800-1.  These were designed in 1966 for an early Optimizing compiler, written in PLI and to be bootstrapped starting with the PLI F compiler  There were many delays in shipping these, so a common PLI joke at the time was that Gen de Gaulle forbade La Gaude from shipping them until the Concorde had its first flight  IBM System360 PLI Subset Reference Manual. C28-8202-0 , 1967 at Bitsavers  R. A. Frieburghouse. The Multics PL1 Compiler . Multicians.org .  Series 60 Level 666000 PLI Reference Manual . Honeywell . 1976. Order No. DE05.  OS PLI Checkout and Optimizing Compilers Language Reference Manual. GC33-0009 1970  A. M. Krasun. The first 35 years of Hursley software 1958-1993 with some hardware asides a personal account BCS, The Chartered Institute for IT, Advanced Programming Specialist Group. October 2006  R. N. Cuff May 1972. A Conversational Compiler for Full PLI. The Computer Journal . 15 2 99104. doi  10.1093comjnl15.2.99 .  B. L. Marks 1973. The design of a checkout compiler. IBM Systems Journal . 12 3 315327. doi  10.1147sj.123.0315 .  Uniprise PLI for UNIX Reference Manual, Uniprise Systems, Inc., Irvine, California, 1995, p. xxi.  Uniprise PLI for UNIX Reference Manual, Uniprise Systems, Inc., Irvine, California, 1995  Richard C. Holt November 5, 1972. Teaching the Fatal Disease or Introductory Computer Programming Using PLI .  Department of Computer Science, Users Guide to PLC - The Cornell Compiler for PLI, Cornell University, Ithaca, 1977.  PLAGO360 Users Manual, Polytechnic Institute of Brooklyn.  J. N. P. Hume and R. C. Holt, Structured Programming using PLI and SPk, Reston, Reston, 1975.  M. V. Zelkowitz, PLI Programming with PLUM, 2nd Ed., Paladin House, Geneva Ill., 1978.  a b Robin A. Vowels March 1996. PLI for OS2. ACM SIGPLAN Notices . Association for Computing Machinery . 31 3 2227. doi  10.1145227717.227724 .  IBM PLI Compiler Family . Retrieved 13 May 2019 .  Burroughs Corporation, B 6700B 7700 PLI Language Reference Manual, Reference 5001530, Detroit, 1977.  Sperry-Univac Computer Systems, SPERRY UNIVAC 1100 Series PLI Programmer Reference, Reference UP-8277, 1976.  Data General Corporation, AOS PLI Reference Manual, Order No. 093-000204, c. 1978.  Control Data Corporation, PLI Reference Manual, 1978, Publication No. 60388100A.  OpenVOS PLI Language Manual R009 . Marlboro, Massachusetts  Stratus Computer, Inc. 1995. OpenVOS PLI.  a b Peter Norton May 15, 1984. The Norton chronicles . PC Magazine .  Whats New in Studio and Server Enterprise Edition 6.0 Service Pack 2 - Wrap Pack 1 PDF . Micro Focus . p.  1.  Enterprise  Micro Focus Studio Enterprise Edition for UNIX  Welcome  Product Information  Installing Studio Enterprise Edition for UNIX  System Requirements . Micro Focus .  IBM PLI Set for AIX Version 1 . Retrieved 13 May 2019 .  IBM Series1 PLI Language Reference, 2nd Ed., Boca Raton, Florida, 1978.  Paul W. Abrahams. The CIMS PLI compiler . 1979 SIGPLAN symposium on Compiler construction. pp.  107116. doi  10.1145800229.806960 . ISBN   0-89791-002-8 .  Pearkins, Jon E. December 1, 1995. Open PLI Liant addresses PLI legacy applications . Enterprise Systems Journal . Archived from the original on November 3, 2012. Open PLI estimated that in 1995 20 of mainframe legacy applications were in PLI, with 60 in COBOL there were 300,000 PLI programmers worldwide  Schultz, G. D.Rose C.West J.Gray April 1980. Executable description and validation of SNA. IEEE Transactions on Communications . 28 4 661677. doi  10.1109TCOM.1980.1094695 .  In his slides on IBM Operating System360 Fred Brooks says OS360 should have been written in PLI not PLS and Assembler. The article is a great summary of the OS360 program. capgemini-sdm.com , 2001.  Kednos PLI for OpenVMS and Tru64 . Archived from the original on 2002-12-06. Cite uses deprecated parameter deadurl  help   Chapter 8 Program Control . Kednos PLI for OpenVMS Systems Reference Manual . January 2007.  The compiler cannot tell whether a statement is a declaration or a multiple assignment statement until encountering the  of the assignment or  of the DECLAREwhich can be several lines later. The fact that DECLAREDCL were not reserved is the proximate cause in this example    consider the fragment DECLAREI,J,K,L vs DECLAREI,J,K,L .  Timothy P. Hart, MACRO Definitions for LISP , October 1963  a b c IBM Corporation September 2012. Enterprise PLI for zOS PLI for AIX Rational Developer for System z PLI for Windows Language Reference PDF . Retrieved June 2, 2019 . References  edit  Textbooks  edit  Neuhold, E.J.  Lawson, H.W. 1971. The PLI Machine An Introduction to Programming . Addison-wesley. ISBN   978-0-2010-5275-6 . Barnes, R.A. 1979. PLI for Programmers . North-Holland. Hughes, J.K. 1986. PLI Structured Programming 3rd ed.. Wiley. ISBN   978-0-8053-0051-2 . Groner, G.F. 1971. PLI Programming in Technological Applications . Books on Demand, Ann Arbor, MI. Anderson, M.E. 1973. PLI for Programmers . Prentice-Hall. Stoutemyer, D.R. 1971. PLI Programming for Engineering  Science . Prentice-Hall. Ziegler, R.R.  C. 1986. PLI Structured Programming and Problem Solving 1st ed.. West. ISBN   978-0-314-93915-9 . Sturm, E. 2009. The New PLI ... for PC, Workstation and Mainframe . Vieweg-Teubner, Wiesbaden, Germany. ISBN   978-3-8348-0726-7 . Vowels, R.A. 1997. Introduction to PLI, Algorithms, and Structured Programming 3rd ed.. ISBN   978-0-9596384-9-3 . Abrahams, Paul 1979. The PLI Programming Language PDF . Courant Mathematics and Computing Laboratory, New York University. Standards  edit  ANSI ANSI X3.53-1976 R1998 Information Systems - Programming Language - PLI ANSI ANSI X3.74-1981 R1998 Information Systems - Programming Language - PLI General-Purpose Subset ECMA 50 Programming Language PLI , 1st edition, December 1976 ISO 61601979 Programming languagesPLI ISOIEC 65221992 Information technologyProgramming languagesPLI general purpose subset Reference manuals  edit  Burroughs Corporation, B 6700  B 7700 PLI Language Reference, 5001530. Detroit, 1977. CDC. R. A. Vowels, PLI for CDC Cyber. Optimizing compiler for the CDC Cyber 70 series. Digital Equipment Corporation, decsystem10 Conversational Programming Language Users Manual , DEC-10-LCPUA-A-D. Maynard, 1975. Fujitsu Ltd, Facom OS IV PLI Reference Manual, 70SP5402E-1,1974. 579 pages. PLI F subset. Honeywell, Inc., Multics PLI Language Specification , AG94-02. 1981. IBM, Operating System360 PLI Language Specifications , C28-6571. 1965. IBM, OS PLI Checkout and Optimizing Compilers Language Reference Manual , GC33-0009. 1970. IBM, NPL Technical Report , December 1964. IBM, Enterprise PLI for zOS Version 4 Release 1 Language Reference Manual , SC14-7285-00. 2010. IBM, OS2 PLI Version 2 Programming Language Reference, 3rd Ed., Form SC26-4308, San Jose. 1994. Kednos PLI for OpenVMS Systems. Reference Manual , AA-H952E-TM. Nov 2003. Liant Software Corporation 1994, Open PLI Language Reference Manual, Rev. Ed., Framingham Mass.. Nixdorf Computer, Terminalsystem 8820 Systemtechnischer Teil PLI-Subset,05001.17.8.93-01, 1976. Ing. C. Olivetti, Mini PLI Reference Manual, 1975, No. 3970530 V Q1 Corporation, The Q1LMC Systems Software Manual, Farmingdale, 1978. External links  edit  Wikibooks has more on the topic of PLI IBM PLI Compilers for zOS , AIX , MVS , VM and VSE Iron Spring Software , PLI for Linux and OS2 Kednos PLI for OpenVMS and Tru64 Micro Focus Mainframe PLI Migration Solution OS PLI V2R3 grammar Version 0.1 Pliedit , PLI editor for Eclipse Power vs. Adventure - PLI and C , a side-by-side comparison of PLI and C . The Compilerator , Online PLI compiler for small experiments and tinkering. Softpanorama PL1 page The PLI Language PL1GCC project in SourceForge Retrieved from  httpsen.wikipedia.orgwindex.phptitlePLI oldid914426331  Categories  Procedural programming languages PLI programming language family Structured programming languages Concurrent programming languages Systems programming languages IBM software Programming languages created in 1964 Programming languages with an ISO standard Hidden categories CS1 errors deprecated parameters All articles with unsourced statements Articles with unsourced statements from June 2019 Wikipedia articles needing clarification from April 2014 Articles needing additional references from March 2012 All articles needing additional references