Thunk From Wikipedia, the free encyclopedia Jump to navigation Jump to search For other uses, see Thunk disambiguation . In computer programming , a thunk is a subroutine used to inject an additional calculation into another subroutine. Thunks are primarily used to delay a calculation until its result is needed, or to insert operations at the beginning or end of the other subroutine. They have a variety of other applications in compiler code generation and modular programming . The term originated as a jocular derivative of think. 1  Contents 1 Background 2 Applications 2.1 Functional programming 2.2 Object-oriented programming 2.3 Interoperability 2.4 Overlays and dynamic linking 3 See also 3.1 Thunk technologies 3.2 Related concepts 4 Notes 5 References Background  edit  The early years of compiler research saw broad experimentation with different evaluation strategies . A key question was how to compile a subroutine call if the arguments can be arbitrary mathematical expressions rather than constants. One approach, known as  call by value , calculates all of the arguments before the call and then passes the resulting values to the subroutine. In the rival  call by name  approach, the subroutine receives the unevaluated argument expression and must evaluate it. A simple implementation of call by name might substitute the code of an argument expression for each appearance of the corresponding parameter in the subroutine, but this can produce multiple versions of the subroutine and multiple copies of the expression code. As an improvement, the compiler can generate a helper subroutine, called a thunk , that calculates the value of the argument. The address and environment a  of this helper subroutine are then passed to the original subroutine in place of the original argument, where it can be called as many times as needed. Peter Ingerman first described thunks in reference to the ALGOL 60 programming language, which supported call-by-name evaluation. 2  Applications  edit  Functional programming  edit  Although the software industry largely standardized on call-by-value and call-by-reference evaluation, 3  active study of call-by-name continued in the functional programming community. This research produced a series of lazy evaluation programming languages in which some variant of call-by-name is the standard evaluation strategy. Compilers for these languages, such as the Glasgow Haskell Compiler , have relied heavily on thunks, with the added feature that the thunks save their initial result so that they can avoid recalculating it 4  this is known as memoization . Functional programming languages have also allowed programmers to explicitly generate thunks. This is done in source code by wrapping an argument expression in an anonymous function that has no parameters of its own. This prevents the expression from being evaluated until a receiving function calls the anonymous function, thereby achieving the same effect as call-by-name. 5  The adoption of anonymous functions into other programming languages has made this capability widely available. The following is a simple demonstration in JavaScript ES6  hypot  is a binary function const hypot   x , y    Math . sqrt  x  x  y  y   thunk  is a function that takes no arguments and, when invoked, performs a potentially expensive  operation computing a square root, in this example andor causes some side-effect to occur const thunk     hypot  3 , 4   the thunk can then be passed around... doSomethingWithThunk  thunk   ...or evaluated thunk    5 Object-oriented programming  edit  Thunks are useful in object-oriented programming platforms that allow a class to inherit multiple interfaces , leading to situations where the same method might be called via any of several interfaces. The following code illustrates such a situation in C . class A  public  virtual int Access  const  return value_   private  int value_   class B  public  virtual int Access  const  return value_   private  int value_   class C  public A , public B  public  int Access  const override  return better_value_   private  int better_value_   int Use  B  b   return b -  Access   int main    ... B some_b  Use   some_b  C some_c  Use   some_c   In this example, the code generated for each of the classes A, B and C will include a dispatch table that can be used to call Access on an object of that type, via a reference that has the same type. Class C will have an additional dispatch table, used to call Access on an object of type C via a reference of type B. The expression b- Access will use Bs own dispatch table or the additional C table, depending on the type of object b refers to. If it refers to an object of type C, the compiler must ensure that Cs Access implementation receives an instance address for the entire C object, rather than the inherited B part of that object. 6  As a direct approach to this pointer adjustment problem, the compiler can include an integer offset in each dispatch table entry. This offset is the difference between the references address and the address required by the method implementation. The code generated for each call through these dispatch tables must then retrieve the offset and use it to adjust the instance addres s before calling the method. The solution just described has problems similar to the nave implementation of call-by-name described earlier the compiler generates several copies of code to calculate an argument the instance address, while also increasing the dispatch table sizes to hold the offsets. As an alternative, the compiler can generate an adjustor thunk along with Cs implementation of Access that adjusts the instance address by the required amount and then calls the method. The thunk can appear in Cs dispatch table for B, thereby eliminating the need for callers to adjust the address themselves. 7  Interoperability  edit  Thunks have been widely used to provide interoperability between software modules whose routines cannot call each other directly. This may occur because the routines have different calling conventions , run in different CPU modes or address spaces , or at least one runs in a virtual machine . A compiler or other tool can solve this problem by generating a thunk that automates the additional steps needed to call the target routine, whether that is transforming arguments, copying them to another location, or switching the CPU mode. A successful thunk minimizes the extra work the caller must do compared to a normal call. Much of the literature on interoperability thunks relates to various Wintel platforms, including MS-DOS , OS2 , 8  Windows 9  10  11  12  and .NET , and to the transition from 16-bit to 32-bit memory addressing. As customers have migrated from one platform to another, thunks have been essential to support legacy software written for the older platforms. Overlays and dynamic linking  edit  On systems that lack automatic virtual memory hardware, thunks can implement a limited form of virtual memory known as overlays . With overlays, a developer divides a programs code into segments that can be loaded and unloaded independently, and identifies the entry points into each segment. A segment that calls into another segment must do so indirectly via a branch table . When a segment is in memory, its branch table entries jump into the segment. When a segment is unloaded, its entries are replaced with reload thunks that can reload it on demand. 13  Similarly, systems that dynamically link modules of a program together at run-time can use thunks to connect the modules. Each module can call the others through a table of thunks that the linker fills in when it loads the module. This way the modules can interact without prior knowledge of where they are located in memory. 14  See also  edit  Thunk technologies  edit  DOS Protected Mode Interface DPMI DOS Protected Mode Services DPMS JDirect Microsoft Layer for Unicode Platform Invocation Services Win32s Windows on Windows WoW64 libffi Related concepts  edit  Anonymous function Futures and promises Remote procedure call Shim computing Trampoline computing Reducible expression Notes  edit   The environment passed is that of the call with the by-name parameter, not that of the called routine. References  edit   Eric Raymond rejects a couple of onomatopoeic myths circulating about the origin of this term and cites the inventors of the thunk recalling that the term was coined after they realized in the wee hours after hours of discussion that the type of an argument in Algol-60 could be figured out in advance with a little compile-time thought ... In other words, it had already been thought of thus it was christened a thunk , which is the past tense of think at two in the morning. See Raymond, Eric S. 1996. Raymond, Eric S. ed.. The New Hackers Dictionary . MIT Press. p.  445. ISBN   9780262680929 . Retrieved 2015-05-25 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Ingerman, P. Z. 1961-01-01. Thunks a way of compiling procedure statements with some comments on procedure declarations. Communications of the ACM . Association for Computing Machinery ACM. 4 1 5558. doi  10.1145366062.366084 . ISSN   0001-0782 .  Scott, Michael 2009. Programming Language Pragmatics . p.  395.  Marlow, Simon 2013. Parallel and Concurrent Programming in Haskell . p.  10.  Queinnec, Christian 2003. Lisp in Small Pieces . p.  176.  Stroustrup, Bjarne Fall 1989. Multiple Inheritance for C PDF . Computing Systems . USENIX . 1 4 . Retrieved 4 August 2014 .  Driesen, Karel Hlzle, Urs 1996. The Direct Cost of Virtual Function Calls in C PDF . OOPSLA . Retrieved 24 February 2011 . Cite journal requires journal  help   Calcote, John May 1995. Thunking Using 16-Bit Libraries in OS2 2.0 . OS2 Developer Magazine . 7 3.  King, Adrian 1994. Inside Microsoft Windows 95 2nd ed.. Redmond, Washington, USA Microsoft Press . ISBN   1-55615-626-X .  Programmers Guide to Microsoft Windows 95 Key Topics on Programming for Windows from the Microsoft Windows Development Team . Technical Reference 1st ed.. Redmond, Washington, USA Microsoft Press . 1995-07-01. ISBN   1-55615-834-3 . Retrieved 2016-05-26 .  Hazzah, Karen 1997. Writing Windows VxDs and Device Drivers - Programming Secrets for Virtual Device Drivers 2nd printing, 2nd ed.. Lawrence, Kansas, USA R D Books  Miller Freeman, Inc. ISBN   0-87930-438-3 .  Kauler, Barry August 1997. Windows Assembly Language and Systems Programming - 16- and 32-Bit Low-Level Programming for the PC and Windows 2nd ed.. Lawrence, Kansas, USA R D Books  Miller Freeman, Inc. ISBN   0-87930-474-X .  Bright, Walter 1990-07-01. Virtual Memory For 640K DOS . Dr. Dobbs Journal . Retrieved 2014-03-06 .  Levine, J.R. 2000. Linkers and loaders . Operating Systems. San Francisco Morgan Kaufmann. ISBN   1-55860-496-0 . OCLC   42413382 . Retrieved from  httpsen.wikipedia.orgwindex.phptitleThunk oldid914211286  Categories  Computing terminology Functional programming Hidden categories CS1 errors missing periodical