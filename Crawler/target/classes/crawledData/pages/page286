Reinforcement learning From Wikipedia, the free encyclopedia Jump to navigation Jump to search For reinforcement learning in psychology, see Reinforcement and Operant conditioning . Machine learning and data mining Problems Classification Clustering Regression Anomaly detection AutoML Association rules Reinforcement learning Structured prediction Feature engineering Feature learning Online learning Semi-supervised learning Unsupervised learning Learning to rank Grammar induction Supervised learning .mw-parser-output .noboldfont-weightnormal  classification    regression  Decision trees Ensembles Bagging Boosting Random forest k -NN Linear regression Naive Bayes Artificial neural networks Logistic regression Perceptron Relevance vector machine RVM Support vector machine SVM Clustering BIRCH CURE Hierarchical k -means Expectationmaximization EM DBSCAN OPTICS Mean-shift Dimensionality reduction Factor analysis CCA ICA LDA NMF PCA t-SNE Structured prediction Graphical models Bayes net Conditional random field Hidden Markov Anomaly detection k -NN Local outlier factor Artificial neural networks Autoencoder Deep learning DeepDream Multilayer perceptron RNN LSTM GRU Restricted Boltzmann machine GAN SOM Convolutional neural network U-Net Reinforcement learning Q-learning SARSA Temporal difference TD Theory Biasvariance dilemma Computational learning theory Empirical risk minimization Occam learning PAC learning Statistical learning VC theory Machine-learning venues NIPS ICML ML JMLR ArXivcs.LG Glossary of artificial intelligence Glossary of artificial intelligence Related articles List of datasets for machine-learning research Outline of machine learning v t e Reinforcement learning  RL  is an area of machine learning concerned with how software agents ought to take actions in an environment so as to maximize some notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongside supervised learning and unsupervised learning . It differs from supervised learning in that labelled inputoutput pairs need not be presented, and sub-optimal actions need not be explicitly corrected. Instead the focus is finding a balance between exploration of uncharted territory and exploitation of current knowledge. 1  The environment is typically formulated as a Markov decision process MDP, as many reinforcement learning algorithms for this context utilize dynamic programming techniques. 2  The main difference between the classical dynamic programming methods and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the MDP and they target large MDPs where exact methods become infeasible. .mw-parser-output .toclimit-2 .toclevel-1 ul,.mw-parser-output .toclimit-3 .toclevel-2 ul,.mw-parser-output .toclimit-4 .toclevel-3 ul,.mw-parser-output .toclimit-5 .toclevel-4 ul,.mw-parser-output .toclimit-6 .toclevel-5 ul,.mw-parser-output .toclimit-7 .toclevel-6 uldisplaynone Contents 1 Introduction 2 Exploration 3 Algorithms for control learning 3.1 Criterion of optimality 3.1.1 Policy 3.1.2 State-value function 3.2 Brute force 3.3 Value function 3.3.1 Monte Carlo methods 3.3.2 Temporal difference methods 3.4 Direct policy search 4 Theory 5 Research 6 Comparison of reinforcement learning algorithms 6.1 Deep reinforcement learning 6.2 Inverse reinforcement learning 6.3 Apprenticeship learning 7 See also 8 References 9 Further reading 10 External links Introduction  edit  The typical framing of a Reinforcement Learning RL scenario an agent takes actions in an environment, which is interpreted into a reward and a representation of the state, which are fed back into the agent. Reinforcement learning, due to its generality, is studied in many other disciplines, such as game theory , control theory , operations research , information theory , simulation-based optimization , multi-agent systems , swarm intelligence , statistics and genetic algorithms . In the operations research and control literature, reinforcement learning is called approximate dynamic programming, or neuro-dynamic programming. The problems of interest in reinforcement learning have also been studied in the theory of optimal control , which is concerned mostly with the existence and characterization of optimal solutions, and algorithms for their exact computation, and less with learning or approximation, particularly in the absence of a mathematical model of the environment. In economics and game theory , reinforcement learning may be used to explain how equilibrium may arise under bounded rationality . Basic reinforcement is modeled as a Markov decision process  a set of environment and agent states, S  a set of actions, A , of the agent P a  s , s    Pr  s t  1  s   s t  s , a t  a  displaystyle P_as,sPrs_t1smid s_ts,a_ta is the probability of transition from state s displaystyle s to state s  displaystyle s under action a displaystyle a . R a  s , s   displaystyle R_as,s is the immediate reward after transition from s displaystyle s to s  displaystyle s with action a displaystyle a . rules that describe what the agent observes Rules are often stochastic . The observation typically involves the scalar, immediate reward associated with the last transition. In many works, the agent is assumed to observe the current environmental state  full observability . If not, the agent has partial observability . Sometimes the set of actions available to the agent is restricted a zero balance cannot be reduced. For example, if the current value of the agent is 3 and the state transition reduces the value by 4, the transition will not be allowed. A reinforcement learning agent interacts with its environment in discrete time steps. At each time t , the agent receives an observation o t displaystyle o_t , which typically includes the reward r t displaystyle r_t . It then chooses an action a t displaystyle a_t from the set of available actions, which is subsequently sent to the environment. The environment moves to a new state s t  1 displaystyle s_t1 and the reward r t  1 displaystyle r_t1 associated with the transition  s t , a t , s t  1  displaystyle s_t,a_t,s_t1 is determined. The goal of a reinforcement learning agent is to collect as much reward as possible. The agent can possibly randomly choose any action as a function of the history. When the agents performance is compared to that of an agent that acts optimally, the difference in performance gives rise to the notion of regret . In order to act near optimally, the agent must reason about the long term consequences of its actions i.e., maximize future income, although the immediate reward associated with this might be negative. Thus, reinforcement learning is particularly well-suited to problems that include a long-term versus short-term reward trade-off. It has been applied successfully to various problems, including robot control , elevator scheduling, telecommunications , backgammon , checkers 3  and go  AlphaGo . Two elements make reinforcement learning powerful the use of samples to optimize performance and the use of function approximation to deal with large environments. Thanks to these two key components, reinforcement learning can be used in large environments in the following situations A model of the environment is known, but an analytic solution is not available Only a simulation model of the environment is given the subject of simulation-based optimization  4  The only way to collect information about the environment is to interact with it. The first two of these problems could be considered planning problems since some form of model is available, while the last one could be considered to be a genuine learning problem. However, reinforcement learning converts both planning problems to machine learning problems. Exploration  edit  The exploration vs. exploitation trade-off has been most thoroughly studied through the multi-armed bandit problem and for finite state space MDPs in Burnetas and Katehakis 1997. 5  Reinforcement learning requires clever exploration mechanisms. Randomly selecting actions, without reference to an estimated probability distribution, shows poor performance. The case of small finite Markov decision processes is relatively well understood. However, due to the lack of algorithms that scale well with the number of states or scale to problems with infinite state spaces, simple exploration methods are the most practical. One such method is  displaystyle epsilon  -greedy, where 0    1 displaystyle 0 epsilon 1 is a parameter controlling the amount of exploration vs. exploitation. With probability 1   displaystyle 1-epsilon  , exploitation is chosen, and the agent chooses the action that it believes has the best long-term effect ties between actions are broken uniformly at random. Alternatively, with probability  displaystyle epsilon  , exploration is chosen, and the action is chosen uniformly at random.  displaystyle epsilon  is usually a fixed parameter but can be adjusted either according to a schedule making the agent explore progressively less, or adaptively based on heuristics. 6  Algorithms for control learning  edit  Even if the issue of exploration is disregarded and even if the state was observable assumed hereafter, the problem remains to use past experience to find out which actions are good. Criterion of optimality  edit  Policy  edit  The agents action selection is modeled as a map called policy    A  S   0 , 1  displaystyle pi Atimes Srightarrow 0,1   a , s   Pr  a t  a  s t  s  displaystyle pi a,sPra_tamid s_ts The policy map gives the probability of taking action a displaystyle a when in state s displaystyle s . 7   61 There are also non-probabilistic policies. State-value function  edit  Value function V   s  displaystyle V_pi s is defined as the expected return starting with state s displaystyle s , i.e. s 0  s displaystyle s_0s , and successively following policy  displaystyle pi  . Hence, roughly speaking, the value function estimates how good it is to be in a given state. 7   60 V   s   E   R   E    t  0   t r t  s 0  s  , displaystyle V_pi soperatorname E Roperatorname E leftsum _t0infty gamma tr_tmid s_0sright, where the random variable R displaystyle R denotes the return , and is defined as the sum of future discounted rewards  clarification needed  R   t  0   t r t , displaystyle Rsum _t0infty gamma tr_t, where r t displaystyle r_t is the reward at step t displaystyle t ,    0 , 1  displaystyle gamma in 0,1 is the discount-rate  clarification needed  . The algorithm must find a policy with maximum expected return. From the theory of MDPs it is known that, without loss of generality, the search can be restricted to the set of so-called stationary policies. A policy is stationary if the action-distribution returned by it depends only on the last state visited from the observation agents history. The search can be further restricted to deterministic stationary policies. A deterministic stationary policy deterministically selects actions based on the current state. Since any such policy can be identified with a mapping from the set of states to the set of actions, these policies can be identified with such mappings with no loss of generality. Brute force  edit  The brute force approach entails two steps For each possible policy, sample returns while following it Choose the policy with the largest expected return One problem with this is that the number of policies can be large, or even infinite. Another is that variance of the returns may be large, which requires many samples to accurately estimate the return of each policy. These problems can be ameliorated if we assume some structure and allow samples generated from one policy to influence the estimates made for others. The two main approaches for achieving this are value function estimation and direct policy search . Value function  edit  See also Value function Value function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy usually either the current on-policy or the optimal off-policy one. These methods rely on the theory of MDPs, where optimality is defined in a sense that is stronger than the above one A policy is called optimal if it achieves the best expected return from any initial state i.e., initial distributions play no role in this definition. Again, an optimal policy can always be found amongst stationary policies. To define optimality in a formal manner, define the value of a policy  displaystyle pi  by V   s   E  R  s ,   , displaystyle Vpi sERmid s,pi , where R displaystyle R stands for the return associated with following  displaystyle pi  from the initial state s displaystyle s . Defining V   s  displaystyle Vs as the maximum possible value of V   s  displaystyle Vpi s , where  displaystyle pi  is allowed to change, V   s   max  V   s  . displaystyle Vsmax _pi Vpi s. A policy that achieves these optimal values in each state is called optimal . Clearly, a policy that is optimal in this strong sense is also optimal in the sense that it maximizes the expected return   displaystyle rho pi  , since    E  V   S   displaystyle rho pi EVpi S , where S displaystyle S is a state randomly sampled from the distribution  displaystyle mu   clarification needed  . Although state-values suffice to define optimality, it is useful to define action-values. Given a state s displaystyle s , an action a displaystyle a and a policy  displaystyle pi  , the action-value of the pair  s , a  displaystyle s,a under  displaystyle pi  is defined by Q   s , a   E   R  s , a ,   , displaystyle Qpi s,aoperatorname E Rmid s,a,pi ,, where R displaystyle R now stands for the random return associated with first taking action a displaystyle a in state s displaystyle s and following  displaystyle pi  , thereafter. The theory of MDPs states that if   displaystyle pi  is an optimal policy, we act optimally take the optimal action by choosing the action from Q    s ,   displaystyle Qpi s,cdot  with the highest value at each state, s displaystyle s . The action-value function of such an optimal policy  Q   displaystyle Qpi   is called the optimal action-value function and is commonly denoted by Q  displaystyle Q . In summary, the knowledge of the optimal action-value function alone suffices to know how to act optimally. Assuming full knowledge of the MDP, the two basic approaches to compute the optimal action-value function are value iteration and policy iteration . Both algorithms compute a sequence of functions Q k displaystyle Q_k  k  0 , 1 , 2 ,  displaystyle k0,1,2,ldots   that converge to Q  displaystyle Q . Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest finite MDPs. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces. Monte Carlo methods  edit  Monte Carlo methods can be used in an algorithm that mimics policy iteration. Policy iteration consists of two steps policy evaluation and policy improvement . Monte Carlo is used in the policy evaluation step. In this step, given a stationary, deterministic policy  displaystyle pi  , the goal is to compute the function values Q   s , a  displaystyle Qpi s,a or a good approximation to them for all state-action pairs  s , a  displaystyle s,a . Assuming for simplicity that the MDP is finite, that sufficient memory is available to accommodate the action-values and that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair  s , a  displaystyle s,a can be computed by averaging the sampled returns that originated from  s , a  displaystyle s,a over time. Given sufficient time, this procedure can thus construct a precise estimate Q displaystyle Q of the action-value function Q  displaystyle Qpi  . This finishes the description of the policy evaluation step. In the policy improvement step, the next policy is obtained by computing a greedy policy with respect to Q displaystyle Q  Given a state s displaystyle s , this new policy returns an action that maximizes Q  s ,   displaystyle Qs,cdot  . In practice lazy evaluation can defer the computation of the maximizing actions to when they are needed. Problems with this procedure include The procedure may spend too much time evaluating a suboptimal policy. It uses samples inefficiently in that a long trajectory improves the estimate only of the single state-action pair that started the trajectory. When the returns along the trajectories have high variance , convergence is slow. It works in episodic problems only It works in small, finite MDPs only. Temporal difference methods  edit  Main article Temporal difference learning The first problem is corrected by allowing the procedure to change the policy at some or all states before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class of generalized policy iteration algorithms. Many actor critic methods belong to this category. The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Suttons temporal difference TD methods that are based on the recursive Bellman equation . 8  9  The computation in TD methods can be incremental when after each transition the memory is changed and the transition is thrown away, or batch when the transitions are batched and the estimates are computed once based on the batch. Batch methods, such as the least-squares temporal difference method, 10  may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue. In order to address the fifth issue, function approximation methods are used. Linear function approximation starts with a mapping  displaystyle phi  that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair  s , a  displaystyle s,a are obtained by linearly combining the components of   s , a  displaystyle phi s,a with some weights  displaystyle theta   Q  s , a    i  1 d  i  i  s , a  . displaystyle Qs,asum _i1dtheta _iphi _is,a. The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. Methods based on ideas from nonparametric statistics which can be seen to construct their own features have been explored. Value iteration can also be used as a starting point, giving rise to the Q-learning algorithm and its many variants. 11  The problem with using action-values is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy. Though this problem is mitigated to some extent by temporal difference methods. Using the so-called compatible function approximation method compromises generality and efficiency. Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-called  displaystyle lambda  parameter  0    1  displaystyle 0leq lambda leq 1 that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue. Direct policy search  edit  An alternative method is to search directly in some subset of the policy space, in which case the problem becomes a case of stochastic optimization . The two approaches available are gradient-based and gradient-free methods. Gradient -based methods  policy gradient methods  start with a mapping from a finite-dimensional parameter space to the space of policies given the parameter vector  displaystyle theta  , let   displaystyle pi _theta  denote the policy associated to  displaystyle theta  . Defining the performance function by         , displaystyle rho theta rho pi _theta , under mild conditions this function will be differentiable as a function of the parameter vector  displaystyle theta  . If the gradient of  displaystyle rho  was known, one could use gradient ascent . Since an analytic expression for the gradient is not available, only a noisy estimate is available. Such an estimate can be constructed in many ways, giving rise to algorithms such as Williams REINFORCE method 12  which is known as the likelihood ratio method in the simulation-based optimization literature. 13  Policy search methods have been used in the robotics context. 14  Many policy search methods may get stuck in local optima as they are based on local search . A large class of methods avoids relying on gradient information. These include simulated annealing , cross-entropy search or methods of evolutionary computation . Many gradient-free methods can achieve in theory and in the limit a global optimum. Policy search methods may converge slowly given noisy data. For example, this happens in episodic problems when the trajectories are long and the variance of the returns is large. Value-function based methods that rely on temporal differences might help in this case. In recent years, actorcritic methods have been proposed and performed well on various problems. 15  Theory  edit  Both the asymptotic and finite-sample behavior of most algorithms is well understood. Algorithms with provably good online performance addressing the exploration issue are known. Efficient exploration of large MDPs is largely unexplored except for the case of bandit problems.  clarification needed  Although finite-time performance bounds appeared for many algorithms, these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations. For incremental algorithms, asymptotic convergence issues have been settled. Temporal-difference-based algorithms converge under a wider set of conditions than was previously possible for example, when used with arbitrary, smooth function approximation. Research  edit  Research topics include adaptive methods that work with fewer or no parameters under a large number of conditions addressing the exploration problem in large MDPs large-scale empirical evaluations learning and acting under partial information e.g., using predictive state representation  modular and hierarchical reinforcement learning improving existing value-function and policy search methods algorithms that work well with large or continuous action spaces transfer learning lifelong learning efficient sample-based planning e.g., based on Monte Carlo tree search . bug detection in software projects 16  Multiagent or distributed reinforcement learning is a topic of interest. Applications are expanding. 17  Actor-critic reinforcement learning Reinforcement learning algorithms such as TD learning are under investigation as a model for dopamine -based learning in the brain. In this model, the dopaminergic projections from the substantia nigra to the basal ganglia function as the prediction error. Reinforcement learning has been used as a part of the model for human skill learning, especially in relation to the interaction between implicit and explicit learning in skill acquisition the first publication on this application was in 19951996. 18  Comparison of reinforcement learning algorithms  edit  Algorithm Description Model Policy Action Space State Space Operator Monte Carlo Every visit to Monte Carlo Model-Free Off-policy Discrete Discrete Sample-means Q-learning Stateactionrewardstate Model-Free Off-policy Discrete Discrete Q-value SARSA Stateactionrewardstateaction Model-Free On-policy Discrete Discrete Q-value Q-learning - Lambda Stateactionrewardstate with eligibility traces Model-Free Off-policy Discrete Discrete Q-value SARSA - Lambda Stateactionrewardstateaction with eligibility traces Model-Free On-policy Discrete Discrete Q-value DQN Deep Q Network Model-Free Off-policy Discrete Continuous Q-value DDPG Deep Deterministic Policy Gradient Model-Free Off-policy Continuous Continuous Q-value A3C Asynchronous Advantage Actor-Critic Algorithm Model-Free On-policy Continuous Continuous Advantage NAF Q-Learning with Normalized Advantage Functions Model-Free Off-policy Continuous Continuous Advantage TRPO Trust Region Policy Optimization Model-Free On-policy Continuous Continuous Advantage PPO Proximal Policy Optimization Model-Free On-policy Continuous Continuous Advantage TD3 Twin Delayed Deep Deterministic Policy Gradient Model-Free Off-policy Continuous Continuous Q-value SAC Soft Actor-Critic Model-Free Off-policy Continuous Continuous Advantage Deep reinforcement learning  edit  This approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space. 19  The work on learning ATARI games by Google DeepMind increased attention to deep reinforcement learning or end-to-end reinforcement learning . 20  Inverse reinforcement learning  edit  In inverse reinforcement learning IRL, no reward function is given. Instead, the reward function is inferred given an observed behavior from an expert. The idea is to mimic observed behavior, which is often optimal or close to optimal. 21  Apprenticeship learning  edit  In apprenticeship learning , an expert demonstrates the target behavior. The system tries to recover the policy via observation. See also  edit  Temporal difference learning Q-learning Stateactionrewardstateaction SARSA Fictitious play Learning classifier system Optimal control Dynamic treatment regimes Error-driven learning Multi-agent system Distributed artificial intelligence References  edit   Kaelbling, Leslie P.  Littman, Michael L.  Moore, Andrew W. 1996. Reinforcement Learning A Survey . Journal of Artificial Intelligence Research . 4  237285. arXiv  cs9605103 . doi  10.1613jair.301 . Archived from the original on 2001-11-20. Cite uses deprecated parameter deadurl  help  .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  van Otterlo, M. Wiering, M. 2012. Reinforcement learning and markov decision processes . Reinforcement Learning . Adaptation, Learning, and Optimization. 12 . pp.  342. doi  10.1007978-3-642-27645-3_1 . ISBN   978-3-642-27644-6 .  Sutton  Barto , Chapter 11.  Gosavi, Abhijit 2003. Simulation-based Optimization Parametric Optimization Techniques and Reinforcement . Operations ResearchComputer Science Interfaces Series. Springer. ISBN   978-1-4020-7454-7 .  Burnetas, Apostolos N. Katehakis, Michael N. 1997, Optimal adaptive policies for Markov Decision Processes , Mathematics of Operations Research , 22  222--255  Tokic, Michel Palm, Gnther 2011, Value-Difference Based Exploration Adaptive Control Between Epsilon-Greedy and Softmax PDF , KI 2011 Advances in Artificial Intelligence , Lecture Notes in Computer Science, 7006 , Springer, pp.  335346, ISBN   978-3-642-24455-1  a b Reinforcement learning An introduction PDF .  Sutton, Richard S. 1984. Temporal Credit Assignment in Reinforcement Learning PhD thesis. University of Massachusetts, Amherst, MA.  Sutton  Barto 1998 , 6. Temporal-Difference Learning .  Bradtke, Steven J.  Barto, Andrew G. 1996. Learning to predict by the method of temporal differences. Machine Learning . 22  3357. CiteSeerX   10.1.1.143.857 . doi  10.1023A1018056104778 .  Watkins, Christopher J.C.H. 1989. Learning from Delayed Rewards PDF PhD thesis. Kings College, Cambridge, UK.  Williams, Ronald J. 1987. A class of gradient-estimating algorithms for reinforcement learning in neural networks. Proceedings of the IEEE First International Conference on Neural Networks . CiteSeerX   10.1.1.129.8871 .  Peters, Jan  Vijayakumar, Sethu  Schaal, Stefan 2003. Reinforcement Learning for Humanoid Robotics PDF . IEEE-RAS International Conference on Humanoid Robots .  Deisenroth, Marc Peter  Neumann, Gerhard  Peters, Jan 2013. A Survey on Policy Search for Robotics . Foundations and Trends in Robotics. 2 . NOW Publishers. pp.  1142. hdl  10044112051 .  Juliani, Arthur 2016-12-17. Simple Reinforcement Learning with Tensorflow Part 8 Asynchronous Actor-Critic Agents A3C . Medium . Retrieved 2018-02-22 .  On the Use of Reinforcement Learning for Testing Game Mechanics   ACM - Computers in Entertainment . cie.acm.org . Retrieved 2018-11-27 .  Reinforcement Learning  Successes of Reinforcement Learning . umichrl.pbworks.com . Retrieved 2017-08-06 .  1 Archived 2017-04-26 at the Wayback Machine  Francois-Lavet, Vincent et al. 2018. An Introduction to Deep Reinforcement Learning . Foundations and Trends in Machine Learning . 11 34 219354. arXiv  1811.12560 . doi  10.15612200000071 .  Mnih, Volodymyr et al. 2015. Human-level control through deep reinforcement learning. Nature . 518 7540 529533. Bibcode  2015Natur.518..529M . doi  10.1038nature14236 . PMID   25719670 .  Ng, A. Y. Russell, S. J. 2000. Algorithms for Inverse Reinforcement Learning PDF . Proceeding ICML 00 Proceedings of the Seventeenth International Conference on Machine Learning . pp.  663670. ISBN   1-55860-707-2 . Further reading  edit  Auer, Peter  Jaksch, Thomas  Ortner, Ronald 2010. Near-optimal regret bounds for reinforcement learning . Journal of Machine Learning Research . 11  15631600. Busoniu, Lucian  Babuska, Robert  De Schutter, Bart  Ernst, Damien 2010. Reinforcement Learning and Dynamic Programming using Function Approximators . Taylor  Francis CRC Press. ISBN   978-1-4398-2108-4 . Franois-Lavet, Vincent Henderson, Peter Islam, Riashat Bellemare, Marc G. Pineau, Joelle 2018. An Introduction to Deep Reinforcement Learning . Foundations and Trends in Machine Learning . 11 34 219354. arXiv  1811.12560 . doi  10.15612200000071 . Powell, Warren 2007. Approximate dynamic programming solving the curses of dimensionality . Wiley-Interscience. ISBN   978-0-470-17155-4 . Sutton, Richard S.  Barto, Andrew G. 1998. Reinforcement Learning An Introduction . MIT Press. ISBN   978-0-262-19398-6 . Sutton, Richard S. 1988. Learning to predict by the method of temporal differences . Machine Learning . 3  944. doi  10.1007BF00115009 . Szita, Istvan  Szepesvari, Csaba 2010. Model-based Reinforcement Learning with Nearly Tight Exploration Complexity Bounds PDF . ICML 2010 . Omnipress. pp.  10311038. Archived from the original PDF on 2010-07-14. Cite uses deprecated parameter deadurl  help  External links  edit  Reinforcement Learning Repository Reinforcement Learning and Artificial Intelligence RLAI, Rich Suttons lab at the University of Alberta  A Beginners Guide to Deep Reinforcement Learning Autonomous Learning Laboratory ALL, Andrew Bartos lab at the University of Massachusetts Amherst  Hybrid reinforcement learning Real-world reinforcement learning experiments at Delft University of Technology Stanford University Andrew Ng Lecture on Reinforcement Learning Dissecting Reinforcement Learning Series of blog post on RL with Python code v t e Computer science Note This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip SoCs Energy consumption Green computing Electronic design automation Hardware acceleration Computer systems organization Computer architecture Embedded system Real-time computing Dependability Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Software development process Requirements analysis Software design Software construction Software deployment Software maintenance Programming team Open-source model Theory of computation Model of computation Formal language Automata theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security services Intrusion detection system Hardware security Network security Information security Application security Humancomputer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Image manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Book Category Portal Outline WikiProject Commons Retrieved from  httpsen.wikipedia.orgwindex.phptitleReinforcement_learning oldid913269479  Categories  Markov models Machine learning algorithms Belief revision Hidden categories CS1 errors deprecated parameters Webarchive template wayback links Wikipedia articles needing clarification from January 2019 Wikipedia articles needing clarification from July 2018 Wikipedia articles needing clarification from August 2017