Lambda calculus From Wikipedia, the free encyclopedia    Redirected from -calculus  Jump to navigation Jump to search Formal system in mathematical logic Lambda calculus also written as -calculus  is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution . It is a universal model of computation that can be used to simulate any Turing machine . It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics . Lambda calculus consists of constructing lambda terms and performing reduction operations on them. In the simplest form of lambda calculus, terms are built using only the following rules Syntax Name Description x Variable A character or string representing a parameter or mathematicallogical value x.M Abstraction Function definition M is a lambda term. The variable x becomes bound in the expression. M N Application Applying a function to an argument. M and N are lambda terms. producing expressions such as  x . y . z . x . z x   y.z y   x y . Parentheses can be dropped if the expression is unambiguous. For some applications, terms for logical and mathematical constants and operations may be included. The reduction operations include Operation Name Description x.Mx  y.My -conversion Renaming the bound formal variables in the expression. Used to avoid name collisions . x.M E  MxE -reduction Replacing the bound variable with the argument expression in the body of the abstraction If De Bruijn indexing is used, then -conversion is no longer required as there will be no name collisions. If repeated application of the reduction steps eventually terminates, then by the ChurchRosser theorem it will produce a beta normal form . Contents 1 Explanation and applications 2 History 2.1 Origin of the lambda symbol 3 Informal description 3.1 Motivation 3.2 The lambda calculus 3.2.1 Lambda terms 3.2.2 Functions that operate on functions 3.2.3 Alpha equivalence 3.2.4 Free variables 3.2.5 Capture-avoiding substitutions 3.2.6 Beta reduction 4 Formal definition 4.1 Definition 4.2 Notation 4.3 Free and bound variables 5 Reduction 5.1 -conversion 5.1.1 Substitution 5.2 -reduction 5.3 -conversion 6 Normal forms and confluence 7 Encoding datatypes 7.1 Arithmetic in lambda calculus 7.2 Logic and predicates 7.3 Pairs 8 Additional programming techniques 8.1 Named constants 8.2 Recursion and fixed points 8.3 Standard terms 8.4 Abstraction elimination 9 Typed lambda calculus 10 Computable functions and lambda calculus 11 Undecidability of equivalence 12 Lambda calculus and programming languages 12.1 Anonymous functions 12.2 Reduction strategies 12.3 A note about complexity 12.4 Parallelism and concurrency 12.5 Optimal reduction 13 Semantics 14 Variations and extensions 15 See also 16 References 17 Further reading 18 External links Explanation and applications  edit  Lambda calculus is Turing complete , that is, it is a universal model of computation that can be used to simulate any Turing machine . 1  Its namesake, the Greek letter lambda , is used in lambda expressions and lambda terms to denote binding a variable in a function . Lambda calculus may be untyped or typed . In typed lambda calculus, functions can be applied only if they are capable of accepting the given inputs type of data. Typed lambda calculi are weaker than the untyped lambda calculus, which is the primary subject of this article, in the sense that typed lambda calculi can express less than the untyped calculus can, but on the other hand typed lambda calculi allow more things to be proved in the simply typed lambda calculus it is, for example, a theorem that every evaluation strategy terminates for every simply typed lambda-term, whereas evaluation of untyped lambda-terms need not terminate. One reason there are many different typed lambda calculi has been the desire to do more of what the untyped calculus can do without giving up on being able to prove strong theorems about the calculus. Lambda calculus has applications in many different areas in mathematics , philosophy , 2  linguistics , 3  4  and computer science . 5  Lambda calculus has played an important role in the development of the theory of programming languages . Functional programming languages implement the lambda calculus. Lambda calculus is also a current research topic in Category theory . 6  History  edit  The lambda calculus was introduced by mathematician Alonzo Church in the 1930s as part of an investigation into the foundations of mathematics . 7  8  The original system was shown to be logically inconsistent in 1935 when Stephen Kleene and J. B. Rosser developed the KleeneRosser paradox . 9  10  Subsequently, in 1936 Church isolated and published just the portion relevant to computation, what is now called the untyped lambda calculus. 11  In 1940, he also introduced a computationally weaker, but logically consistent system, known as the simply typed lambda calculus . 12  Until the 1960s when its relation to programming languages was clarified, the -calculus was only a formalism. Thanks to Richard Montague and other linguists applications in the semantics of natural language, the -calculus has begun to enjoy a respectable place in both linguistics 13  and computer science. 14  Origin of the lambda symbol  edit  There is a bit of controversy over the reason for Churchs use of the Greek letter lambda  as the notation for function-abstraction in the lambda calculus, perhaps in part due to conflicting explanations by Church himself. According to Cardone and Hindley 2006 By the way, why did Church choose the notation  In an unpublished 1964 letter to Harald Dickson he stated clearly that it came from the notation  x  displaystyle hat x  used for class-abstraction by Whitehead and Russell , by first modifying  x  displaystyle hat x  to  x displaystyle x  to distinguish function-abstraction from class-abstraction, and then changing  to  for ease of printing. This origin was also reported in Rosser, 1984, p.338. On the other hand, in his later years Church told two enquirers that the choice was more accidental a symbol was needed and  just happened to be chosen. Dana Scott has also addressed this controversy in various public lectures. 15  Scott recounts that he once posed a question about the origin of the lambda symbol to Churchs son-in-law John Addison, who then wrote his father-in-law a postcard Dear Professor Church, Russell had the iota operator, Hilbert had the epsilon operator. Why did you choose lambda for your operator According to Scott, Churchs entire response consisted of returning the postcard with the following annotation  eeny, meeny, miny, moe . Informal description  edit  This section includes a list of references , related reading or external links , but its sources remain unclear because it lacks inline citations . Please help to improve this section by introducing more precise citations.  September 2013   Learn how and when to remove this template message  Motivation  edit  Computable functions are a fundamental concept within computer science and mathematics. The -calculus provides a simple semantics for computation, enabling properties of computation to be studied formally. The -calculus incorporates two simplifications that make this semantics simple. The first simplification is that the -calculus treats functions anonymously, without giving them explicit names. For example, the function s q u a r e _ s u m   x , y   x 2  y 2 displaystyle operatorname square_sum x,yx2y2 can be rewritten in anonymous form as  x , y   x 2  y 2 displaystyle x,ymapsto x2y2 read as a tuple of x and y is mapped to x 2  y 2 textstyle x2y2 . Similarly, id   x   x displaystyle operatorname id xx can be rewritten in anonymous form as x  x displaystyle xmapsto x where the input is simply mapped to itself. The second simplification is that the -calculus only uses functions of a single input. An ordinary function that requires two inputs, for instance the s q u a r e _ s u m textstyle operatorname square_sum  function, can be reworked into an equivalent function that accepts a single input, and as output returns another function, that in turn accepts a single input. For example,  x , y   x 2  y 2 displaystyle x,ymapsto x2y2 can be reworked into x   y  x 2  y 2  displaystyle xmapsto ymapsto x2y2 This method, known as currying , transforms a function that takes multiple arguments into a chain of functions each with a single argument. Function application of the s q u a r e _ s u m textstyle operatorname square_sum  function to the arguments 5, 2, yields at once   x , y   x 2  y 2   5 , 2  textstyle x,ymapsto x2y25,2  5 2  2 2 textstyle 5222  29 textstyle 29 , whereas evaluation of the curried version requires one more step   x   y  x 2  y 2    5    2  textstyle Bigl bigl xmapsto ymapsto x2y2bigr 5Bigr 2   y  5 2  y 2   2  textstyle ymapsto 52y22  the definition of x displaystyle x has been used with 5 displaystyle 5 in the inner expression. This is like -reduction.  5 2  2 2 textstyle 5222  the definition of y displaystyle y has been used with 2 displaystyle 2 . Again, similar to -reduction.  29 textstyle 29 to arrive at the same result. The lambda calculus  edit  The lambda calculus consists of a language of lambda terms , which is defined by a certain formal syntax, and a set of transformation rules, which allow manipulation of the lambda terms. These transformation rules can be viewed as an equational theory or as an operational definition . As described above, all functions in the lambda calculus are anonymous functions, having no names. They only accept one input variable, with currying used to implement functions with several variables. Lambda terms  edit  The syntax of the lambda calculus defines some expressions as valid lambda calculus expressions and some as invalid, just as some strings of characters are valid C programs and some are not. A valid lambda calculus expression is called a lambda term. The following three rules give an inductive definition that can be applied to build all syntactically valid lambda terms a variable, x displaystyle x , is itself a valid lambda term if t displaystyle t is a lambda term, and x displaystyle x is a variable, then   x . t  displaystyle lambda x.t is a lambda term called a lambda abstraction  if t displaystyle t and s displaystyle s are lambda terms, then  t s  displaystyle ts is a lambda term called an application . Nothing else is a lambda term. Thus a lambda term is valid if and only if it can be obtained by repeated application of these three rules. However, some parentheses can be omitted according to certain rules. For example, the outermost parentheses are usually not written. See Notation , below. A lambda abstraction  x . t displaystyle lambda x.t is a definition of an anonymous function that is capable of taking a single input x displaystyle x and substituting it into the expression t displaystyle t . It thus defines an anonymous function that takes x displaystyle x and returns t displaystyle t . For example,  x . x 2  2 displaystyle lambda x.x22 is a lambda abstraction for the function f  x   x 2  2 displaystyle fxx22 using the term x 2  2 displaystyle x22 for t displaystyle t . The definition of a function with a lambda abstraction merely sets up the function but does not invoke it. The abstraction binds the variable x displaystyle x in the term t displaystyle t . An application t s displaystyle ts represents the application of a function t displaystyle t to an input s displaystyle s , that is, it represents the act of calling function t displaystyle t on input s displaystyle s to produce t  s  displaystyle ts . There is no concept in lambda calculus of variable declaration. In a definition such as  x . x  y displaystyle lambda x.xy i.e. f  x   x  y displaystyle fxxy , the lambda calculus treats y displaystyle y as a variable that is not yet defined. The lambda abstraction  x . x  y displaystyle lambda x.xy is syntactically valid, and represents a function that adds its input to the yet-unknown y displaystyle y . Bracketing may be used and may be needed to disambiguate terms. For example,  x .    x . x  x  displaystyle lambda x.lambda x.xx and   x .   x . x   x displaystyle lambda x.lambda x.xx denote different terms although they coincidentally reduce to the same value. Here, the first example defines a function whose lambda term is the result of applying x to the child function, while the second example is the application of the outermost function to the input x, which returns the child function. Therefore, both examples evaluate to the identity function  x . x displaystyle lambda x.x . Functions that operate on functions  edit  In lambda calculus, functions are taken to be  first class values , so functions may be used as the inputs, or be returned as outputs from other functions. For example,  x . x displaystyle lambda x.x represents the identity function , x  x displaystyle xmapsto x , and   x . x  y displaystyle lambda x.xy represents the identity function applied to y displaystyle y . Further,   x . y  displaystyle lambda x.y represents the constant function x  y displaystyle xmapsto y , the function that always returns y displaystyle y , no matter the input. In lambda calculus, function application is regarded as left-associative , so that s t x displaystyle stx means  s t  x displaystyle stx . There are several notions of equivalence and reduction that allow lambda terms to be reduced to equivalent lambda terms. Alpha equivalence  edit  A basic form of equivalence, definable on lambda terms, is alpha equivalence. It captures the intuition that the particular choice of a bound variable, in a lambda abstraction, does not usually matter. For instance,  x . x displaystyle lambda x.x and  y . y displaystyle lambda y.y are alpha-equivalent lambda terms, and they both represent the same function the identity function. The terms x displaystyle x and y displaystyle y are not alpha-equivalent, because they are not bound in a lambda abstraction. In many presentations, it is usual to identify alpha-equivalent lambda terms. The following definitions are necessary in order to be able to define beta reduction Free variables  edit  The free variables of a term are those variables not bound by a lambda abstraction. The set of free variables of an expression is defined inductively The free variables of x displaystyle x are just x displaystyle x The set of free variables of  x . t displaystyle lambda x.t is the set of free variables of t displaystyle t , but with x displaystyle x removed The set of free variables of t s displaystyle ts is the union of the set of free variables of t displaystyle t and the set of free variables of s displaystyle s . For example, the lambda term representing the identity  x . x displaystyle lambda x.x has no free variables, but the function  x . y x displaystyle lambda x.yx has a single free variable, y displaystyle y . Capture-avoiding substitutions  edit  Suppose t displaystyle t , s displaystyle s and r displaystyle r are lambda terms and x displaystyle x and y displaystyle y are variables. The notation t  x  r  displaystyle txr indicates substitution of r displaystyle r for x displaystyle x in t displaystyle t in a capture-avoiding manner. This is defined so that x  x  r   r displaystyle xxrr  y  x  r   y displaystyle yxry if x  y displaystyle xneq y   t s   x  r    t  x  r    s  x  r   displaystyle tsxrtxrsxr    x . t   x  r    x . t displaystyle lambda x.txrlambda x.t    y . t   x  r    y .  t  x  r   displaystyle lambda y.txrlambda y.txr if x  y displaystyle xneq y and y displaystyle y is not in the free variables of r displaystyle r . The variable y displaystyle y is said to be fresh for r displaystyle r . For example,   x . x   y  y    x .  x  y  y     x . x displaystyle lambda x.xyylambda x.xyylambda x.x , and    x . y  x   x  y      x . y   x  y    x  x  y      x . y  y displaystyle lambda x.yxxylambda x.yxyxxylambda x.yy . The freshness condition requiring that y displaystyle y is not in the free variables of r displaystyle r  is crucial in order to ensure that substitution does not change the meaning of functions. For example, a substitution is made that ignores the freshness condition   x . y   y  x    x .  y  y  x     x . x displaystyle lambda x.yyxlambda x.yyxlambda x.x . This substitution turns the constant function  x . y displaystyle lambda x.y into the identity  x . x displaystyle lambda x.x by substitution. In general, failure to meet the freshness condition can be remedied by alpha-renaming with a suitable fresh variable. For example, switching back to our correct notion of substitution, in   x . y   y  x  displaystyle lambda x.yyx the lambda abstraction can be renamed with a fresh variable z displaystyle z , to obtain   z . y   y  x    z .  y  y  x     z . x displaystyle lambda z.yyxlambda z.yyxlambda z.x , and the meaning of the function is preserved by substitution. Beta reduction  edit  The beta reduction rule states that an application of the form   x . t  s displaystyle lambda x.ts reduces to the term t  x  s  displaystyle txs . The notation   x . t  s  t  x  s  displaystyle lambda x.tsto txs is used to indicate that   x . t  s displaystyle lambda x.ts beta reduces to t  x  s  displaystyle txs . For example, for every s displaystyle s ,   x . x  s  x  x  s   s displaystyle lambda x.xsto xxss . This demonstrates that  x . x displaystyle lambda x.x really is the identity. Similarly,   x . y  s  y  x  s   y displaystyle lambda x.ysto yxsy , which demonstrates that  x . y displaystyle lambda x.y is a constant function. The lambda calculus may be seen as an idealised version of a functional programming language, like Haskell or Standard ML . Under this view, beta reduction corresponds to a computational step. This step can be repeated by additional beta conversions until there are no more applications left to reduce. In the untyped lambda calculus, as presented here, this reduction process may not terminate. For instance, consider the term     x . x x    x . x x  displaystyle Omega lambda x.xxlambda x.xx . Here   x . x x    x . x x    x x   x   x . x x    x  x   x . x x    x  x   x . x x      x . x x    x . x x  displaystyle lambda x.xxlambda x.xxto xxxlambda x.xxxxlambda x.xxxxlambda x.xxlambda x.xxlambda x.xx . That is, the term reduces to itself in a single beta reduction, and therefore the reduction process will never terminate. Another aspect of the untyped lambda calculus is that it does not distinguish between different kinds of data. For instance, it may be desirable to write a function that only operates on numbers. However, in the untyped lambda calculus, there is no way to prevent a function from being applied to truth values , strings, or other non-number objects. Formal definition  edit  Main article Lambda calculus definition Definition  edit  Lambda expressions are composed of variables v 1 , v 2 , ..., v n , ... the abstraction symbols lambda  and dot . parentheses   The set of lambda expressions, , can be defined inductively  If x is a variable, then x   If x is a variable and M  , then x.M   If M, N  , then M N   Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications. 16  17  Notation  edit  To keep the notation of lambda expressions uncluttered, the following conventions are usually applied Outermost parentheses are dropped M N instead of M N Applications are assumed to be left associative M N P may be written instead of M N P 18  The body of an abstraction extends as far right as possible  x.M N means x.M N and not x.M N A sequence of abstractions is contracted x.y.z.N is abbreviated as xyz.N 19  18  Free and bound variables  edit  The abstraction operator, , is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be bound . In an expression  x . M , the part  x is often called binder , as a hint that the variable x is getting bound by appending  x to M . All other variables are called free . For example, in the expression  y . x x y , y is a bound variable and x is free. Also a variable is bound by its nearest abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda  x . y  x . z x  The set of free variables of a lambda expression, M, is denoted as FVM and is defined by recursion on the structure of the terms, as follows FVx  x, where x is a variable FVx.M  FVM  x FVM N  FVM  FVN 20  An expression that contains no free variables is said to be closed . Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic . Reduction  edit  The meaning of lambda expressions is defined by how expressions can be reduced. 21  There are three kinds of reduction -conversion  changing bound variables  alpha  -reduction  applying functions to their arguments  beta  -conversion  which captures a notion of extensionality  eta . We also speak of the resulting equivalences two expressions are -equivalent , if they can be -converted into the same expression, and -equivalence are defined similarly. The term redex , short for reducible expression , refers to subterms that can be reduced by one of the reduction rules. For example,  x .M N is a beta-redex in expressing the substitution of N for x in M. The expression to which a redex reduces is called its reduct the reduct of  x .M N is M x N . If x is not free in M ,  x .M x is also an eta-redex, with a reduct of M . -conversion  edit  Alpha-conversion, sometimes known as alpha-renaming, 22  allows bound variable names to be changed. For example, alpha-conversion of  x . x might yield  y . y . Terms that differ only by alpha-conversion are called -equivalent . Frequently, in uses of lambda calculus, -equivalent terms are considered to be equivalent. The precise rules for alpha-conversion are not completely trivial. First, when alpha-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an alpha-conversion of  x . x . x could result in  y . x . x , but it could not result in  y . x . y . The latter has a different meaning from the original. This is analogous to the programming notion of variable shadowing . Second, alpha-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace x with y in  x . y . x , we get  y . y . y , which is not at all the same. In programming languages with static scope, alpha-conversion can be used to make name resolution simpler by ensuring that no variable name masks a name in a containing scope see alpha renaming to make name resolution trivial . In the De Bruijn index notation, any two alpha-equivalent terms are syntactically identical. Substitution  edit  Substitution, written .mw-parser-output .monospacedfont-familymonospace,monospace E  V   R  , is the process of replacing all free occurrences of the variable V in the expression E with expression R . Substitution on terms of the -calculus is defined by recursion on the structure of terms, as follows note x and y are only variables while M and N are any  expression. x  x   N  N y  x   N  y , if x  y M 1 M 2  x   N  M 1  x   N M 2  x   N  x .M x   N   x .M  y .M x   N   y .M x   N, if x  y , provided y  FVN To substitute into a lambda abstraction, it is sometimes necessary to -convert the expression. For example, it is not correct for  x . y  y   x  to result in  x . x  , because the substituted x was supposed to be free but ended up being bound. The correct substitution in this case is  z . x  , up to -equivalence. Substitution is defined uniquely up to -equivalence. -reduction  edit  Beta-reduction captures the idea of function application. Beta-reduction is defined in terms of substitution the beta-reduction of   V . E  E     is E  V   E   . For example, assuming some encoding of 2, 7,  , we have the following -reduction  n . n 2 7  7 2 . Beta reduction can be seen to be the same as the concept of local reducibility in natural deduction , via the CurryHoward isomorphism . -conversion  edit  Eta-conversion expresses the idea of extensionality , which in this context is that two functions are the same if and only if they give the same result for all arguments. Eta-conversion converts between  x . f x  and f whenever x does not appear free in f . Eta conversion can be seen to be the same as the concept of local completeness in natural deduction , via the CurryHoward isomorphism . Normal forms and confluence  edit  Main article Normalization property abstract rewriting For the untyped lambda calculus, -reduction as a rewriting rule is neither strongly normalising nor weakly normalising . However, it can be shown that -reduction is confluent when working up to -conversion i.e. we consider two normal forms to be equal if it is possible to -convert one into the other. Therefore, both strongly normalising terms and weakly normalising terms have a unique normal form. For strongly normalising terms, any reduction strategy is guaranteed to yield the normal form, whereas for weakly normalising terms, some reduction strategies may fail to find it. Encoding datatypes  edit  Main articles Church encoding and MogensenScott encoding The basic lambda calculus may be used to model booleans, arithmetic , data structures and recursion, as illustrated in the following sub-sections. Arithmetic in lambda calculus  edit  There are several possible ways to define the natural numbers in lambda calculus, but by far the most common are the Church numerals , which can be defined as follows 0    f . x . x 1    f . x . f x 2    f . x . f  f x  3    f . x . f  f  f x  and so on. Or using the alternative syntax presented above in Notation  0    fx . x 1    fx . f x 2    fx . f  f x  3    fx . f  f  f x  A Church numeral is a higher-order function it takes a single-argument function f , and returns another single-argument function. The Church numeral n is a function that takes a function f as argument and returns the n -th composition of f , i.e. the function f composed with itself n times. This is denoted f  n  and is in fact the n -th power of f considered as an operator f 0 is defined to be the identity function. Such repeated compositions of a single function f  obey the laws of exponents , which is why these numerals can be used for arithmetic. In Churchs original lambda calculus, the formal parameter of a lambda expression was required to occur at least once in the function body, which made the above definition of 0 impossible. One way of thinking about the Church numeral n , which is often useful when analysing programs, is as an instruction repeat n times. For example, using the PAIR and NIL functions defined below, one can define a function that constructs a linked list of n elements all equal to x by repeating prepend another x element n times, starting from an empty list. The lambda term is  n . x . n PAIR x  NIL By varying what is being repeated, and varying what argument that function being repeated is applied to, a great many different effects can be achieved. We can define a successor function, which takes a Church numeral n and returns n  1 by adding another application of f , where mfx means the function f is applied m times on x SUCC    n . f . x . f  n f x  Because the m -th composition of f composed with the n -th composition of f gives the m  n -th composition of f , addition can be defined as follows PLUS    m . n . f . x . m f  n f x  PLUS can be thought of as a function taking two natural numbers as arguments and returning a natural number it can be verified that PLUS 2 3 and 5 are -equivalent lambda expressions. Since adding m to a number n can be accomplished by adding 1 m times, an alternative definition is PLUS    m . n . m SUCC n 23  Similarly, multiplication can be defined as MULT    m . n . f . m  n f  19  Alternatively MULT    m . n . m PLUS n  0 since multiplying m and n is the same as repeating the add n function m times and then applying it to zero. Exponentiation has a rather simple rendering in Church numerals, namely POW    b . e . e b 20  The predecessor function defined by PRED n  n  1 for a positive integer n and PRED 0  0 is considerably more difficult. The formula PRED    n . f . x . n  g . h . h  g f   u . x   u . u  can be validated by showing inductively that if T denotes  g . h . h  g f  , then T  n   u . x    h . h  f  n 1  x  for n  0 . Two other definitions of PRED are given below, one using conditionals and the other using pairs . With the predecessor function, subtraction is straightforward. Defining SUB    m . n . n PRED m , SUB m n yields m  n when m  n and 0 otherwise. Logic and predicates  edit  By convention, the following two definitions known as Church booleans are used for the boolean values TRUE and FALSE  TRUE    x . y . x FALSE    x . y . y Note that FALSE is equivalent to the Church numeral zero defined above Then, with these two -terms, we can define some logic operators these are just possible formulations other expressions are equally correct AND    p . q . p q p OR    p . q . p p q NOT    p .p FALSE TRUE IFTHENELSE    p . a . b . p a b We are now able to compute some logic functions, for example AND TRUE FALSE   p . q . p q p  TRUE FALSE   TRUE FALSE TRUE   x . y . x  FALSE TRUE   FALSE and we see that AND TRUE FALSE is equivalent to FALSE . A predicate is a function that returns a boolean value. The most fundamental predicate is ISZERO , which returns TRUE if its argument is the Church numeral 0 , and FALSE if its argument is any other Church numeral ISZERO    n . n  x .FALSE TRUE The following predicate tests whether the first argument is less-than-or-equal-to the second LEQ    m . n .ISZERO SUB m n  , and since m  n , if LEQ m n and LEQ n m , it is straightforward to build a predicate for numerical equality. The availability of predicates and the above definition of TRUE and FALSE make it convenient to write if-then-else expressions in lambda calculus. For example, the predecessor function can be defined as PRED    n . n  g . k .ISZERO  g 1 k PLUS  g k  1  v .0 0 which can be verified by showing inductively that n  g . k .ISZERO  g 1 k PLUS  g k  1  v .0 is the add n  1 function for n  0. Pairs  edit  A pair 2-tuple can be defined in terms of TRUE and FALSE , by using the Church encoding for pairs . For example, PAIR encapsulates the pair  x , y , FIRST returns the first element of the pair, and SECOND returns the second. PAIR    x . y . f . f x y FIRST    p . p TRUE SECOND    p . p FALSE NIL    x .TRUE NULL    p . p  x . y .FALSE A linked list can be defined as either NIL for the empty list, or the PAIR of an element and a smaller list. The predicate NULL tests for the value NIL . Alternatively, with NIL   FALSE , the construct l  h . t . z .deal_with_head_ h _and_tail_ t  deal_with_nil obviates the need for an explicit NULL test. As an example of the use of pairs, the shift-and-increment function that maps  m , n  to  n , n  1 can be defined as     x .PAIR SECOND x  SUCC SECOND x  which allows us to give perhaps the most transparent version of the predecessor function PRED    n .FIRST  n  PAIR 0 0. Additional programming techniques  edit  There is a considerable body of programming idioms for lambda calculus. Many of these were originally developed in the context of using lambda calculus as a foundation for programming language semantics, effectively using lambda calculus as a low-level programming language . Because several programming languages include the lambda calculus or something very similar as a fragment, these techniques also see use in practical programming, but may then be perceived as obscure or foreign. Named constants  edit  In lambda calculus, a library would take the form of a collection of previously defined functions, which as lambda-terms are merely particular constants. The pure lambda calculus does not have a concept of named constants since all atomic lambda-terms are variables, but one can emulate having named constants by setting aside a variable as the name of the constant, using lambda-abstraction to bind that vari able in the main body, and apply that lambda-abstraction to the intended definition. Thus to use f to mean M some explicit lambda-term in N another lambda-term, the main program, one can say  f . N  M Authors often introduce syntactic sugar , such as let , to permit writing the above in the more intuitive order let f  M in N By chaining such definitions, one can write a lambda calculus program as zero or more function definitions, followed by one lambda-term using those functions that constitutes the main body of the program. A notable restriction of this let is that the name f is not defined in M , since M is outside the scope of the lambda-abstraction binding f  this means a recursive function definition cannot be used as the M with let . The more advanced letrec syntactic sugar construction that allows writing recursive function definitions in that naive style instead additionally employs fixed-point combinators. Recursion and fixed points  edit  Main article Fixed-point combinator See also SKI combinator calculus   Self-application and recursion Recursion is the definition of a function using the function itself. Lambda calculus cannot express this as directly as some other notations all functions are anonymous in lambda calculus, so we cant refer to a value which is yet to be defined, inside the lambda term defining that same value. However, recursion can still be achieved by arranging for a lambda expression to receive itse lf as its argument value, for example in  x . x x  E . Consider the factorial function F n  recursively defined by F n   1, if n  0 else n  F n  1 . In the lambda expression which is to represent this function, a parameter typically the first one will be assumed to receive the lambda expression itself as its value, so that calling it  applying it to an argument  will amount to recursion. Thus to achieve recursion, the intended-as-self-referencing argument called r here must always be passed to itself within the function body, at a call point G    r .  n .1, if n  0 else n   r r  n 1 with r r x  F x  G r x to hold, so r  G and F   G G   x . x x  G The self-application achieves replication here, passing the functions lambda expression on to the next invocation as an argument value, making it available to be referenced and called there. This solves it but requires re-writing each recursive call as self-application. We would like to have a generic solution, without a need for any re-writes G    r .  n .1, if n  0 else n   r  n 1 with r x  F x  G r x to hold, so r  G r  FIX G and F   FIX G where FIX g    r where r  g r   g FIX g  so that FIX G  G FIX G   n .1, if n  0 else n  FIX G  n 1 Given a lambda term with first argument representing recursive call e.g. G here, the fixed-point combinator FIX will return a self-replicating lambda expression representing the recursive function here, F . The function does not need to be explicitly passed to itself at any point, for the self-replication is arranged in advance, when it is created, to be done each time it is called. Thus the original lambda expression FIX G is re-created inside itself, at call-point, achieving self-reference . In fact, there are many possible definitions for this FIX operator, the simplest of them being Y    g . x . g  x x   x . g  x x  In the lambda calculus, Y g is a fixed-point of g , as it expands to Y g  h . x . h  x x   x . h  x x  g  x . g  x x   x . g  x x  g  x . g  x x   x . g  x x  g  Y g  Now, to perform our recursive call to the factorial function, we would simply call  Y G n ,   where n is the number we are calculating the factorial of. Given n  4, for example, this gives  Y G 4 G  Y G 4  r . n .1, if n  0 else n   r  n 1  Y G 4  n .1, if n  0 else n   Y G  n 1 4 1, if 4  0 else 4   Y G 41 4  G  Y G 41 4   n .1, if n  0 else n   Y G  n 1 41 4  1, if 3  0 else 3   Y G 31 4  3  G  Y G 31 4  3   n .1, if n  0 else n   Y G  n 1 31 4  3  1, if 2  0 else 2   Y G 21 4  3  2  G  Y G 21 4  3  2   n .1, if n  0 else n   Y G  n 1 21 4  3  2  1, if 1  0 else 1   Y G 11 4  3  2  1  G  Y G 11 4  3  2  1   n .1, if n  0 else n   Y G  n 1 11 4  3  2  1  1, if 0  0 else 0   Y G 01 4  3  2  1  1 24 Every recursively defined function can be seen as a fixed point of some suitably defined function closing over the recursive call with an extra argument, and therefore, using Y , every recursively defined function can be expressed as a lambda expression. In particular, we can now cleanly define the subtraction, multiplication and comparison predicate of natural numbers recursively. Standard terms  edit  Certain terms have commonly accepted names I    x . x K    x . y . x S    x . y . z . x z  y z  B    x . y . z . x  y z  C    x . y . z . x z y W    x . y . x y y U    x . x x     x . x x      Y    g . x . g  x x   x . g  x x  Several of these have direct applications in the elimination of lambda-abstraction that turns lambda terms into combinator calculus terms. Abstraction elimination  edit  Main article Combinatory_logic   Completeness_of_the_S-K_basis If N is a lambda-term without lambda-abstraction, but possibly containing named constants  combinators , then there exists a lambda-term T  x , N  which is equivalent to  x . N but lacks lambda-abstraction except as part of the named constants, if these are considered non-atomic. This can also be viewed as anonymising variables, as T  x , N  removes all occurrences of x from N , while still allowing argument values to be substituted into the positions where N contains an x . The conversion function T can be defined by T  x , x    I T  x , N    K N if x is not free in N . T  x , M N    S T  x , M  T  x , N  In either case, a term of the form T  x , N  P can reduce by having the initial combinator I , K , or S grab the argument P , just like -reduction of  x . N  P would do. I returns that argument. K throws the argument away, just like  x . N  would do if x has no free occurrence in N . S passes the argument on to both subterms of the application, and then applies the result of the first to the result of the second. The combinators B and C are similar to S , but pass the argument on to only one subterm of an application  B to the argument subterm and C to the function subterm, thus saving a subsequent K if there is no occurrence of x in one subterm. In comparison to B and C , the S combinator actually conflates two functionalities rearranging arguments, and duplicating an argument so that it may be used in two places. The W combinator does only the latter, yielding the B, C, K, W system as an alternative to SKI combinator calculus . Typed lambda calculus  edit  Main article Typed lambda calculus A typed lambda calculus is a typed formalism that uses the lambda-symbol   displaystyle lambda   to denote anonymous function abstraction. In this context, types are usually objects of a syntactic nature that are assigned to lambda terms the exact nature of a type depends on the calculus considered see kinds below. From a certain point of view, typed lambda calculi can be seen as refinements of the untyped lambda calculus but from another point of view, they can also be considered the more fundamental theory and untyped lambda calculus a special case with only one type. 24  Typed lambda calculi are foundational programming languages and are the base of typed functional programming languages such as ML and Haskell and, more indirectly, typed imperative programming languages . Typed lambda calculi play an important role in the design of type systems for programming languages here typability usually captures desirable properties of the program, e.g. the program will not cause a memory access violation. Typed lambda calculi are closely related to mathematical logic and proof theory via the CurryHoward isomorphism and they can be considered as the internal language of classes of categories , e.g. the simply typed lambda calculus is the language of Cartesian closed categories CCCs. Computable functions and lambda calculus  edit  A function F  N  N of natural numbers is a computable function if and only if there exists a lambda expression f such that for every pair of x , y in N , F  x  y if and only if f x      y ,   where x and y are the Church numerals corresponding to x and y , respectively and   meaning equivalence with beta reduction. This is one of the many ways to define computability see the ChurchTuring thesis for a discussion of other approaches and their equivalence. Undecidability of equivalence  edit  There is no algorithm that takes as input two lambda expressions and outputs TRUE or FALSE depending on whether or not the two expressions are equivalent. 11  This was historically the first problem for which undecidability could be proven. As is common for a proof of undecidability, the proof shows that no computable function can decide the equivalence. Churchs thesis is then invoked to show that no algorithm can do so. Churchs proof first reduces the problem to determining whether a given lambda expression has a normal form . A normal form is an equivalent expression that cannot be reduced any further under the rules imposed by the form. Then he assumes that this predicate is computable, and can hence be expressed in lambda calculus. Building on earlier work by Kleene and constructing a Gdel numbering for lambda expressions, he constructs a lambda expression e that closely follows the proof of Gdels first incompleteness theorem . If e is applied to its own Gdel number, a contradiction results. Lambda calculus and programming languages  edit  As pointed out by Peter Landin s 1965 paper A Correspondence between ALGOL 60 and Churchs Lambda-notation 25  , sequential procedural programming languages can be understood in terms of the lambda calculus, which provides the basic mechanisms for procedural abstraction and procedure subprogram application. Anonymous functions  edit  Main article Anonymous function For example, in Lisp the square function can be expressed as a lambda expression as follows  lambda  x    x x  The above example is an expression that evaluates to a first-class function. The symbol lambda creates an anonymous function, given a list of parameter names, x  just a single argument in this case, and an expression that is evaluated as the body of the function,  x x . Anonymous functions are sometimes called lambda expressions. For example, Pascal and many other imperative languages have long supported passing subprograms as arguments to other subprograms through the mechanism of function pointers . However, function pointers are not a sufficient condition for functions to be first class datatypes, because a function is a first class datatype if and only if new instances of the function can be created at run-time. And this run-time creation of functions is supported in Smalltalk , JavaScript , and more recently in Scala , Eiffel agents, C delegates and C11 , among others. Reduction strategies  edit  Further information Evaluation strategy Whether a term is normalising or not, and how much work needs to be done in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between eager evaluation and lazy evaluation . Full beta reductions Any redex can be reduced at any time. This means essentially the lack of any particular reduction strategywith regard to reducibility, all bets are off. Applicative order The rightmost, innermost redex is always reduced first. Intuitively this means a functions arguments are always reduced before the function itself. Applicative order always attempts to apply functions to normal forms, even when this is not possible. Most programming languages including Lisp, ML and imperative languages like C and Java  are described as strict, meaning that functions applied to non-normalising arguments are non-normalising. This is done essentially using applicative order, call by value reduction  see below , but usually called eager evaluation. Normal order The leftmost, outermost redex is always reduced first. That is, whenever possible the arguments are substituted into the body of an abstraction before the arguments are reduced. Call by name As normal order, but no reductions are performed inside abstractions. For example,  x . x . x  x is in normal form according to this strategy, although it contains the redex  x . x  x . Call by value Only the outermost redexes are reduced a redex is reduced only when its right hand side has reduced to a value variable or lambda abstraction. Call by need As normal order, but function applications that would duplicate terms instead name the argument, which is then reduced only when it is needed. Called in practical contexts lazy evaluation. In implementations this name takes the form of a pointer, with the redex represented by a thunk . Applicative order is not a normalising strategy. The usual counterexample is as follows define    where    x . xx . This entire expression contains only one redex, namely the whole expression its reduct is again  . Since this is the only available reduction,  has no normal form under any evaluation strategy. Using applicative order, the expression KI   x . y . x   x . x   is reduced by first reducing  to normal form since it is the rightmost redex, but since  has no normal form, applicative order fails to find a normal form for KI . In contrast, normal order is so called because it always finds a normalising reduction, if one exists. In the above example, KI reduces under normal order to I , a normal form. A drawback is that redexes in the arguments may be copied, resulting in duplicated computation for example,  x . xx   x . x  y  reduces to  x . x  y   x . x  y  using this strategy now there are two redexes, so full evaluation needs two more steps, but if the argument had been reduced first, there would now be none. The positive tradeoff of using applicative order is that it does not cause unnecessary computation, if all arguments are used, because it never substitutes arguments containing redexes and hence never needs to copy them which would duplicate work. In the above example, in applicative order  x . xx   x . x  y  reduces first to  x . xx  y and then to the normal order yy , taking two steps instead of three. Most purely functional programming languages notably Miranda and its descendants, including Haskell, and the proof languages of theorem provers , use lazy evaluation , which is essentially the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using sharing . In the example given above,  x . xx   x . x  y  reduces to  x . x  y   x . x  y  , which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too. A note about complexity  edit  While the idea of beta reduction seems simple enough, it is not an atomic step, in that it must have a non-trivial cost when estimating computational complexity . 26  To be precise, one must somehow find the location of all of the occurrences of the bound variable V in the expression E , implying a time cost, or one must keep track of these locations in some way, implying a space cost. A nave search for the locations of V in E is O  n  in the length n of E . This has led to the study of systems that use explicit substitution . Sinots director strings 27  offer a way of tracking the locations of free variables in expressions. Parallelism and concurrency  edit  The ChurchRosser property of the lambda calculus means that evaluation -reduction can be carried out in any order , even in parallel. This means that various nondeterministic evaluation strategies are relevant. However, the lambda calculus does not offer any explicit constructs for parallelism . One can add constructs such as Futures to the lambda calculus. Other process calculi have been developed for describing communication and concurrency. Optimal reduction  edit  In Lvys 1988 paper  Sharing in the Evaluation of lambda Expressions , he defines a notion of optimal sharing, such that no work is duplicated . For example, performing a beta reduction in normal order on  x . xx  II reduces it to II II . The argument II is duplicated by the application to the first lambda term. If the reduction was done in an applicative order first, we save work because work is not duplicated  x . xx  II reduces to  x . xx  I . On the other hand, using applicative order can result in redundant reductions or even possibly never reduce to normal form. For example, performing a beta reduction in normal order on  f .f I y. x . xx  y I yields y. x . xx  y I I ,  x . xx  II which we know we can do without duplicating work. Doing the same but in applicative order yields  f .f I y.y I y I , y.y I y I I , I I I I , and now work is duplicated. Lvy shows the existence of lambda terms where there does not exist a sequence of reductions which reduces them without duplicating work. The below lambda term is such an example. g.ggx.x h.f.ffz.z w.hwy.y It is composed of three similar terms, xg. ...  h.y and yf. ... w.z  , and finally zw.hwy.y . There are only two possible beta reductions to be done here, on x and on y. Reducing the outer x term first results in the inner y term being duplicated, and each copy will have to be reduced, but reducing the inner y term first will duplicate its argument z, which will cause work to be duplicated when the values of h and w are made known. Incidentally, the above term reduces to the identity function y.y , and is constructed by making wrappers which make the identity function available to the binders gh... , fw... , hx.x at first, and wz.z at first, all of which are applied to the innermost term y.y . The precise notion of duplicated work relies on noticing that after the first reduction of I I is done, the value of the other I I can be determined, because they have the same structure and in fact they have exactly the same values, and result from a common ancestor. Such similar structures can each be assigned a label that can be tracked across reductions. If a name is assigned to the redex that produces all the resulting II terms, and then all duplicated occurrences of II can be tracked and reduced in one go. However, it is not obvious that a redex will produce the II term. Identifying the structures that are similar in different parts of a lambda term can involve a complex algorithm and can possibly have a complexity equal to the history of the reduction itself. While Lvy defines the notion of optimal sharing, he does not provide an algorithm to do it. In Vincent van Oostrom, Kees-Jan van de Looij, and Marijn Zwitserloods paper Lambdascope Another optimal implementation of the lambda-calculus , they provide such an algorithm by transforming lambda terms into interaction nets , which are then reduced. Roughly speaking, the resulting reduction is optimal because every term that would have the same labels as per Lvys paper would also be the same graph in the interaction net. In the paper, they mention that their prototype implementation of Lambdascope performs as well as the optimised version of the reference optimal higher order machine BOHM. More details can be found in the short article About the efficient reduction of lambda terms . Semantics  edit  The fact that lambda calculus terms act as functions on other lambda calculus terms, and even on themselves, led to questions about the semantics of the lambda calculus. Could a sensible meaning be assigned to lambda calculus terms The natural semantics was to find a set D isomorphic to the function space D  D , of functions on itself. However, no nontrivial such D can exist, by cardinality constraints because the set of all functions from D to D has greater cardinality than D , unless D is a singleton set . In the 1970s, Dana Scott showed that, if only continuous functions were considered, a set or domain D with the required property could be found, thus providing a model for the lambda calculus. This work also formed the basis for the denotational semantics of programming languages. Variations and extensions  edit  These extensions are in the lambda cube  Typed lambda calculus  Lambda calculus with typed variables and functions System F  A typed lambda calculus with type-variables Calculus of constructions  A typed lambda calculus with types as first-class values These formal systems are extensions of lambda calculus that are not in the lambda cube Binary lambda calculus  A version of lambda calculus with binary IO, a binary encoding of terms, and a designated universal machine. Lambda-mu calculus  An extension of the lambda calculus for treating classical logic These formal systems are variations of lambda calculus Kappa calculus  A first-order analogue of lambda calculus These formal systems are related to lambda calculus Combinatory logic  A notation for mathematical logic without variables SKI combinator calculus  A computational system based on the S , K and I combinators, equivalent to lambda calculus, but reducible without variable substitutions See also  edit  Mathematics portal Applicative computing systems  Treatment of objects in the style of the lambda calculus Cartesian closed category  A setting for lambda calculus in category theory Categorical abstract machine  A model of computation applicable to lambda calculus CurryHoward isomorphism  The formal correspondence between programs and proofs De Bruijn index  notation disambugating alpha conversions De Bruijn notation  notation using postfix modification functiond Deductive lambda calculus  The consideration of the problems associated with considering lambda calculus as a Deductive system . Domain theory  Study of certain posets giving denotational semantics for lambda calculus Evaluation strategy  Rules for the evaluation of expressions in programming languages Explicit substitution  The theory of substitution, as used in -reduction Functional programming Harrop formula  A kind of constructive logical formula such that proofs are lambda terms Interaction nets KleeneRosser paradox  A demonstration that some form of lambda calculus is inconsistent Knights of the Lambda Calculus  A semi-fictional organization of LISP and Scheme hackers Krivine machine  An abstract machine to interpret call-by-name in lambda-calculus Lambda calculus definition  Formal definition of the lambda calculus. Let expression  An expression closely related to a lambda abstraction. Minimalism computing Rewriting  Transformation of formul in formal systems SECD machine  A virtual machine designed for the lambda calculus ScottCurry theorem  A theorem about sets of lambda terms To Mock a Mockingbird  An introduction to Haskell programming language and lambda calculus Universal Turing machine  A formal computing machine that is equivalent to lambda calculus Unlambda  An esoteric functional programming language based on combinatory logic References  edit   Turing, A. M. December 1937. Computability and -Definability. The Journal of Symbolic Logic . 2 4 153163. doi  10.23072268280 . JSTOR   2268280 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Coquand, Thierry , Type Theory , The Stanford Encyclopedia of Philosophy Summer 2013 Edition, Edward N. Zalta ed..  Moortgat, Michael 1988. Categorial Investigations Logical and Linguistic Aspects of the Lambek Calculus . Foris Publications. ISBN   9789067653879 .  Bunt, Harry Muskens, Reinhard, eds. 2008, Computing Meaning , Springer, ISBN   9781402059575  Mitchell, John C. 2003, Concepts in Programming Languages , Cambridge University Press, p.  57, ISBN   9780521780988 .  Pierce, Benjamin C. Basic Category Theory for Computer Scientists . p.  53.  Church, A. 1932. A set of postulates for the foundation of logic. Annals of Mathematics . Series 2. 33 2 346366. doi  10.23071968337 . JSTOR   1968337 .  For a full history, see Cardone and Hindleys History of Lambda-calculus and Combinatory Logic 2006.  Kleene, S. C.  Rosser, J. B. July 1935. The Inconsistency of Certain Formal Logics. The Annals of Mathematics . 36 3 630. doi  10.23071968646 .  Church, Alonzo December 1942. Review of Haskell B. Curry, The Inconsistency of Certain Formal Logics . The Journal of Symbolic Logic . 7 4 170171. doi  10.23072268117 . JSTOR   2268117 .  a b Church, A. 1936. An unsolvable problem of elementary number theory. American Journal of Mathematics . 58 2 345363. doi  10.23072371045 . JSTOR   2371045 .  Church, A. 1940. A Formulation of the Simple Theory of Types. Journal of Symbolic Logic . 5 2 5668. doi  10.23072266170 . JSTOR   2266170 .  Partee, B. B. H. ter Meulen, A. Wall, R. E. 1990. Mathematical Methods in Linguistics . Springer . Retrieved 29 Dec 2016 .  Alama, Jesse The Lambda Calculus , The Stanford Encyclopedia of Philosophy Summer 2013 Edition, Edward N. Zalta ed..  Dana Scott,  Looking Backward Looking Forward , Invited Talk at the Workshop in honour of Dana Scotts 85th birthday and 50 years of domain theory, 7-8 July, FLoC 2018 talk 7 July 2018. The relevant passage begins at 3250 . See also this extract of a May 2016 talk at the University of Birmingham, UK.  Barendregt, Hendrik Pieter 1984. The Lambda Calculus Its Syntax and Semantics . Studies in Logic and the Foundations of Mathematics. 103 Revised ed.. North Holland. ISBN   0-444-87508-5 .  Corrections .  a b Example for Rules of Associativity . Lambda-bound.com . Retrieved 2012-06-18 .  a b Selinger, Peter 2008, Lecture Notes on the Lambda Calculus PDF , 0804 , Department of Mathematics and Statistics, University of Ottawa, p.  9, arXiv  0804.3434 , Bibcode  2008arXiv0804.3434S  a b Barendregt, Henk  Barendsen, Erik March 2000, Introduction to Lambda Calculus PDF  de Queiroz, Ruy J. G. B. 1988. A Proof-Theoretic Account of Programming and the Role of Reduction Rules. Dialectica . 42 4 265282. doi  10.1111j.1746-8361.1988.tb00919.x .  Turbak, Franklyn Gifford, David 2008, Design concepts in programming languages , MIT press, p.  251, ISBN   978-0-262-20175-9  Felleisen, Matthias Flatt, Matthew 2006, Programming Languages and Lambda Calculi PDF , p.  26, archived from the original PDF on 2009-02-05  a note accessed 2017 at the original location suggests that the authors consider the work originally referenced to have been superseded by a book.  Types and Programming Languages, p. 273, Benjamin C. Pierce  Landin, P. J. 1965. A Correspondence between ALGOL 60 and Churchs Lambda-notation . Communications of the ACM . 8 2 89101. doi  10.1145363744.363749 .  Statman, R. 1979. The typed -calculus is not elementary recursive . Theoretical Computer Science . 9 1 7381. doi  10.10160304-39757990007-0 .  Sinot, F.-R. 2005. Director Strings Revisited A Generic Approach to the Efficient Representation of Free Variables in Higher-order Rewriting . Journal of Logic and Computation . 15 2 201218. doi  10.1093logcomexi010 .  permanent dead link  Further reading  edit  Abelson, Harold  Gerald Jay Sussman. Structure and Interpretation of Computer Programs . The MIT Press . ISBN   0-262-51087-1 . Hendrik Pieter Barendregt Introduction to Lambda Calculus . Henk Barendregt , The Impact of the Lambda Calculus in Logic and Computer Science . The Bulletin of Symbolic Logic, Volume 3, Number 2, June 1997. Barendregt, Hendrik Pieter , The Type Free Lambda Calculus pp10911132 of Handbook of Mathematical Logic , North-Holland 1977 ISBN   0-7204-2285-X Cardone and Hindley, 2006. History of Lambda-calculus and Combinatory Logic . In Gabbay and Woods eds., Handbook of the History of Logic , vol. 5. Elsevier. Church, Alonzo, An unsolvable problem of elementary number theory , American Journal of Mathematics , 58 1936, pp.  345363. This paper contains the proof that the equivalence of lambda expressions is in general not decidable. Alonzo Church, The Calculi of Lambda-Conversion  ISBN   978-0-691-08394-0  1  Kleene, Stephen, A theory of positive integers in formal logic , American Journal of Mathematics , 57 1935, pp.  153173 and 219244. Contains the lambda calculus definitions of several familiar functions. Landin, Peter , A Correspondence Between ALGOL 60 and Churchs Lambda-Notation , Communications of the ACM , vol. 8, no. 2 1965, pages 89101. Available from the ACM site . A classic paper highlighting the importance of lambda calculus as a basis for programming languages. Larson, Jim, An Introduction to Lambda Calculus and Scheme . A gentle introduction for programmers. Schalk, A. and Simmons, H. 2005 An introduction to -calculi and arithmetic with a decent selection of exercises . Notes for a course in the Mathematical Logic MSc at Manchester University. de Queiroz, Ruy J.G.B. 2008 On Reduction Rules, Meaning-as-Use and Proof-Theoretic Semantics . Studia Logica , 90 2211247. doi  10.1007s11225-008-9150-5 . A paper giving a formal underpinning to the idea of meaning-is-use which, even if based on proofs, it is different from proof-theoretic semantics as in the DummettPrawitz tradition since it takes reduction as the rules giving meaning. Hankin, Chris, An Introduction to Lambda Calculi for Computer Scientists, ISBN   0954300653 Monographstextbooks for graduate students Morten Heine Srensen, Pawe Urzyczyn, Lectures on the CurryHoward isomorphism , Elsevier, 2006, ISBN   0-444-52077-5 is a recent monograph that covers the main topics of lambda calculus from the type-free variety, to most typed lambda calculi , including more recent developments like pure type systems and the lambda cube . It does not cover subtyping extensions. Pierce, Benjamin 2002, Types and Programming Languages , MIT Press, ISBN   0-262-16209-1 covers lambda calculi from a practical type system perspective some topics like dependent types are only mentioned, but subtyping is an important topic. Some parts of this article are based on material from FOLDOC , used with permission . External links  edit  Graham Hutton, Lambda Calculus , a short 12 minutes Computerphile video on the Lambda Calculus Helmut Brandl, A Step by Step Introduction into Lambda Calculus Hazewinkel, Michiel , ed. 2001 1994, Lambda-calculus , Encyclopedia of Mathematics , Springer ScienceBusiness Media B.V.  Kluwer Academic Publishers, ISBN   978-1-55608-010-4 Achim Jung, A Short Introduction to the Lambda Calculus - PDF  Dana Scott, A timeline of lambda calculus - PDF  David C. Keenan, To Dissect a Mockingbird A Graphical Notation for the Lambda Calculus with Animated Reduction Ral Rojas, A Tutorial Introduction to the Lambda Calculus - PDF  Peter Selinger, Lecture Notes on the Lambda Calculus - PDF  L. Allison, Some executable -calculus examples Georg P. Loczewski, The Lambda Calculus and A Bret Victor, Alligator Eggs A Puzzle Game Based on Lambda Calculus Lambda Calculus on Safalras Website Lambda Calculus . PlanetMath . LCI Lambda Interpreter a simple yet powerful pure calculus interpreter Lambda Calculus links on Lambda-the-Ultimate Mike Thyer, Lambda Animator , a graphical Java applet demonstrating alternative reduction strategies. Implementing the Lambda calculus using C Templates Marius Buliga, Graphic lambda calculus Lambda Calculus as a Workflow Model by Peter Kelly, Paul Coddington, and Andrew Wendelborn mentions graph reduction as a common means of evaluating lambda expressions and discusses the applicability of lambda calculus for distributed computing due to the ChurchRosser property, which enables parallel graph reduction for lambda expressions. Shane Steinert-Threlkeld, Lambda Calculi , Internet Encyclopedia of Philosophy Anton Salikhmetov, Macro Lambda Calculus Authority control BNF  cb119586908 data GND  4166495-4 LCCN  sh85074174 SUDOC  027576345  Frink Jr., Orrin 1944. Review The Calculi of Lambda-Conversion by Alonzo Church PDF . Bull. Amer. Math. Soc . 50 3 169172. doi  10.1090s0002-9904-1944-08090-7 . Retrieved from  httpsen.wikipedia.orgwindex.phptitleLambda_calculus oldid914166566  Categories  1936 in computer science Computability theory Formal methods Lambda calculus Models of computation Theoretical computer science Hidden categories All articles with dead external links Articles with dead external links from December 2017 Articles with permanently dead external links Articles with short description Articles lacking in-text citations from September 2013 All articles lacking in-text citations Wikipedia articles with BNF identifiers Wikipedia articles with GND identifiers Wikipedia articles with LCCN identifiers Wikipedia articles with SUDOC identifiers Articles with example code