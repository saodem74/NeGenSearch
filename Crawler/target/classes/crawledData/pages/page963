Methods of computing square roots From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article has multiple issues. Please help improve it or discuss these issues on the talk page .  Learn how and when to remove these template messages  This article possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed.  January 2012   Learn how and when to remove this template message  This article may be too technical for most readers to understand . Please help improve it to make it understandable to non-experts , without removing the technical details.  September 2012   Learn how and when to remove this template message  This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources   Methods of computing square roots     news    newspapers    books    scholar    JSTOR  July 2017   Learn how and when to remove this template message  This article may be too long to read and navigate comfortably . The readable prose size is 61 kilobytes. Please consider splitting content into sub-articles, condensing it, or adding subheadings .  June 2019   Learn how and when to remove this template message  The sequence we get by computing the square root of two with the Babylonian method with different starting points In numerical analysis , a branch of mathematics, there are several square root algorithms or methods of computing the principal square root of a non-negative real number . For the square roots of a negative or complex number , see below . Finding S displaystyle sqrt S is the same as solving the equation f  x   x 2  S  0 displaystyle fxx2-S0, for a positive x displaystyle x . Therefore, any general numerical root-finding algorithm can be used. Newtons method , for example, reduces in this case to the so-called Babylonian method x n  1  x n  f  x n  f   x n   x n  x n 2  S 2 x n  1 2  x n  S x n  displaystyle x_n1x_n-frac fx_nfx_nx_n-frac x_n2-S2x_nfrac 12leftx_nfrac Sx_nright These methods generally yield approximate results, but can be made arbitrarily precise by increasing the number of calculation steps. Contents 1 Rough estimation 2 Babylonian method 2.1 Example 2.2 Convergence 2.2.1 Worst case for convergence 2.2.2 Scaling Herons algorithm 3 Bakhshali method 3.1 Example 4 Digit-by-digit calculation 4.1 Basic principle 4.2 Decimal base 10 4.2.1 Examples 4.3 Binary numeral system base 2 4.3.1 Example 5 Exponential identity 6 Vedic duplex method for extracting a square root 6.1 Basic principle 6.2 Example 7 A two-variable iterative method 8 Iterative methods for reciprocal square roots 8.1 Goldschmidts algorithm 9 Taylor series 10 CORDIC 11 Continued fraction expansion 11.1 Algorithm 11.2 Example, square root of 114 as a continued fraction 11.3 Generalized continued fraction 12 Lucas sequence method 13 Using Pells equation 14 Approximations that depend on the floating point representation 14.1 Reciprocal of the square root 15 Negative or complex square 16 See also 17 Notes 18 External links Rough estimation  edit  Many square root algorithms require an initial seed value . If the initial seed value is far away from the actual square root, the algorithm will be slowed down. It is therefore useful to have a rough estimate, which may be very inaccurate but easy to calculate. With S displaystyle S expressed in scientific notation as a  10 2 n displaystyle atimes 102n where 1  a  100 displaystyle 1leq a 100 and n is an integer, the square root S  a  10 n displaystyle sqrt Ssqrt atimes 10n can be estimated as S   2  10 n if   a  10 , 6  10 n if   a  10. displaystyle sqrt Sapprox begincases2cdot 10n textif a 10,6cdot 10n textif ageq 10.endcases The factors two and six are used because they approximate the geometric means of the lowest and highest possible values with the given number of digits 1  10  10 4  2 displaystyle sqrt sqrt 1cdot sqrt 10sqrt410approx 2, and 10  100  1000 4  6 displaystyle sqrt sqrt 10cdot sqrt 100sqrt41000approx 6, . For S  125348  12.5348  10 4 displaystyle S12534812.5348times 104 , the estimate is S  6  10 2  600 displaystyle sqrt Sapprox 6cdot 102600 . When working in the binary numeral system as computers do internally, by expressing S displaystyle S as a  2 2 n displaystyle atimes 22n where 0.1 2  a  10 2 displaystyle 0.1_2leq a 10_2 , the square root S  a  2 n displaystyle sqrt Ssqrt atimes 2n can be estimated as S  2 n displaystyle sqrt Sapprox 2n , since the geometric mean of the lowest and highest possible values is 0.1 2  10 2  1 4  1 displaystyle sqrt sqrt 0.1_2cdot sqrt 10_2sqrt411 . For S  125348  1 1110 1001 1010 0100 2  1.1110 1001 1010 0100 2  2 16 displaystyle S12534811110100110100100_21.1110100110100100_2times 216, the binary approximation gives S  2 8  1 0000 0000 2  256 . displaystyle sqrt Sapprox 28100000000_2256,. These approximations are useful to find better seeds for iterative algorithms, which results in faster convergence. Babylonian method  edit  Herons method redirects here. For the formula used to find the area of a triangle, see Herons formula . Graph charting the use of the Babylonian method for approximating a square root of 100 10 using starting values x 0    50 , x 0    1 , and x 0     5 . Note that a positive starting value yields the positive root, and a negative starting value the negative root. Perhaps the first algorithm used for approximating S displaystyle sqrt S is known as the Babylonian method , despite there being no direct evidence, beyond informed conjecture, that the eponymous Babylonian mathematicians employed exactly this method. 1  The method is also known as Herons method , after the first-century Greek mathematician Hero of Alexandria who gave the first explicit description of the method in his AD 60 work Metrica . 2  The basic idea is that if x is an overestimate to the square root of a non-negative real number S then S  x will be an underestimate, or vice versa, and so the average of these two numbers may reasonably be expected to provide a better approximation though the formal proof of that assertion depends on the inequality of arithmetic and geometric means that shows this average is always an overestimate of the square root, as noted in the article on square roots , thus assuring convergence. More precisely, if x is our initial guess of S displaystyle sqrt S and e is the error in our estimate such that S   x  e  2 , then we can expand the binomial and solve for e  S  x 2 2 x  e  S  x 2 2 x , displaystyle efrac S-x22xeapprox frac S-x22x, since e  x displaystyle ell x . Therefore, we can compensate for the error and update our old estimate as x  e  x  S  x 2 2 x  S  x 2 2 x  S x  x 2  x revised displaystyle xeapprox xfrac S-x22xfrac Sx22xfrac frac Sxx2equiv x_textrevised Since the computed error was not exact, this becomes our next best guess. The process of updating is iterated until desired accuracy is obtained. This is a quadratically convergent algorithm, which means that the number of correct digits of the approximation roughly doubles with each iteration. It proceeds as follows Begin with an arbitrary positive starting value x 0 the closer to the actual square root of S , the better. Let x n  1 be the average of x n and S  x n using the arithmetic mean to approximate the geometric mean . Repeat step 2 until the desired accuracy is achieved. It can also be represented as x 0  S , displaystyle x_0approx sqrt S, x n  1  1 2  x n  S x n  , displaystyle x_n1frac 12leftx_nfrac Sx_nright, S  lim n   x n . displaystyle sqrt Slim _nto infty x_n. This algorithm works equally well in the p -adic numbers , but cannot be used to identify real square roots with p -adic square roots one can, for example, construct a sequence of rational numbers by this method that converges to 3 in the reals, but to 3 in the 2-adics. It can be derived from Newtons method which it predates by 16 centuries Writing f  x   x 2  S displaystyle fxx2-S , x n  1  x n  f  x n  f   x n   x n  x n 2  S 2 x n  1 2  2 x n   x n  S x n    1 2  x n  S x n  . displaystyle x_n1x_n-dfrac fx_nfx_nx_n-dfrac x_n2-S2x_ndfrac 12Bigl 2x_n-bigl x_n-dfrac Sx_nbigr Bigr dfrac 12Bigl x_ndfrac Sx_nBigr _. Example  edit  To calculate  S , where S  125348, to six significant figures, use the rough estimation method above to get x 0  6  10 2  600.000 x 1  1 2  x 0  S x 0   1 2  600.000  125348 600.000   404.457 x 2  1 2  x 1  S x 1   1 2  404.457  125348 404.457   357.187 x 3  1 2  x 2  S x 2   1 2  357.187  125348 357.187   354.059 x 4  1 2  x 3  S x 3   1 2  354.059  125348 354.059   354.045 x 5  1 2  x 4  S x 4   1 2  354.045  125348 354.045   354.045 displaystyle beginalignedbeginarrayrlllx_0 6cdot 102  600.0000.3emx_1 frac 12leftx_0frac Sx_0right frac 12left600.000frac 125348600.000right 404.4570.3emx_2 frac 12leftx_1frac Sx_1right frac 12left404.457frac 125348404.457right 357.1870.3emx_3 frac 12leftx_2frac Sx_2right frac 12left357.187frac 125348357.187right 354.0590.3emx_4 frac 12leftx_3frac Sx_3right frac 12left354.059frac 125348354.059right 354.0450.3emx_5 frac 12leftx_4frac Sx_4right frac 12left354.045frac 125348354.045right 354.045endarrayendaligned Therefore,  125348  354.045 . Convergence  edit  Suppose that x 0  0 and S  0. Then for any natural number n , x n  0. Let the relative error in x n be defined by  n  x n S  1   1 displaystyle varepsilon _nfrac x_nsqrt S-1 -1 and thus x n  S   1   n  . displaystyle x_nsqrt Scdot 1varepsilon _n. Then it can be shown that  n  1   n 2 2  1   n   0. displaystyle varepsilon _n1frac varepsilon _n221varepsilon _ngeq 0. And thus that  n  2  min   n  1 2 2 ,  n  1 2  displaystyle varepsilon _n2leq min leftfrac varepsilon _n122,frac varepsilon _n12right and consequently that convergence is assured, and quadratic . Worst case for convergence  edit  If using the rough estimate above with the Babylonian method, then the least accurate cases in ascending order are as follows S  1  x 0  2  x 1  1.250   1  0.250. S  10  x 0  2  x 1  3.500   1  0.107. S  10  x 0  6  x 1  3.833   1  0.213. S  100  x 0  6  x 1  11.333   1  0.134. displaystyle beginalignedS 1 x_0 2 x_1 1.250 varepsilon _1 0.250.S 10 x_0 2 x_1 3.500 varepsilon _1  0.107.S 10 x_0 6 x_1 3.833 varepsilon _1  0.213.S 100 x_0 6 x_1 11.333 varepsilon _1  0.134.endaligned Thus in any case,  1  2  2 . displaystyle varepsilon _1leq 2-2.,  2  2  5  10  1 . displaystyle varepsilon _2 2-5 10-1.,  3  2  11  10  3 . displaystyle varepsilon _3 2-11 10-3.,  4  2  23  10  6 . displaystyle varepsilon _4 2-23 10-6.,  5  2  47  10  14 . displaystyle varepsilon _5 2-47 10-14.,  6  2  95  10  28 . displaystyle varepsilon _6 2-95 10-28.,  7  2  191  10  57 . displaystyle varepsilon _7 2-191 10-57.,  8  2  383  10  115 . displaystyle varepsilon _8 2-383 10-115., Rounding errors will slow the convergence. It is recommended to keep at least one extra digit beyond the desired accuracy of the x n being calculated to minimize round off error. Scaling Herons algorithm  edit  Efficiency of Heron algorithm can be enhanced by prescaling. If S   0.5 , 2.0  displaystyle Sin 0.5,2.0 then, using a starting guess x 0  1.0 displaystyle x_01.0 , Heron algorithm proceeds with quadratic convergence and 5 iterations of the algorithm are sufficient to compute S displaystyle sqrt S with 16 digit accuracy. Prescaling consists in finding an integer number k such that S  2 2 k S  displaystyle S22ktilde S , where S    0.5 , 2.0  displaystyle tilde Sin 0.5,2.0 , then solve the intermediate problem z  S  displaystyle zsqrt tilde S by performing a fixed number of iterations of the Heron method starting from z 0  1.0 displaystyle z_01.0 , finally obtain the solution x  2 k z displaystyle x2kz . This technique is particularly effective when working with floating point numbers in binary format e.g. IEEE-754, as the determination of k and S  displaystyle tilde S is trivial. In fact, these numbers are represented in the format 1. x x x  2 p displaystyle 1.xxxdots 2p where mantissa and exponent are immediately available. Then if p is even, then S   1. x x x  displaystyle tilde S1.xxxdots  and k  p  2 displaystyle kp2 , otherwise S   1. x x x   2.0 displaystyle tilde S1.xxxdots 2.0 and k   p  1   2 displaystyle kp12 . Note that there is no floating point mathematical operation involved here, as multiplication and division by powers of 2 can be done with trivial integer operations on the exponent. Similarly, no floating point operation is required when computing the final solution x  2 k z displaystyle x2kz . Bakhshali method  edit  This method for finding an approximation to a square root was described in an ancient Indian mathematical manuscript called the Bakhshali manuscript . It is equivalent to two iterations of the Babylonian method beginning with x 0 . Thus, the algorithm is quartically convergent, which means that the number of correct digits of the approximation roughly quadruples with each iteration. 3  The original presentation, using modern notation, is as follows To calculate S displaystyle sqrt S , let x 0 2 be the initial approximation to S . Then, successively iterate as a n  S  x n 2 2 x n , displaystyle a_nfrac S-x_n22x_n, b n  x n  a n , displaystyle b_nx_na_n, x n  1  b n  a n 2 2 b n . displaystyle x_n1b_n-frac a_n22b_n. Written explicitly, it becomes x n  1   x n  a n   a n 2 2  x n  a n  . displaystyle x_n1x_na_n-frac a_n22x_na_n. Let x 0  N be an integer which is the nearest perfect square to S . Also, let the difference d  S - N 2 , then the first iteration can be written as S  N  d 2 N  d 2 8 N 3  4 N d  8 N 4  8 N 2 d  d 2 8 N 3  4 N d  N 4  6 N 2 S  S 2 4 N 3  4 N S  N 2  N 2  6 S   S 2 4 N  N 2  S  . displaystyle sqrt Sapprox Nfrac d2N-frac d28N34Ndfrac 8N48N2dd28N34Ndfrac N46N2SS24N34NSfrac N2N26SS24NN2S. This gives a rational approximation to the square root. Example  edit  Using the same example as given in Babylonian method, let S  125348. displaystyle S125348. Then, the first iterations gives x 0  600 displaystyle x_0600 a 1  125348  600 2 2  600   195.543 displaystyle a_1frac 125348-60022times 600-195.543 b 1  600    195.543   404.456 displaystyle b_1600-195.543404.456 x 1  404.456    195.543  2 2  404.456  357.186 displaystyle x_1404.456-frac -195.54322times 404.456357.186 Likewise the second iteration gives a 2  125348  357.186 2 2  357.186   3.126 displaystyle a_2frac 125348-357.18622times 357.186-3.126 b 2  357.186    3.126   354.06 displaystyle b_2357.186-3.126354.06 x 2  354.06    3.1269  2 2  354.06  354.046 displaystyle x_2354.06-frac -3.126922times 354.06354.046 Digit-by-digit calculation  edit  This is a method to find each digit of the square root in a sequence. It is slower than the Babylonian method, but it has several advantages It can be easier for manual calculations. Every digit of the root found is known to be correct, i.e., it does not have to be changed later. If the square root has an expansion that terminates, the algorithm terminates after the last digit is found. Thus, it can be used to check whether a given integer is a square number . The algorithm works for any base , and naturally, the way it proceeds depends on the base chosen. Napiers bones include an aid for the execution of this algorithm. The shifting n th root algorithm is a generalization of this method. Basic principle  edit  First, consider the case of finding the square root of a number Z , that is the square of a two-digit number XY , where X is the tens digit and Y is the units digit. Specifically Z  10X  Y 2  100X 2  20XY  Y 2 Now using the Digit-by-Digit algorithm, we first determine the value of X . X is the largest digit such that X 2 is less or equal to Z from which we removed the two rightmost digits. In the next iteration, we pair the digits, multiply X by 2, and place it in the tenths place while we try to figure out what the value of Y is. Since this is a simple case where the answer is a perfect square root XY , the algorithm stops here. The same idea can be extended to any arbitrary square root computation next. Suppose we are able to find the square root of N by expressing it as a sum of n positive numbers such that N   a 1  a 2  a 3    a n  2 . displaystyle Na_1a_2a_3dotsb a_n2. By repeatedly applying the basic identity  x  y  2  x 2  2 x y  y 2 , displaystyle xy2x22xyy2, the right-hand-side term can be expanded as  a 1  a 2  a 3    a n  2  a 1 2  2 a 1 a 2  a 2 2  2  a 1  a 2  a 3  a 3 2    a n  1 2  2   i  1 n  1 a i  a n  a n 2  a 1 2   2 a 1  a 2  a 2   2  a 1  a 2   a 3  a 3     2   i  1 n  1 a i   a n  a n . displaystyle beginaligned a_1a_2a_3dotsb a_n2 ,a_122a_1a_2a_222a_1a_2a_3a_32dotsb a_n-122leftsum _i1n-1a_irighta_na_n2 ,a_122a_1a_2a_22a_1a_2a_3a_3dotsb left2leftsum _i1n-1a_irighta_nrighta_n.endaligned This expression allows us to find the square root by sequentially guessing the values of a i displaystyle a_i s. Suppose that the numbers a 1 ,  , a m  1 displaystyle a_1,ldots ,a_m-1 have already been guessed, then the m-th term of the right-hand-side of above summation is given by Y m   2 P m  1  a m  a m , displaystyle Y_m2P_m-1a_ma_m, where P m  1   i  1 m  1 a i displaystyle P_m-1sum _i1m-1a_i is the approximate square root found so far. Now each new guess a m displaystyle a_m should satisfy the recursion X m  X m  1  Y m , displaystyle X_mX_m-1-Y_m, such that X m  0 displaystyle X_mgeq 0 for all 1  m  n , displaystyle 1leq mleq n, with initialization X 0  N . displaystyle X_0N. When X n  0 , displaystyle X_n0, the exact square root has been found if not, then the sum of a i displaystyle a_i s gives a suitable approximation of the square root, with X n displaystyle X_n being the approximation error. For example, in the decimal number system we have N   a 1  10 n  1  a 2  10 n  2    a n  1  10  a n  2 , displaystyle Na_1cdot 10n-1a_2cdot 10n-2cdots a_n-1cdot 10a_n2, where 10 n  i displaystyle 10n-i are place holders and the coefficients a i   0 , 1 , 2 ,  , 9  displaystyle a_iin 0,1,2,ldots ,9 . At any m-th stage of the square root calculation, the approximate root found so far, P m  1 displaystyle P_m-1 and the summation term Y m displaystyle Y_m are given by P m  1   i  1 m  1 a i  10 n  i  10 n  m  1  i  1 m  1 a i  10 m  i  1 , displaystyle P_m-1sum _i1m-1a_icdot 10n-i10n-m1sum _i1m-1a_icdot 10m-i-1, Y m   2 P m  1  a m  10 n  m  a m  10 n  m   20  i  1 m  1 a i  10 m  i  1  a m  a m  10 2  n  m  . displaystyle Y_m2P_m-1a_mcdot 10n-ma_mcdot 10n-m20sum _i1m-1a_icdot 10m-i-1a_ma_mcdot 102n-m. Here since the place value of Y m displaystyle Y_m is an even power of 10, we only need to work with the pair of most significant digits of the remaining term X m  1 displaystyle X_m-1 at any m-th stage. The section below codifies this procedure. It is obvious that a similar method can be used to compute the square root in number systems other than the decimal number system. For instance, finding the digit-by-digit square root in the binary number system is quite efficient since the value of a i displaystyle a_i is searched from a smaller set of binary digits 0,1. This makes the computation faster since at each stage the value of Y m displaystyle Y_m is either Y m  0 displaystyle Y_m0 for a m  0 displaystyle a_m0 or Y m  2 P m  1  1 displaystyle Y_m2P_m-11 for a m  1 displaystyle a_m1 . The fact that we have only two possible options for a m displaystyle a_m also makes the process of deciding the value of a m displaystyle a_m at m-th stage of calculation easier. This is because we only need to check if Y m  X m  1 displaystyle Y_mleq X_m-1 for a m  1. displaystyle a_m1. If this condition is satisfied, then we take a m  1 displaystyle a_m1  if not then a m  0. displaystyle a_m0. Also, the fact that multiplication by 2 is done by left bit-shifts helps in the computation. Decimal base 10  edit  Write the original number in decimal form. The numbers are written similar to the long division algorithm, and, as in long division, the root will be written on the line above. Now separate the digits into pairs, starting from the decimal point and going both left and right. The decimal point of the root will be above the decimal point of the square. One digit of the root will appear above each pair of digits of the square. Beginning with the left-most pair of digits, do the following procedure for each pair Starting on the left, bring down the most significant leftmost pair of digits not yet used if all the digits have been used, write 00 and write them to the right of the remainder from the previous step on the first step, there will be no remainder. In other words, multiply the remainder by 100 and add the two digits. This will be the current value c . Find p , y and x , as follows Let p be the part of the root found so far , ignoring any decimal point. For the first step, p  0. Determine the greatest digit x such that x  20 p  x   c displaystyle x20pxleq c . We will use a new variable y  x 20 p  x . Note 20 p  x is simply twice p , with the digit x appended to the right. Note x can be found by guessing what c 20 p  is and doing a trial calculation of y , then adjusting x upward or downward as necessary. Place the digit x displaystyle x as the next digit of the root, i.e., above the two digits of the square you just brought down. Thus the next p will be the old p times 10 plus x . Subtract y from c to form a new remainder. If the remainder is zero and there are no more digits to bring down, then the algorithm has terminated. Otherwise go back to step 1 for another iteration. Examples  edit  Find the square root of 152.2756. 1 2. 3 4   01 52.27 56 01 11  1  22 x  1 01 y  xx  11  1 00 52 222  52  233 x  2 00 44 y  20xx  222  44 08 27 2433  827  2444 x  3 07 29 y  240xx  2433  729 98 56 24644  9856  24655 x  4 98 56 y  2460xx  24644  9856 00 00 Algorithm terminates Answer is 12.34 Find the square root of 2. 1. 4 1 4 2   02.00 00 00 00 02 11  2  22 x  1 01 y  xx  11  1 01 00 244  100  255 x  4 00 96 y  20xx  244  96 04 00 2811  400  2822 x  1 02 81 y  280xx  2811  281 01 19 00 28244  11900  28255 x  4 01 12 96 y  2820xx  28244  11296 06 04 00 282822  60400  282833 x  2 The desired precision is achieved The square root of 2 is about 1.4142 Binary numeral system base 2  edit  Inherent to digit-by-digit algorithms is a search and test step find a digit, e displaystyle ,e , when added to the right of a current solution r displaystyle ,r , such that  r  e    r  e   x displaystyle ,recdot releq x , where x displaystyle ,x is the value for which a root is desired. Expanding r  r  2 r e  e  e  x displaystyle ,rcdot r2reecdot eleq x . The current value of r  r displaystyle ,rcdot r or, usually, the remaindercan be incrementally updated efficiently when working in binary, as the value of e displaystyle ,e will have a single bit set a power of 2, and the operations needed to compute 2  r  e displaystyle ,2cdot rcdot e and e  e displaystyle ,ecdot e can be replaced with faster bit shift operations. Example  edit  Here we obtain the square root of 81, which when converted into binary gives 1010001. The numbers in the left column gives the option between that number or zero to be used for subtraction at that stage of computation. The final answer is 1001, which in decimal is 9. 1 0 0 1 ---------  1010001 1 1 1 --------- 101 01 0 -------- 1001 100 0 -------- 10001 10001 10001 ------- 0 This gives rise to simple computer implementations 4  short isqrt  short num   short res  0  short bit  1   14   The second-to-top bit is set 1   30 for 32 bits  bit  starts at the highest power of four  the argument. while  bit  num  bit   2  while  bit  0   if  num  res  bit   num - res  bit  res   res   1   bit   else res   1  bit   2   return res   Using the notation above, the variable bit corresponds to e m 2 displaystyle e_m2 which is  2 m  2  4 m displaystyle 2m24m , the variable res is equal to 2 r e m displaystyle 2re_m , and the variable num is equal to the current X m displaystyle X_m which is the difference of the number we want the square root of and the square of our current approximation with all bits set up to 2 m  1 displaystyle 2m1 . Thus in the first loop, we want to find the highest power of 4 in bit to find the highest power of 2 in e displaystyle e . In the second loop, if num is greater than res  bit, then X m displaystyle X_m is greater than 2 r e m  e m 2 displaystyle 2re_me_m2 and we can subtract it. The next line, we want to add e m displaystyle e_m to r displaystyle r which means we want to add 2 e m 2 displaystyle 2e_m2 to 2 r e m displaystyle 2re_m so we want res  res  bit  1 . Then update e m displaystyle e_m to e m  1 displaystyle e_m-1 inside res which involves dividing by 2 or another shift to the right. Combining these 2 into one line leads to res  res  1  bit . If X m displaystyle X_m isnt greater than 2 r e m  e m 2 displaystyle 2re_me_m2 then we just update e m displaystyle e_m to e m  1 displaystyle e_m-1 inside res and divide it by 2. Then we update e m displaystyle e_m to e m  1 displaystyle e_m-1 in bit by dividing it by 4. The final iteration of the 2nd loop has bit equal to 1 and will cause update of e displaystyle e to run one extra time removing the factor of 2 from res making it our integer approximation of the root. Faster algorithms, in binary and decimal or any other base, can be realized by using lookup tablesin effect trading more storage space for reduced run time . 5  Exponential identity  edit  Pocket calculators typically implement good routines to compute the exponential function and the natural logarithm , and then compute the square root of S using the identity found using the properties of logarithms  ln  x n  n ln  x displaystyle ln xnnln x  and exponentials  e ln  x  x displaystyle eln xx  S  e 1 2 ln  S . displaystyle sqrt Sefrac 12ln S. The denominator in the fraction corresponds to the n th root. In the case above the denominator is 2, hence the equation specifies that the square root is to be found. The same identity is used when computing square roots with logarithm tables or slide rules . Vedic duplex method for extracting a square root  edit  The Vedic duplex method from the book  Vedic Mathematics  is a variant of the digit-by-digit method for calculating the square root. 6  The duplex is the square of the central digit plus double the cross-product of digits equidistant from the center. The duplex is computed from the quotient digits square root digits computed thus far, but after the initial digits. The duplex is subtracted from the dividend digit prior to the second subtraction for the product of the quotient digit times the divisor digit. For perfect squares the duplex and the dividend will get smaller and reach zero after a few steps. For non-perfect squares the decimal value of the square root can be calculated to any precision desired. However, as the decimal places proliferate, the duplex adjustment gets larger and longer to calculate. The duplex method follows the Vedic ideal for an algorithm, one-line, mental calculation. It is flexible in choosing the first digit group and the divisor. Small divisors are to be avoided by starting with a larger initial group. Basic principle  edit  We proceed as with the digit-by-digit calculation by assuming that we want to express a number N as a square of the sum of n positive numbers as N   a 0  a 1    a n  1  2 displaystyle Na_0a_1cdots a_n-12  a 0 2  2 a 0  i  1 n  1 a i  a 1 2  2 a 1  i  2 n  1 a i    a n  1 2 . displaystyle a_022a_0sum _i1n-1a_ia_122a_1sum _i2n-1a_icdots a_n-12. Define divisor as q  2 a 0 displaystyle q2a_0 and the duplex for a sequence of m numbers as d m   a  m  2  2   i  1  m  2  2 a i a m  i  1 for   m  odd  i  1 m  2 2 a i a m  i  1 for   m  even . displaystyle d_mbegincasesa_lceil m2rceil 2sum _i1lfloor m2rfloor 2a_ia_m-i1 textfor mtext oddsum _i1m22a_ia_m-i1 textfor mtext even.endcases Thus, we can re-express the above identity in terms of the divisor and the duplexes as N  a 0 2   i  1 n  1  q a i  d i  . displaystyle N-a_02sum _i1n-1qa_id_i. Now the computation can proceed by recursively guessing the values of a m displaystyle a_m so that X m  X m  1  q a m  d m , displaystyle X_mX_m-1-qa_m-d_m, such that X m  0 displaystyle X_mgeq 0 for all 1  m  n  1 displaystyle 1leq mleq n-1 , with initialization X 0  N  a 0 2 . displaystyle X_0N-a_02. When X m  0 displaystyle X_m0 the algorithm terminates and the sum of a i displaystyle a_i s give the square root. The method is more similar to long division where X m  1 displaystyle X_m-1 is the dividend and X m displaystyle X_m is the remainder. For the case of decimal numbers, if N   a 0  10 n  1  a 1  10 n  2    a n  2  10  a n  1  2 displaystyle Na_0cdot 10n-1a_1cdot 10n-2cdots a_n-2cdot 10a_n-12 where a i   0 , 1 , 2 ,  , 9  displaystyle a_iin 0,1,2,ldots ,9 , then the initiation X 0  N  a 0 2  10 2  n  1  displaystyle X_0N-a_02cdot 102n-1 and the divisor will be q  2 a 0  10 n  1 displaystyle q2a_0cdot 10n-1 . Also the product at any m-th stage will be q a m  10 n  m  1  2 a 0 a m  10 2 n  m  2 displaystyle qa_mcdot 10n-m-12a_0a_mcdot 102n-m-2 and the duplexes will be d m  d  m  10 2 n  m  3 displaystyle d_mtilde d_mcdot 102n-m-3 , where d  m displaystyle tilde d_m are the duplexes of the sequence a 1 , a 2 ,  , a m displaystyle a_1,a_2,ldots ,a_m . At any m-th stage, we see that the place value of the duplex d  m displaystyle tilde d_m is one less than the product 2 a 0 a m displaystyle 2a_0a_m . Thus, in actual calculations it is customary to subtract the duplex value of the m-th stage at m1-th stage. Also, unlike the previous digit-by-digit square root calculation, where at any given m-th stage, the calculation is done by taking the most significant pair of digits of the remaining term X m  1 displaystyle X_m-1 , the duplex method uses only a single most significant digit of X m  1 displaystyle X_m-1 . In other words, to calculate the duplex of a number, double the product of each pair of equidistant digits plus the square of the center digit of the digits to the right of the colon. Number Calculation  Duplex 3 3 2  9 14 214  8 574 254  7 2  89 1,421 211  242  2  16  18 10,523 213  202  5 2  6025  31 406,739 249 203 267  72084  156 In a square root calculation the quotient digit set increases incrementally for each step. Example  edit  Consider the perfect square 2809  53 2 . Use the duplex method to find the square root of 2,809. Set down the number in groups of two digits . Define a divisor , a dividend and a quotient to find the root . Given 2809. Consider the first group, 28. Find the nearest perfect square below that group. The root of that perfect square is the first digit of our root . Since 28  25 and 25  5 2 , take 5 as the first digit in the square root. For the divisor take double this first digit 2  5, which is 10. Next, set up a division framework with a colon. 28 0 9 is the dividend and 5 is the quotient .  Note the quotient should always be a single digit number, and it should be such that the dividend in the next stage is non-negative.  Put a colon to the right of 28 and 5 and keep the colons lined up vertically. The duplex is calculated only on quotient digits to the right of the colon. Calculate the remainder . 28 minus 25 is 3. Append the remainder on the left of the next digit to get the new dividend. Here, append 3 to the next dividend digit 0, which makes the new dividend 30. The divisor 10 goes into 30 just 3 times. No reserve needed here for subsequent deductions. Repeat the operation. The zero remainder appended to 9. Nine is the next dividend. This provides a digit to the right of the colon so deduct the duplex, 3 2  9. Subtracting this duplex from the dividend 9, a zero remainder results. Ten into zero is zero. The next root digit is zero. The next duplex is 230  0. The dividend is zero. This is an exact square root, 53. Find the square root of 2809. Set down the number in groups of two digits. The number of groups gives the number of whole digits in the root. Put a colon after the first group, 28, to separate it. From the first group, 28, obtain the divisor, 10, since 28 255 2 and by doubling this first root, 2x510. Gross dividend 28 0 9. Using mental math Divisor 10 3 0 Square 10 28 3 0 9 Duplex, Deduction 25 xx 09 Square root 5 3. 0 Dividend 30 00 Remainder 3 00 00 Square Root, Quotient 5 3. 0 A two-variable iterative method  edit  This method is applicable for finding the square root of 0  S  3 displaystyle 0 S 3, and converges best for S  1 displaystyle Sapprox 1 . This, however, is no real limitation for a computer based calculation, as in base 2 floating point and fixed point representations, it is trivial to multiply S displaystyle S, by an integer power of 4, and therefore S displaystyle sqrt S by the corresponding power of 2, by changing the exponent or by shifting, respectively. Therefore, S displaystyle S, can be moved to the range 1 2  S  2 displaystyle frac 12leq S 2 . Moreover, the following method does not employ general divisions, but only additions, subtractions, multiplications, and divisions by powers of two, which are again trivial to implement. A disadvantage of the method is that numerical errors accumulate, in contrast to single variable iterative methods such as the Babylonian one. The initialization step of this method is a 0  S displaystyle a_0S, c 0  S  1 displaystyle c_0S-1, while the iterative steps read a n  1  a n  a n c n  2 displaystyle a_n1a_n-a_nc_n2, c n  1  c n 2  c n  3   4 displaystyle c_n1c_n2c_n-34, Then, a n  S displaystyle a_nrightarrow sqrt S while c n  0 displaystyle c_nrightarrow 0 . Note that the convergence of c n displaystyle c_n, , and therefore also of a n displaystyle a_n, , is quadratic. The proof of the method is rather easy. First, rewrite the iterative definition of c n displaystyle c_n, as 1  c n  1   1  c n   1  c n  2  2 displaystyle 1c_n11c_n1-c_n22, . Then it is straightforward to prove by induction that S  1  c n   a n 2 displaystyle S1c_na_n2 and therefore the convergence of a n displaystyle a_n, to the desired result S displaystyle sqrt S is ensured by the convergence of c n displaystyle c_n, to 0, which in turn follows from  1  c 0  2 displaystyle -1 c_0 2, . This method was developed around 1950 by M. V. Wilkes , D. J. Wheeler and S. Gill 7  for use on EDSAC , one of the first electronic computers. 8  The method was later generalized, allowing the computation of non-square roots. 9  Iterative methods for reciprocal square roots  edit  The following are iterative methods for finding the reciprocal square root of S which is 1  S displaystyle 1sqrt S . Once it has been found, find S displaystyle sqrt S by simple multiplication S  S   1  S  displaystyle sqrt SScdot 1sqrt S . These iterations involve only multiplication, and not division. They are therefore faster than the Babylonian method . However, they are not stable. If the initial value is not close to the reciprocal square root, the iterations will diverge away from it rather than converge to it. It can therefore be advantageous to perform an iteration of the Babylonian method on a rough estimate before starting to apply these methods. Applying Newtons method to the equation  1  x 2   S  0 displaystyle 1x2-S0 produces a method that converges quadratically using three multiplications per step x n  1  x n 2   3  S  x n 2  . displaystyle x_n1frac x_n2cdot 3-Scdot x_n2. Another iteration is obtained by Halleys method , which is the Householders method of order two. This converges cubically , but involves four multiplications per iteration  citation needed  y n  S  x n 2 displaystyle y_nScdot x_n2 , and x n  1  x n 8   15  y n   10  3  y n   displaystyle x_n1frac x_n8cdot 15-y_ncdot 10-3cdot y_n . Goldschmidts algorithm  edit  Some computers use Goldschmidts algorithm to simultaneously calculate S displaystyle sqrt S and 1  S displaystyle 1sqrt S . Goldschmidts algorithm finds S displaystyle sqrt S faster than Newton-Raphson iteration on a computer with a fused multiplyadd instruction and either a pipelined floating point unit or two independent floating-point units. 10  The first way of writing Goldschmidts algorithm begins b 0  S displaystyle b_0S Y 0  1  S displaystyle Y_0approx 1sqrt S typically using a table lookup y 0  Y 0 displaystyle y_0Y_0 x 0  S y 0 displaystyle x_0Sy_0 and iterates b n  1  b n Y n 2 displaystyle b_n1b_nY_n2 Y n  1   3  b n  1   2 displaystyle Y_n13-b_n12 x n  1  x n Y n  1 displaystyle x_n1x_nY_n1 y n  1  y n Y n  1 displaystyle y_n1y_nY_n1 until b i displaystyle b_i is sufficiently close to 1, or a fixed number of iterations. The iterations converge to lim n   x n  S displaystyle lim _nto infty x_nsqrt S , and lim n   y n  1  S displaystyle lim _nto infty y_n1sqrt S . Note that it is possible to omit either x n displaystyle x_n and y n displaystyle y_n from the computation, and if both are desired then x n  S y n displaystyle x_nSy_n may be used at the end rather than computing it through in each iteration. A second form, using fused multiply-add operations, begins y 0  1  S displaystyle y_0approx 1sqrt S typically using a table lookup x 0  S y 0 displaystyle x_0Sy_0 h 0  y 0  2 displaystyle h_0y_02 and iterates r n  0.5  x n h n displaystyle r_n0.5-x_nh_n x n  1  x n  x n r n displaystyle x_n1x_nx_nr_n h n  1  h n  h n r n displaystyle h_n1h_nh_nr_n until r i displaystyle r_i is sufficiently close to 0, or a fixed number of iterations. This converges to lim n   x n  S displaystyle lim _nto infty x_nsqrt S , and lim n   2 h n  1  S displaystyle lim _nto infty 2h_n1sqrt S . Taylor series  edit  If N is an approximation to S displaystyle sqrt S , a better approximation can be found by using the Taylor series of the square root function N 2  d  N  n  0    1  n  2 n    1  2 n  n  2 4 n d n N 2 n  N  1  d 2 N 2  d 2 8 N 4  d 3 16 N 6  5 d 4 128 N 8    displaystyle sqrt N2dNsum _n0infty frac -1n2n1-2nn24nfrac dnN2nN1frac d2N2-frac d28N4frac d316N6-frac 5d4128N8cdots  As an iterative method, the order of convergence is equal to the number of terms used. With two terms, it is identical to the Babylonian method . With three terms, each iteration takes almost as many operations as the Bakhshali approximation , but converges more slowly.  citation needed  Therefore, this is not a particularly efficient way of calculation. To maximize the rate of convergence, choose N so that  d  N 2 displaystyle frac dN2, is as small as possible. CORDIC  edit  A completely different method for computing the square root is based on the CORDIC algorithm, which uses only very simple operations addition, subtraction, with bitshift and table lookup to implement multiplication. The square root of S may be obtained as the output x n displaystyle x_n using the hyperbolic coordinate system in vectoring mode, with the following initialization 11  x 0  S  1 displaystyle x_0S1 y 0  S  1 displaystyle y_0S-1  0  0 displaystyle omega _00 Continued fraction expansion  edit  See also solving quadratic equations with continued fractions Quadratic irrationals numbers of the form a  b c displaystyle frac asqrt bc , where a , b and c are integers, and in particular, square roots of integers, have periodic continued fractions . Sometimes what is desired is finding not the numerical value of a square root, but rather its continued fraction expansion, and hence its rational approximation. Let S be the positive number for which we are required to find the square root. Then assuming a to be a number that serves as an initial guess and r to be the remainder term, we can write S  a 2  r . displaystyle Sa2r. Since we have S  a 2   S  a   S  a   r displaystyle S-a2sqrt Sasqrt S-ar , we can express the square root of S as S  a  r a  S . displaystyle sqrt Safrac rasqrt S. By applying this expression for S displaystyle sqrt S to the denominator term of the fraction, we have S  a  r a   a  r a  S   a  r 2 a  r a  S . displaystyle sqrt Safrac raafrac rasqrt Safrac r2afrac rasqrt S. Proceeding this way, we get a generalized continued fraction for the square root as S  a  r   2 a  r   2 a  r   2 a   displaystyle sqrt Safrac r2afrac r2afrac r2acdots  For any S a possible choice for a and r is a  1 and r  S - 1, yielding S  1  S  1   2  S  1   2  S  1   2   displaystyle sqrt S1frac S-12frac S-12frac S-12cdots  For example, for the square root of 2, we can take a  1 and r  1, giving us 2  1  1   2  1   2  1   2   displaystyle sqrt 21frac 12frac 12frac 12cdots  Taking the first three denominators give the rational approximation of  2 as 12,2,2  1712  1.41667, correct up to first three decimal places. Taking the first five denominators gives the rational approximation to  2 as 12,2,2,2,2  9970  1.4142857, correct up to first five decimal places. Taking more denominators give better approximations. As another example, for the square root of 3, we can select a  2 and r  -1, giving us 3  2  1   4  1   4  1   4   displaystyle sqrt 32-frac 14-frac 14-frac 14-cdots  The first three denominators gives  3 as 1.73214, correct up to the first four decimal places. Note that it is not necessary to choose an integer valued a . For instance, we can take a   2 and r  1, such that 3  2  1   2 2  1   2 2  1   2 2   displaystyle sqrt 3sqrt 2frac 12sqrt 2frac 12sqrt 2frac 12sqrt 2cdots  We can do the same for the whole numbers as well. For instance, 2  4  1  3   2  3   2  3   2   displaystyle 2sqrt 41frac 32frac 32frac 32cdots  Algorithm  edit  The following iterative algorithm 12  can be used to obtain the continued fraction expansion in canonical form  S is any natural number that is not a perfect square  m 0  0 displaystyle m_00, d 0  1 displaystyle d_01, a 0   S  displaystyle a_0leftlfloor sqrt Srightrfloor , m n  1  d n a n  m n displaystyle m_n1d_na_n-m_n, d n  1  S  m n  1 2 d n displaystyle d_n1frac S-m_n12d_n, a n  1   S  m n  1 d n  1    a 0  m n  1 d n  1  . displaystyle a_n1leftlfloor frac sqrt Sm_n1d_n1rightrfloor leftlfloor frac a_0m_n1d_n1rightrfloor . Notice that m n , d n , and a n are always integers. The algorithm terminates when this triplet is the same as one encountered before. The algorithm can also terminate on a i when a i  2 a 0 , 13  which is easier to implement. The expansion will repeat from then on. The sequence  a 0  a 1 , a 2 , a 3 , ... is the continued fraction expansion S  a 0  1 a 1  1 a 2  1 a 3   displaystyle sqrt Sa_0cfrac 1a_1cfrac 1a_2cfrac 1a_3,ddots  Example, square root of 114 as a continued fraction  edit  Begin with m 0    0 d 0    1 and a 0    10 10 2    100 and 11 2    121     114 so 10 chosen. 114  114  0 1  10  114  10 1  10   114  10   114  10  114  10  10  114  100 114  10  10  1 114  10 14 . displaystyle beginalignedsqrt 114 frac sqrt 1140110frac sqrt 114-10110frac sqrt 114-10sqrt 11410sqrt 11410 10frac 114-100sqrt 1141010frac 1frac sqrt 1141014.endaligned m 1  d 0  a 0  m 0  1  10  0  10 . displaystyle m_1d_0cdot a_0-m_01cdot 10-010,. d 1  S  m 1 2 d 0  114  10 2 1  14 . displaystyle d_1frac S-m_12d_0frac 114-102114,. a 1   a 0  m 1 d 1    10  10 14    20 14   1 . displaystyle a_1leftlfloor frac a_0m_1d_1rightrfloor leftlfloor frac 101014rightrfloor leftlfloor frac 2014rightrfloor 1,. So, m 1    10 d 1    14 and a 1    1. 114  10 14  1  114  4 14  1  114  16 14  114  4   1  1 114  4 7 . displaystyle frac sqrt 11410141frac sqrt 114-4141frac 114-1614sqrt 11441frac 1frac sqrt 11447. Next, m 2    4 d 2    7 and a 2    2. 114  4 7  2  114  10 7  2  14 7  114  10   2  1 114  10 2 . displaystyle frac sqrt 114472frac sqrt 114-1072frac 147sqrt 114102frac 1frac sqrt 114102. 114  10 2  10  114  10 2  10  14 2  114  10   10  1 114  10 7 . displaystyle frac sqrt 11410210frac sqrt 114-10210frac 142sqrt 1141010frac 1frac sqrt 114107. 114  10 7  2  114  4 7  2  98 7  114  4   2  1 114  4 14 . displaystyle frac sqrt 1141072frac sqrt 114-472frac 987sqrt 11442frac 1frac sqrt 114414. 114  4 14  1  114  10 14  1  14 14  114  10   1  1 114  10 1 . displaystyle frac sqrt 1144141frac sqrt 114-10141frac 1414sqrt 114101frac 1frac sqrt 114101. 114  10 1  20  114  10 1  20  14 114  10  20  1 114  10 14 . displaystyle frac sqrt 11410120frac sqrt 114-10120frac 14sqrt 1141020frac 1frac sqrt 1141014. Now, loop back to the second equation above. Consequently, the simple continued fraction for the square root of 114 is 114   10  1 , 2 , 10 , 2 , 1 , 20 , 1 , 2 , 10 , 2 , 1 , 20 , 1 , 2 , 10 , 2 , 1 , 20 ,   . displaystyle sqrt 114101,2,10,2,1,20,1,2,10,2,1,20,1,2,10,2,1,20,dots ., sequence A010179 in the OEIS  Its decimal value is approximately 10.67707 82520 31311 21.... Generalized continued fraction  edit  A more rapid method is to evaluate its generalized continued fraction . From the formula derived there  z  x 2  y  x  y 2 x  y 2 x  y 2 x    x  2 x  y 2  2 z  y   y  y 2 2  2 z  y   y 2 2  2 z  y    displaystyle sqrt zsqrt x2yxcfrac y2xcfrac y2xcfrac y2xddots xcfrac 2xcdot y22z-y-y-cfrac y222z-y-cfrac y222z-y-ddots  and the fact that 114 is 23 of the way between 10 2 100 and 11 2 121 results in 114  1026 3  32 2  2 3  32 3  2  3 64  2 64  2 64  2 64    32 3  2 192  18 192  18 192   , displaystyle sqrt 114cfrac sqrt 10263cfrac sqrt 32223cfrac 323cfrac 2364cfrac 264cfrac 264cfrac 264ddots cfrac 323cfrac 2192cfrac 18192cfrac 18192ddots , which is simply the aforementioned 101,2, 10,2,1, 20,1,2, 10,2,1, 20,1,2, ... evaluated at every third term. Combining pairs of fractions produces 114  32 2  2 3  32 3  64  3 2050  1  1 2050  1 2050    32 3  64 6150  3  9 6150  9 6150   , displaystyle sqrt 114cfrac sqrt 32223cfrac 323cfrac 6432050-1-cfrac 12050-cfrac 12050-ddots cfrac 323cfrac 646150-3-cfrac 96150-cfrac 96150-ddots , which is now 101,2, 10,2,1,20,1,2, 10,2,1,20,1,2, ... evaluated at the third term and every six terms thereafter. Lucas sequence method  edit  the Lucas sequence of the first kind U n  P , Q  is defined by the recurrence relations  U n  P , Q    0 if   n  0 1 if   n  1 P  U n  1  P , Q   Q  U n  2  P , Q  Otherwise displaystyle U_nP,Qbegincases0 textif n01 textif n1Pcdot U_n-1P,Q-Qcdot U_n-2P,Q textOtherwiseendcases and the characteristic equation of it is x 2  P  x  Q  0 displaystyle x2-Pcdot xQ0 it has the discriminant D  P 2  4 Q displaystyle DP2-4Q and the roots x 1  P  D 2 , x 2  P  D 2 displaystyle beginmatrixx_1frac Psqrt D2, x_2frac P-sqrt D2endmatrix all that yield the following positive value lim n   U n  1 U n  x 1 displaystyle lim _nto infty frac U_n1U_nx_1 so when we want a displaystyle sqrt a , we can choose P  2 displaystyle P2 and Q  1  a displaystyle Q1-a , and then calculate x 1  1  a displaystyle x_11sqrt a using U n  1 displaystyle U_n1 and U n displaystyle U_n for large value of n displaystyle n . The most effective way to calculate U n  1 displaystyle U_n1 and U n displaystyle U_n is  U n U n  1    0 1  Q P    U n  1 U n    0 1  Q P  n   U 0 U 1  displaystyle beginbmatrixU_nU_n1endbmatrixbeginbmatrix0 1-Q Pendbmatrixcdot beginbmatrixU_n-1U_nendbmatrixbeginbmatrix0 1-Q Pendbmatrixncdot beginbmatrixU_0U_1endbmatrix Summary  0 1 a  1 2  n   0 1    U n U n  1  displaystyle beginbmatrix0 1a-1 2endbmatrixncdot beginbmatrix01endbmatrixbeginbmatrixU_nU_n1endbmatrix then when n   displaystyle nto infty   a  U n  1 U n  1 displaystyle sqrt afrac U_n1U_n-1 Using Pells equation  edit  Pells equation also known as Brahmagupta equation since he was the first to give a solution to this particular equation  citation needed   and its variants yield a method for efficiently finding continued fraction convergents of square roots of integers. However, it can be complicated to execute, and usually not every convergent is generated. The ideas behind the method are as follows If  p , q  is a solution where p and q are integers to the equation p 2  S  q 2  1 displaystyle p2Scdot q2pm 1 , then p q displaystyle frac pq is a continued fraction convergent of S displaystyle sqrt S , and as such, is an excellent rational approximation to it. If  p a , q a  and  p b , q b  are solutions, then so is p  p a p b  S  q a q b displaystyle pp_ap_bScdot q_aq_b, q  p a q b  p b q a displaystyle qp_aq_bp_bq_a, compare to the multiplication of quadratic integers  More generally, if  p 1 , q 1  is a solution, then it is possible to generate a sequence of solutions  p n , q n  satisfying p m  n  p m p n  S  q m q n displaystyle p_mnp_mp_nScdot q_mq_n, q m  n  p m q n  p n q m displaystyle q_mnp_mq_np_nq_m, The method is as follows Find positive integers p 1 and q 1 such that p 1 2  S  q 1 2  1 displaystyle p_12Scdot q_12pm 1 . This is the hard part It can be done either by guessing, or by using fairly sophisticated techniques. To generate a long list of convergents, iterate p n  1  p 1 p n  S  q 1 q n displaystyle p_n1p_1p_nScdot q_1q_n, q n  1  p 1 q n  p n q 1 displaystyle q_n1p_1q_np_nq_1, To find the larger convergents quickly, iterate p 2 n  p n 2  S  q n 2 displaystyle p_2np_n2Scdot q_n2, q 2 n  2 p n q n displaystyle q_2n2p_nq_n, Notice that the corresponding sequence of fractions coincides with the one given by the Heros method starting with p 1 q 1 displaystyle textstyle frac p_1q_1 . In either case, p n q n displaystyle frac p_nq_n is a rational approximation satisfying  p n q n  S   1 q n 2  S . displaystyle leftfrac p_nq_n-sqrt Sright frac 1q_n2cdot sqrt S. Approximations that depend on the floating point representation  edit  A number is represented in a floating point format as m  b p displaystyle mtimes bp which is also called scientific notation . Its square root is m  b p  2 displaystyle sqrt mtimes bp2 and similar formulae would apply for cube roots and logarithms. On the face of it, this is no improvement in simplicity, but suppose that only an approximation is required then just b p  2 displaystyle bp2 is good to an order of magnitude. Next, recognise that some powers, p , will be odd, thus for 3141.59  3.14159  10 3 rather than deal with fractional powers of the base, multiply the mantissa by the base and subtract one from the power to make it even. The adjusted representation will become the equivalent of 31.4159  10 2 so that the square root will be  31.4159  10. If the integer part of the adjusted mantissa is taken, there can only be the values 1 to 99, and that could be used as an index into a table of 99 pre-computed square roots to complete the estimate. A computer using base sixteen would require a larger table, but one using base two would require only three entries the possible bits of the integer part of the adjusted mantissa are 01 the power being even so there was no shift, remembering that a normalised floating point number always has a non-zero high-order digit or if the power was odd, 10 or 11, these being the first two bits of the original mantissa. Thus, 6.25  110.01 in binary, normalised to 1.1001  2 2 an even power so the paired bits of the mantissa are 01, while .625  0.101 in binary normalises to 1.01  2 1 an odd power so the adjustment is to 10.1  2 2 and the paired bits are 10. Notice that the low order bit of the power is echoed in the high order bit of the pairwise mantissa. An even power has its low-order bit zero and the adjusted mantissa will start with 0, whereas for an odd power that bit is one and the adjusted mantissa will start with 1. Thus, when the power is halved, it is as if its low order bit is shifted out to become the first bit of the pairwise mantissa. A table with only three entries could be enlarged by incorporating additional bits of the mantissa. However, with computers, rather than calculate an interpolation into a table, it is often better to find some simpler calculation giving equivalent results. Everything now depends on the exact details of the format of the representation, plus what operations are available to access and manipulate the parts of the number. For example, Fortran offers an EXPONENTx function to obtain the power. Effort expended in devising a good initial approximation is to be recouped by thereby avoiding the additional iterations of the refinement process that would have been needed for a poor approximation. Since these are few one iteration requires a divide, an add, and a halving the constraint is severe. Many computers follow the IEEE or sufficiently similar representation, and a very rapid approximation to the square root can be obtained for starting Newtons method. The technique that follows is based on the fact that the floating point format in base two approximates the base-2 logarithm. That is log 2   m  2 p   p  log 2   m  displaystyle log _2mtimes 2pplog _2m So for a 32-bit single precision floating point number in IEEE format where notably, the power has a bias of 127 added for the represented form you can get the approximate logarithm by interpreting its binary representation as a 32-bit integer, scaling it by 2  23 displaystyle 2-23 , and removing a bias of 127, i.e. x int  2  23  127  log 2   x  . displaystyle x_textintcdot 2-23-127approx log _2x. For example, 1.0 is represented by a hexadecimal number 0x3F800000, which would represent 1065353216  127  2 23 displaystyle 1065353216127cdot 223 if taken as an integer. Using the formula above you get 1065353216  2  23  127  0 displaystyle 1065353216cdot 2-23-1270 , as expected from log 2   1.0  displaystyle log _21.0 . In a similar fashion you get 0.5 from 1.5 0x3FC00000. To get the square root, divide the logarithm by 2 and convert the value back. The following program demonstrates the idea. Note that the exponents lowest bit is intentionally allowed to propagate into the mantissa. One way to justify the steps in this program is to assume b displaystyle b is the exponent bias and n displaystyle n is the number of explicitly stored bits in the mantissa and then show that    x int  2 n  b   2   b   2 n   x int  2 n   2    b  1   2   2 n . displaystyle x_textint2n-b2bcdot 2nx_textint-2n2b12cdot 2n.  Assumes that float is in the IEEE 754 single precision floating point format  and that int is 32 bits.  float sqrt_approx  float z   int val_int    int    z   Same bits, but as an int    To justify the following code, prove that   val_int  2m - b  2  b  2m  val_int - 2m  2  b  1  2  2m   where   b  exponent bias  m  number of mantissa bits   .  val_int - 1   23   Subtract 2m.  val_int   1   Divide by 2.  val_int  1   29   Add b  1  2  2m.  return   float    val_int   Interpret again as float   The three mathematical operations forming the core of the above function can be expressed in a single line. An additional adjustment can be added to reduce the maximum relative error. So, the three operations, not including the cast, can be rewritten as val_int   1   29    val_int   1  -  1   22   a  where a is a bias for adjusting the approximation errors. For example, with a  0 the results are accurate for even powers of 2 e.g., 1.0, but for other numbers the results will be slightly too big e.g.,1.5 for 2.0 instead of 1.414... with 6 error. With a  -0x4B0D2, the maximum relative error is minimized to 3.5. If the approximation is to be used for an initial guess for Newtons method to the equation  1  x 2   S  0 displaystyle 1x2-S0 , then the reciprocal form shown in the following section is preferred. Reciprocal of the square root  edit  Main article Fast inverse square root A variant of the above routine is included below, which can be used to compute the reciprocal of the square root, i.e., x  1 2 displaystyle x-1 over 2 instead, was written by Greg Walsh. The integer-shift approximation produced a relative error of less than 4, and the error dropped further to 0.15 with one iteration of Newtons method on the following line. 14  In computer graphics it is a very efficient way to normalize a vector. float invSqrt  float x   float xhalf  0.5f  x  union  float x  int i   u  u . x  x  u . i  0x5f375a86 -  u . i   1   The next line can be repeated any number of times to increase accuracy  u . x  u . x   1.5f - xhalf  u . x  u . x  return u . x   Some VLSI hardware implements inverse square root using a second degree polynomial estimation followed by a Goldschmidt iteration . 15  Negative or complex square  edit  If S     0, then its principal square root is S   S  i . displaystyle sqrt Ssqrt vert Svert ,,i,. If S     a  bi where a and b are real and b    0, then its principal square root is S   S   a 2  sgn   b   S   a 2 i . displaystyle sqrt Ssqrt frac vert Svert a2,,operatorname sgnbsqrt frac vert Svert -a2,,i,. This can be verified by squaring the root. 16  17  Here  S   a 2  b 2 displaystyle vert Svert sqrt a2b2 is the modulus of S . The principal square root of a complex number is defined to be the root with the non-negative real part. See also  edit  Alpha max plus beta min algorithm Integer square root Mental calculation n th root algorithm Recurrence relation Shifting nth-root algorithm Square root of 2 Notes  edit   Fowler, David Robson, Eleanor 1998. Square Root Approximations in Old Babylonian Mathematics YBC 7289 in Context. Historia Mathematica . 25 4 376. doi  10.1006hmat.1998.2209 . .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-formatfont-s ize95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Heath, Thomas 1921. A History of Greek Mathematics, Vol. 2 . Oxford Clarendon Press. pp.  323324.  Bailey, David Borwein, Jonathan 2012. Ancient Indian Square Roots An Exercise in Forensic Paleo-Mathematics PDF . American Mathematical Monthly . 119 8. pp.  646657 . Retrieved 2017-09-14 .  Fast integer square root by Mr. Woos abacus algorithm archived  Integer Square Root function  Sri Bharati Krisna Tirthaji 2008 1965. Vedic Mathematics or Sixteen Simple Mathematical Formulae from the Vedas . Motilal Banarsidass. ISBN   978-8120801639 .  M. V. Wilkes, D. J. Wheeler and S. Gill, The Preparation of Programs for an Electronic Digital Computer, Addison-Wesley, 1951.  M. Campbell-Kelly, Origin of Computing, Scientific American, September 2009.  J. C. Gower, A Note on an Iterative Method for Root Extraction, The Computer Journal 13142 143, 1958.  Markstein, Peter November 2004. Software Division and Square Root Using Goldschmidts Algorithms PDF . 6th Conference on Real Numbers and Computers . Dagstuhl , Germany. CiteSeerX   10.1.1.85.9648 .  Meher, Pramod Kumar Valls, Javier Juang, Tso-Bing Sridharan, K. Maharatna, Koushik 2008-08-22. 50 Years of CORDIC Algorithms, Architectures and Applications PDF . IEEE Transactions on Circuits  Systems-I Regular Papers published 2009-09-09. 56 9 18931907. doi  10.1109TCSI.2009.2025803 . Retrieved 2016-01-03 .  Beceanu, Marius. Period of the Continued Fraction of sqrtn PDF . Theorem 2.3. Archived from the original PDF on 21 December 2015 . Retrieved 21 December 2015 .  Gliga, Alexandra Ioana March 17, 2006. On continued fractions of the square root of prime numbers PDF . Corollary 3.3.  Fast Inverse Square Root by Chris Lomont  High-Speed Double-Precision Computation of Reciprocal, Division, Square Root and Inverse Square Root by Jos-Alejandro Pieiro and Javier Daz Bruguera 2002 abstract  Abramowitz, Miltonn Stegun, Irene A. 1964. Handbook of mathematical functions with formulas, graphs, and mathematical tables . Courier Dover Publications. p.  17. ISBN   978-0-486-61272-0 . , Section 3.7.26, p. 17  Cooke, Roger 2008. Classical algebra its nature, origins, and uses . John Wiley and Sons. p.  59. ISBN   978-0-470-25952-8 . , Extract page 59 External links  edit  Weisstein, Eric W. Square root algorithms . MathWorld . Square roots by subtraction Integer Square Root Algorithm by Andrija Radovi Personal Calculator Algorithms I   Square Roots William E. Egbert, Hewlett-Packard Journal may 1977   page 22 Calculator to learn the square root Retrieved from  httpsen.wikipedia.orgwindex.phptitleMethods_of_computing_square_roots oldid913826179  Categories  Root-finding algorithms Computer arithmetic algorithms Hidden categories Articles that may contain original research from January 2012 All articles that may contain original research Wikipedia articles that are too technical from September 2012 All articles that are too technical Articles needing expert attention from September 2012 All articles needing expert attention Articles needing additional references from July 2017 All articles needing additional references Articles that may be too long from June 2019 Articles with multiple maintenance issues All articles with unsourced statements Articles with unsourced statements from August 2019 Articles with unsourced statements from September 2017