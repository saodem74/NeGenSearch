Aspect-oriented software development From Wikipedia, the free encyclopedia Jump to navigation Jump to search This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources   Aspect-oriented software development     news    newspapers    books    scholar    JSTOR  June 2009   Learn how and when to remove this template message  In computing , aspect-oriented software development AOSD is a software development technology that seeks new modularizations of software systems in order to isolate secondary or supporting functions from the main programs business logic . AOSD allows multiple concerns to be expressed separately and automatically unified into working systems. Traditional software development focuses on decomposing systems into units of primary functionality, while recognizing that there are other issues of concern that do not fit well into the primary decomposition. The traditional development process leaves it to the programmers to code modules corresponding to the primary functionality and to make sure that all other issues of con cern are addressed in the code wherever appropriate. Programmers need to keep in mind all the things that need to be done, how to deal with each issue, the problems associated with the possible interactions, and the execution of the right behavior at the right time. These concerns span multiple primary functional units within the application, and often result in serious problem s faced during application development and maintenance. The distribution of the code for realizing a concern becomes especially critical as the requirements for that concern evolve  a system maintainer must find and correctly update a variety of situations. Aspect-oriented software development focuses on the identification, specification and representation of cross-cutting concerns and their modularization into separate functional units as well as their automated composition into a working system. Contents 1 History 2 Motivation 2.1 Crosscutting concerns 2.1.1 Example 1 Logging in Apache Tomcat 2.1.2 Example 2 Coordination of components 2.2 Examples of crosscutting concerns 2.3 Problems caused by scattering and tangling 2.3.1 System development 2.3.2 System maintenance and evolution 3 Overview 3.1 Nature of aspect-orientation 3.1.1 Quantification and obliviousness 3.2 Concepts and terminology 3.2.1 Join point model 3.2.2 Pointcut designators 3.2.3 Advice bodies 3.2.4 Inter-type declarations 3.2.5 Aspects 3.2.6 Aspect weaving 3.3 Example 3.4 Aspect-oriented requirement engineering 3.5 Aspect oriented business process management AOBPM 3.6 Aspect-oriented system architecture 3.7 Aspect-oriented modeling and design 3.8 Aspect-oriented programming AOP 3.9 Formal method support for aspect-orientation 3.10 Aspect-oriented middleware 4 Adoption 5 Footnotes 6 References 7 External links History  edit  Aspect-Oriented Software Development describes a number of approaches to software modularization and composition including, in order of publication, reflection and metaobject protocols , Composition Filters , 1  developed at the University of Twente in the Netherlands, Subject-Oriented Programming 2  later extended as Multidimensional Separation of Concerns  3  at IBM, Feature Oriented Programming 4  at University of Texas at Austin, Adaptive Programming 5  at Northeastern University , USA, and Aspect-Oriented Programming AOP 6  at Palo Alto Research Center . The term aspect-oriented was introduced by Gregor Kiczales and his team at Palo Alto Research Center who also first developed the explicit concept of AOP and the AOP language called AspectJ which has gained considerable acceptance and popularity within the Java developer community. Currently, several aspect-oriented programming languages are available for a variety of languages and platforms. Just as object-oriented programming led to the development of a large class of object-oriented development methodologies , AOP has encouraged a nascent set of software engineering technologies, including methodologies for dealing with aspects, modeling techniques often based on the ideas of the Unified Modeling Language , UML, and testing technology for assessing the effectiveness of aspect approaches. AOSD now refers to a wide range of software development techniques that support the modularization of cross-cutting concerns in a software system, from requirement engineering to business process management , analysis and design , architecture , programming and implementation techniques, testing and software maintenance techniques. Aspect-oriented software development has constantly gained in popularity, and is the subject of an annual conference, the International Conference on Aspect-Oriented Software Development, held for the first time in 2002 in Enschede, The Netherlands. AOSD is a rapidly evolving area. It is a popular topic of Software Engineering research, especially in Europe, where research activities on AOSD are coordinated by the European Network of Excellence on Aspect-Oriented Software Development AOSD-Europe, funded by the European Commission. Motivation  edit  Crosscutting concerns  edit  Figure 3  An UML architecture diagram for a telecom component The motivation for aspect-oriented programming approaches stem from the problems caused by code scattering and tangling. The purpose of Aspect-Oriented Software Development is to provide systematic means to modularize crosscutting concerns. The implementation of a concern is scattered if its code is spread out over multiple modules. The concern affects the implementation of multiple modules. Its implementation is not modular. The implementation of a concern is tangled if its code is intermixed with code that implements other concerns. The module in which tangling occurs is not cohesive. Scattering and tangling often go together, even though they are different concepts. Aspect-oriented software development considers that code scattering and tangling are the symptoms of crosscutting concerns. Crosscutting concerns cannot be modularized using the decomposition mechanisms of the language object or procedures because they inherently follow different decomposition rules. The implementation and integration of these concerns with the primary functional decomposition of the system causes code tangling and scattering. Example 1 Logging in Apache Tomcat  edit  Classloading in Tomcat is a modular concern with respect to the system decomposition. Its implementation is contained in a small number of classes and is not intertwined with the implementation of other concerns. Logging in Tomcat is a crosscutting concern. Its implementation spreads over many classes and packages and is intermixed with the implementation of many other concerns. Example 2 Coordination of components  edit  Figure 3 represents the UML architecture diagram of a telecom component. Each box corresponds to a process that communicates with other processes through connectors. Examples of crosscutting concerns  edit  See Cross-cutting concernExamples . Problems caused by scattering and tangling  edit  Scattering and tangling of behavior are the symptoms that the implementation of a concern is not well modularized. A concern that is not modularized does not exhibit a well-defined interface. The interactions between the implementation of the concern and the modules of the system are not explicitly declared. They are encoded implicitly through the dependencies and interactions between fragments of code that implement the concern and the implementation of other modules. The lack of interfaces between the implementation of crosscutting concerns and the implementation of the modules of the system impedes the development, the evolution and the maintenance of the system. System development  edit  A module is primarily a unit of independent development. It can be implemented to a large extent independently of other modules. Modularity is achieved through the definition of well-defined interfaces between segments of the system. 7  The lack of explicit interfaces between crosscutting concerns and the modules obtained through the functional decomposition of the system imply that the implementation of these concerns, as well as the responsibility with respect to the correct implementation of these concerns, cannot be assigned to independent development teams. This responsibility has to be shared among diffe rent developers that work on the implementation of different modules of the system and have to integrate the crosscutting concern with the module behavior. Furthermore, modules whose implementation is tangled with crosscutting concerns are hard to reuse in different contexts. Crosscutting impedes reuse of components. The lack of interfaces between crosscutting concerns and other modules makes it hard to represent and reason about the overall architecture of a system. As the concern is not modularized, the interactions between the concern and the top-level components of the system are hard to represent explicitly. Hence, these concerns become hard to reason about because the dependencies between crosscutting concerns and components are not specified. Finally, concerns that are not modularized are hard to test in isolation. The dependencies of the concern with respect to behavior of other modules are not declared explicitly. Hence, the implementation of unit test for such concerns requires knowledge about the implementation of many modules in the system. System maintenance and evolution  edit  The lack of support for the modular implementation of crosscutting concerns is especially problematic when the implementation of this concern needs to be modified. The comprehension of the implementation of a crosscutting concern requires the inspection of the implementation of all the modules with which it interacts. Hence, modifications of the system that affect the implemen tation of crosscutting concern require a manual inspection of all the locations in the code that are relevant to the crosscutting concern. The system maintainer must find and correctly update a variety of poorly identified situations. Overview  edit  Nature of aspect-orientation  edit  The focus of aspect-oriented software development is in the investigation and implementation of new structures for software modularity that provide support for explicit abstractions to modularize concerns. Aspect-oriented programming approaches provide explicit abstractions for the modular implementation of concerns in design, code, documentation, or other artifacts developed during the software life-cycle. These modularized concerns are called aspects , and aspect-oriented approaches provide methods to compose them. Some approaches denote a root concern as the base . Various approaches provide different flexibility with respect to composition of aspects. Quantification and obliviousness  edit  The best known definition of the nature of AOSD is due to Filman and Friedman, which characterized AOSD using the equation aspect orientation  quantification  obliviousness . 8  AOP can be understood as the desire to make quantified statements about the behavior of programs, and to have these quantifications hold over programs written by oblivious programmers. 8  AOP is the desire to make statements of the form In program P, whenever condition C arises, perform action A over a conventionally coded program P. 8  Obliviousness implies that a program has no knowledge of which aspects modify it where or when, whereas quantification refers to the ability of aspects to affect multiple points in the program. The notion of non-invasiveness is often preferred to the term obliviousness. Non-invasiveness expresses that aspects can add behavior to a program without having to perform changes in that program, yet it does not assume that programs are not aware of the aspects. Filmans definition of aspect-orientation is often considered too restrictive. 9  Many aspect-oriented approaches use annotations to explicitly declare the locations in the system where aspects introduce behavior. These approaches require the manual inspection and modification of other modules in the system and are therefore invasive. Furthermore, aspect-orientation does not necessarily require quantification. Aspects can be used to isolate features whose implementation would otherwise be tangled with ot her features. Such aspects do not necessarily use quantification over multiple locations in the system. The essential features of Aspect-Oriented Software Development are therefore better characterized in terms of the modularity of the implementation of crosscutting concerns, the abstractions provided by aspect-oriented languages to enable modularization and the expressiveness of the aspect-oriented composition operators . Concepts and terminology  edit  Aspect-oriented approaches provide explicit support for localizing concerns into separated modules, called aspects . An aspect is a module that encapsulates a concern. Most aspect-oriented languages support the non-invasive introduction of behavior into a code base and quantification over points in the program where this behavior should be introduced. These points are called join points . Join point model  edit  Join points are points in the execution of the system, such as method calls, where behavior supplied by aspects is combined. A join point is a point in the execution of the program, which is used to define the dynamic structure of a crosscutting concern. The join point model of an aspect-oriented language defines the types of join points that are supported by the aspect-oriented language and the possible interaction points between aspects and base modules. The dynamic interpretation of join points makes it possible to expose runtime information such as the caller or callee of a method from a join point to a matching pointcut . Nowadays, there are various join point models around and still more under development. They heavily depend on the underlying programming language and AO language. Examples of join points are method execution method call field read and write access exception handler execution static and dynamic initialization A method call join point covers the actions of an object receiving a method call. It includes all the actions that compose a method call, starting after all arguments are evaluated up to return. Many AOP approaches implement aspect behavior by weaving hooks into join point shadows , which is the static projection of a join point onto the program code. Figure 6 illustrates possible join points in the execution of a small object-oriented program. The highlighted join points include the execution of method moveByint, int on a Line object, the calls to methods moveByint, int on the Point objects in the context of the Line object, the execution of these methods in the context of the Point objects and the calls and execution of the setXint and setYint methods. Pointcut designators  edit  The quantification over join points is expressed at the language level . This quantification may be implicit in the language structure or may be expressed using a query-like construct called a pointcut. Pointcuts are defined as a predicate over the syntax-tree of the program, and define an interface that constrains which elements of the base program are exposed by the pointcut. A pointcut picks out certain join points and values at those points. The syntactic formulation of a pointcut varies from approach to approach, but a pointcut can often be composed out of other pointcuts using the boolean operators AND, OR and NOT. Pointcut expressions can concisely capture a wide range of events of interests, using wildcards. For example, in AspectJ syntax, the move pointcut pointcut move  call  public  Figure . .. picks out each call to Figures public methods. cflow poincuts identify join points based on whether they occur in the dynamic context of other join points. For example, in AspectJ syntax cflowmove picks out each join point that occurs in the dynamic context of the join points picked out by the move pointcut. Pointcuts can be classified in two categories Kinded pointcuts, such as the call pointcut, match one kind of join point using a signature. Non-kinded pointcuts, such as the cflow pointcut match all kinds of join points using a variety of properties. Advice bodies  edit  An advice body is code that is executed when a join point is reached. Advice modularizes the functional details of a concern. The order in which the advice bodies contributed by aspects and by the base may be controlled in a variety of ways, including as a join point is reached, before the execution proceeds with the base after the base semantics for the join point. When the join point corresponds to the execution of a method, an after advice can be executed after the method returned or after raising an exception as the join point is reached, with explicit control over whether the base semantics is executed. Around advice can modify the control flow of the program. More general ways to describe the ordering of advice bodies in terms of partial-order graphs have also been provided. 10  When the execution of a join point satisfies a pointcut expression, the base and advice code associated with the join point are executed. The advice may interact with the rest system through a join point instance containing reflective information on the context of the event that triggered the advice, such as the arguments of a method call or the target instance of a call. Inter-type declarations  edit  Inter-type declarations allow the programmer to modify a programs static structure, such as class members and classes hierarchy. New members can be inserted and classes can be pushed down the class hierarchy. Aspects  edit  An aspect is a module that encapsulates a concern. An aspect is composed of pointcuts, advice bodies and inter-type declarations. In some approaches, an aspect may also contain classes and methods. Aspect weaving  edit  Main article Aspect weaver Aspect weaving is a composition mechanism that coordinates aspects with the other modules of the system. It is performed by a specialized compiler, called an aspect weaver . Example  edit  Figure 6  Figure Editor in UML Figure 7  Aspect-Oriented Figure Editor in UML Figure 6 illustrates a classic example of a crosscutting concern in a figure editor example taken from the AOSD literature  citation needed  . The example describes an abstract Shape class that can be moved in the editor. Whenever a shape is moved, the display needs to be refreshed. Figure 6 also depicts two Shape subclasses, Line and Point that implement the Shape functionality. The display refresh concern is scattered across the implementation of both subclasses. Figure 7 represents an aspect-oriented implementat ion of the same system, where an aspect encapsulates the display updating functionality. The move pointcut descriptor of Figure 7  citation needed  captures all the executions of the moveBy methods of a subclass of Shape and invokes the display refresh functionality after the execution proceeds. The concern is modularized, which makes it easier to evolve and maintain. Aspect-oriented requirement engineering  edit  Aspect-oriented requirement engineering also referred to as Early Aspects focuses on the identification, specification and representation of crosscutting properties at the requirement level. Examples of such properties include security , mobility, availability and real-time constraints. Crosscutting properties are requirements, use cases or features that have a broadly scoped effect on other requirements or architecture components. Aspect-oriented requirements engineering approaches are techniques that explicitly recognise the importance of clearly addressing both functional and non-functional crosscutting concerns in addition to non-crosscutting ones. Therefore, these approaches focus on systematically and modularly treating, reasoning about, composing and subsequently tracing crosscutting functional and non-functional concerns via suitable abstraction , representation and composition mechanisms tailored to the requirements engineering domain. Specific areas of excellence under the denominator of AO Requirements Analysis are the aspect-oriented requirements process itself, the aspect-oriented requirements notations, aspect-oriented requirements tool support, adoption and integration of aspect-oriented requirements engineering, and assessmentevaluation of aspect-oriented requirements. Aspect oriented business process management AOBPM  edit  Reducing complexity is an important issue in Business Process Management BPM area. One source of complexity is rooted in the variety of concerns that a business process addresses, such as security and privacy. Ideally, these concerns should be defined separately from the business processes, as they typically span several processes, and they can be subject for change on a gene ral organisational level instead of specific process level. However, current Business Process Management Systems do not support this kind of modelling. Aspect oriented business process management AOBPM tries to support separation of cross-cutting concerns from the core business concerns. It defines a set of requirements and a formal model. This model is designed using Coloured Petri Nets CPN. The approach is implemented as a service in YAWL based on Service Oriented Architecture . The assessment result of current aspect oriented business process management approaches are defined based on five dimensions such as Signature Exposure, Rule Composition, Advice Relations, Transformation Patterns, and Phases Support. The result can be seen in the following figure. Aspect-oriented system architecture  edit  Aspect-oriented system architecture focuses on the localization and specification of crosscutting concerns in architectural designs. Crosscutting concerns that appear at the architectural level cannot be modularized by redefining the software architecture using conventional architectural abstractions. Aspect-oriented system architecture languages propose explicit mechanisms to identify, specify and evaluate aspects at the architecture design level. Aspect-oriented architecture starts from the observation that we need to identify, specify and evaluate aspects explicitly at the architecture design level. Aspectual architecture approaches describe steps for identifying architectural aspects. This information is used to redesign a given architecture in which the architectural aspects are made explicit. In this regard, specifi c areas of excellence are the aspect-oriented architecture process itself, the aspect-oriented architecture notations, aspect-oriented architecture tool support, adoption and integration of aspect-oriented architecture, and assessmentevaluation of aspect-oriented architecture. Aspect-oriented modeling and design  edit  Aspect-oriented design has the same objectives as any software design activity, i.e. characterising and specifying the behavior and structure of the software system. Its unique contribution to software design lies in the fact that concerns that are necessarily scattered and tangled in more traditional approaches can be modularized. Typically, such an approach includes both a pr ocess and a language. The process takes as input requirements and produces a design model. The produced design model represents separate concerns and their relationships. The language provides constructs that can describe the elements to be represented in the design and the relationships that can exist between those elements. In particular, constructs are provided to support co ncern modularization and the specification of concern composition, with consideration for conflicts. Beyond that, the design of each individual modularized concern compares to standard software design. Here, specific areas of excellence areas are the aspect-oriented design process itself, the aspect-oriented design notations, aspect-oriented design tool support, adoption and integration of aspect-oriented design, and assessmentevaluation of aspect-oriented design. Aspect-oriented programming AOP  edit  Main article Aspect-oriented programming AOP includes programming techniques and tools that support the modularization of concerns at the level of the source code. Just like any other programming language, an aspect-oriented language typically consists of two parts a language specification and an implementation. Hence, there are two corresponding areas of concern support for language developers and support for application developers. Support for application developers An aspect-oriented approach supports the implementation of concerns and how to compose those independently implemented concerns. While the specification of such a language is the primary manual for application developers, it provides obviously no guarantee that the application developer will produce high-quality aspect-oriented programs. Specific areas of excellence the crucial concepts of aspect-oriented programming, programming in aspect-oriented languages, composing software components written in any language using aspect-oriented composition mechanisms, or aspect-oriented programming environments. Support for language developers Excellence in constructing aspect-oriented languages includes the following areas constructing languages or DSLs for specific domains andor platforms, and transferring implementation principles from other aspect-oriented execution environments, including interpreters, compilers, and virtual machines. Formal method support for aspect-orientation  edit  Formal methods can be used both to define aspects semantically and to analyze and verify aspect-oriented systems. Aspect-oriented programming extends programming notations with aspect modules that isolate the declaration of when the aspect should be applied join points and what actions should be taken when it is reached advice. Expertise in formal semantic definitions of aspect construct s is useful for language designers to provide a deep understanding of the differences among constructs. Aspects potentially can harm the reliability of a system to which they are woven, and could invalidate essential properties that already were true of the system without the aspect. It is also necessary to show that they actually do add intended crosscutting properties to the system. Hence, numerous questions of correctness and verification are raised by aspect languages. Among the kinds of expertise are specially designed testing techniques to provide coverage for aspects, program slicing and code analysis approaches to identify interactions among aspects and between aspects and underlying systems, model checking techniques specialized for aspects, and inductive techniques to verify aspect-oriented systems. Each of the above approaches can be used to specify and analyze individual aspects relative to an existing system, define conditions for composing multiple aspects correctly, and detect and resolve potential interferences among aspects. Although some approaches are already used in aspect languages, others are still subject of research and are not ready for routine industrial application. Nevertheless, awareness of these issues is essential for language designers, and for effective use of aspects, especially in safety-critical contexts. Aspect-oriented middleware  edit  Middleware and AOSD strongly complement each other. In general, areas of excellence consist of support for the application developer, which includes the crucial concepts of aspect supporting middleware, aspect-oriented software development using a specific middleware, involving the aspect programming model, aspect deployment model, platform infrastructure, and services of the middleware, and Product Family Engineering methods, architectures, techniques in distributed and ambient computing, and support for the middleware developer with respect to host-infrastructure middleware, distribution middleware, common middleware services, and domain-specific middleware services. Adoption  edit  IBM WebSphere Application Server WAS is a java application server that supports Java EE and Web Services. Websphere is distributed according to editions that support different features. Websphere uses AspectJ internally to isolate features of the different editions. JBoss Application Server JBoss AS is a free, open-source java application server that supports Java EE. The core of JBoss AS is integrated with the JBoss AOP aspect-oriented programming language. 11  The application server uses JBoss AOP to deploy services such as security and transaction management. Oracle TopLink is a Java object-to-relational persistence framework that is integrated with the Spring Application Server. TopLink achieves high levels of persistence transparency using Spring AOP. SAP Sun Microsystems uses AspectJ to streamline mobile application development for the Java ME platform. Aspects are used to simplify the development of mobile applications for deployment to different operator decks and different mobile gaming community interfaces. Siemens Soarian is a health information management system that supports seamless access to patient medical records and the definition of workflows for health provider organizations. Soarian uses AspectJ to integrate crosscutting features such as tracing, auditing and performance monitoring in the context of an agile development process. Motorola wi4 is a cellular infrastructure system that provides support for the WiMAX wireless broadband standard. The wi4 control software is developed using an aspect-oriented extension to the UML 2.0 standard called WEAVR. WEAVR is used during the development for debugging and testing purposes. ASML is a provider of lithography systems for the semiconductor industry. ASML uses an aspect-oriented extension to C called Mirjam to modularize tracing and profiling concerns. Glassbox is a troubleshooting agent for Java applications that automatically diagnoses common problems. The Glassbox inspector monitors the activity of the Java virtual machine using AspectJ. .NET 3.5 supports Aspect Oriented concepts through the Unity container. Footnotes  edit   Bosch, J. M. Aksit 1992. Composition-Filters Based Real-Time Programming . Vancouver An Evaluation of Object-Oriented Technology in Real-Time Systems Past, Present  Future ACM OOPSLA92 Workshop. .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-positionright .1em ce nter.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-outpu t .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Harrison, William Harold Ossher September 1993. Subject-Oriented Programming - A Critique of Pure Objects. Proceedings of 1993 Conference on Object-Oriented Programming Systems, Languages, and Applications .  Ossher, Harold Peri Tarr William Harrison Stanley Sutton May 1999. N-Degrees of Separation Multi-Dimension Separation of Concerns. Proceedings of 1999 International Conference on Software Engineering . doi  10.1145302405.302457 .  Batory, Don S. V. Singhal J. Thomas S. Dasari B. Geraci M. Sirkin September 1994. The GenVoca Model of Software-System Generators. IEEE Software . 11 5 8994. doi  10.110952.311067 .  Lieberherr, K. 1996. Adaptive Object-Oriented Software The Demeter Method with Propagation Patterns . PWS Publishing Company.  Kiczales, Gregor John Lamping Anurag Mendhekar Chris Maeda Cristina Lopes Jean-Marc Loingtier John Irwin 1997. Aspect-Oriented Programming. Proceedings of the European Conference on Object-Oriented Programming . 1241  220242.  Parnas, D.L. 1972 On the Criteria To Be Used in Decomposing Systems into Modules, in Communications of the ACM, December 1972, Vol. 15, No. 12, 1053-1058  a b c Filman, R. and D. Friedman. Aspect-oriented programming is quantification and Obliviousness. Proceedings of the Workshop on Advanced Separation of Concerns, in conjunction with OOPSLA00 2000  Rashid, A and A. Moreira. Domain Models are NOT Aspect Free. Proceedings of the 9th International Conference on Model-Driven Engineering Languages and Systems Models06. Genoa, Italy. LNCS 4199. Springer-Verlag 2006 155-169.  William Harrison, Harold Ossher, Peri Tarr. General Composition of Software Artifacts, Proceedings of Software Composition Workshop 2006, March 2006, Springer-Verlag, LNCS 4089, pages 194-210  Chapter 8. JBoss AOP . Red Hat . 2010. References  edit  Kiczales, G.  Lamping, J. Mendhekar, A. Maeda, C. Lopes, C. Loingtier, J. M. Irwin, J. 1997. Aspect-oriented programming PDF . ECOOP 97. Proceedings of the 11th European Conference on Object-Oriented Programming . LNCS . 1241 . pp.  220242. CiteSeerX   10.1.1.115.8660 . doi  10.1007BFb0053381 . ISBN   3-540-63089-9 . Murphy, G.C., R.J. Walker, E.L.A. Baniassad, M.P. Robillard, A. Lai, M.A. Kersten 2001 Does Aspect-Oriented Programming Work, in Communications of the ACM, October 2001, Vol. 44, No. 10, 75-77 Tarr, P., H. Ossher, W. Harrison, S.M. Sutton Jr. 1999 N Degrees of Separation Multi- Dimensional Separation of Concerns, in Proceedings of the 21st International Conference on Software Engineering ICSE 1999, Los Angeles, California, USA, IEEE Computer Society Press, 107-119 External links  edit  Aspect-Oriented Software Development Community and Conference European Network of Excellence on Aspect-Oriented Software Development Early Aspects Aspect-Oriented Requirements Engineering and Architecture Design The Aspect-Oriented Software Architecture Design Portal Aspect-Oriented Software Engineering at Lancaster Early Aspects for Business Process Modeling An Aspect-Oriented Language for BPMN Composition Filters Model Demeter and Adaptive Programming IBM subject-oriented programming Aspect-Oriented Software Development Course, Bedir Tekinerdogan, Bilkent University Aspect Oriented Business Process Management v t e Aspect-oriented software development Concepts Advice Aspect Aspect-oriented programming Aspect weaver Cross-cutting concerns Join point Pointcut Languages AspectC AspectJ AspectWerkz v t e Software engineering Fields Computer programming Requirements engineering Software deployment Software design Software maintenance Software testing Systems analysis Formal methods Concepts Data modeling Enterprise architecture Functional specification Modeling language Orthogonality Programming paradigm Software Software archaeology Software architecture Software configuration management Software development methodology Software development process Software quality Software quality assurance Software verification and validation Structured analysis Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Scrum Spiral model V-Model Waterfall model XP Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML USL SysML Software engineers Victor Basili Kent Beck Grady Booch Fred Brooks Barry Boehm Peter Chen Danese Cooper Ward Cunningham Tom DeMarco Edsger W. Dijkstra Delores M. Etter Martin Fowler Adele Goldstine Margaret Hamilton C. A. R. Hoare Lois Haibt Mary Jean Harrold Grace Hopper Watts Humphrey Michael A. Jackson Ivar Jacobson Alan Kay Nancy Leveson Stephen J. Mellor Bertrand Meyer David Parnas Trygve Reenskaug Winston W. Royce James Rumbaugh Mary Shaw Peri Tarr Elaine Weyuker Niklaus Wirth Edward Yourdon Related fields Computer science Computer engineering Project management Risk management Systems engineering Category Commons Retrieved from  httpsen.wikipedia.orgwindex.phptitleAspect-oriented_software_development oldid909074330  Categories  Aspect-oriented software development Hidden categories Use dmy dates from July 2013 Articles needing additional references from June 2009 All articles needing additional references All articles with unsourced statements Articles with unsourced statements from January 2012