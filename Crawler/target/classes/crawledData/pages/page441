Von Neumann architecture From Wikipedia, the free encyclopedia Jump to navigation Jump to search computer architecture where code and data share a common bus See also Stored-program computer and Universal Turing machine   Stored-program computer Von Neumann architecture scheme The von Neumann architecture also known as the von Neumann model or Princeton architecture is a computer architecture based on a 1945 description by the mathematician and physicist John von Neumann and others in the First Draft of a Report on the EDVAC . 1  That document describes a design architecture for an electronic digital computer with these components A processing unit that contains an arithmetic logic unit and processor registers A control unit that contains an instruction register and program counter Memory that stores data and instructions External mass storage Input and output mechanisms 1  2  The term von Neumann architecture has evolved to mean any stored-program computer in which an instruction fetch and a data operation cannot occur at the same time because they share a common bus . This is referred to as the von Neumann bottleneck and often limits the performance of the system. 3  The design of a von Neumann architecture machine is simpler than a Harvard architecture machinewhich is also a stored-program system but has one dedicated set of address and data buses for reading and writing to memory, and another set of address and data buses to fetch instructions . A stored-program digital computer keeps both program instructions and data in read-write , random-access memory RAM. Stored-program computers were an advancement over the program-controlled computers of the 1940s, such as the Colossus and the ENIAC . Those were programmed by setting switches and inserting patch cables to route data and control signals between various functional units. The vast majority of modern computers use the same memory for both data and program instructions. The von Neumann vs. Harvard distinction applies to the cache architecture, not the main memory  split cache architecture . Contents 1 History 2 Capabilities 3 Development of the stored-program concept 4 Early von Neumann-architecture computers 5 Early stored-program computers 6 Evolution 7 Design limitations 7.1 Von Neumann bottleneck 7.1.1 Mitigations 7.2 Self-modifying code 8 See also 9 References 10 Further reading 11 External links History  edit  The earliest computing machines had fixed programs. Some very simple computers still use this design, either for simplicity or training purposes. For example, a desk calculator in principle is a fixed program computer. It can do basic mathematics , but it cannot run a word processor or games. Changing the program of a fixed-program machine requires rewiring, restructuring, or redesigning the machine. The earliest computers were not so much programmed as designed for a particular task. Reprogrammingwhen possible at allwas a laborious process that started with flowcharts and paper notes, followed by detailed engineering designs, and then the often-arduous process of physically rewiring and rebuilding the machine. It could take three weeks to set up and debug a program on ENIAC . 4  With the proposal of the stored-program computer, this changed. A stored-program computer includes, by design, an instruction set , and can store in memory a set of instructions a program  that details the computation . A stored-program design also allows for self-modifying code . One early motivation for such a facility was the need for a program to increment or otherwise modify the address portion of instructions, which operators had to do manually in early designs. This became less important when index registers and indirect addressing became usual features of machine architecture. Another use was to embed frequently used data in the instruction stream using immediate addressing . Self-modifying code has largely fallen out of favor, since it is usually hard to understand and debug , as well as being inefficient under modern processor pipelining and caching schemes. Capabilities  edit  On a large scale, the ability to treat instructions as data is what makes assemblers , compilers , linkers , loaders , and other automated programming tools possible. It makes programs that write programs possible. 5  This has made a sophisticated self-hosting computing ecosystem flourish around von Neumann architecture machines. Some high level languages leverage the von Neumann architecture by providing an abstract, machine-independent way to manipulate executable code at runtime e.g., LISP , or by using runtime information to tune just-in-time compilation e.g. languages hosted on the Java virtual machine , or languages embedded in web browsers . On a smaller scale, some repetitive operations such as BITBLT or pixel and vertex shaders can be accelerated on general purpose processors with just-in-time compilation techniques. This is one use of self-modifying code that has remained popular. Development of the stored-program concept  edit  The mathematician Alan Turing , who had been alerted to a problem of mathematical logic by the lectures of Max Newman at the University of Cambridge , wrote a paper in 1936 entitled On Computable Numbers, with an Application to the Entscheidungsproblem , which was published in the Proceedings of the London Mathematical Society . 6  In it he described a hypothetical machine he called a universal computing machine, now known as the  Universal Turing machine . The hypothetical machine had an infinite store memory in todays terminology that contained both instructions and data. John von Neumann became acquainted with Turing while he was a visiting professor at Cambridge in 1935, and also during Turings PhD year at the Institute for Advanced Study in Princeton, New Jersey during 1936  1937. Whether he knew of Turings paper of 1936 at that time is not clear. In 1936, Konrad Zuse also anticipated in two patent applications that machine instructions could be stored in the same storage used for data. 7  Independently, J. Presper Eckert and John Mauchly , who were developing the ENIAC at the Moore School of Electrical Engineering , at the University of Pennsylvania , wrote about the stored-program concept in December 1943. 8  9  In planning a new machine, EDVAC , Eckert wrote in January 1944 that they would store data and programs in a new addressable memory device, a mercury metal delay line memory . This was the first time the construction of a practical stored-program machine was proposed. At that time, he and Mauchly were not aware of Turings work. Von Neumann was involved in the Manhattan Project at the Los Alamos National Laboratory , which required huge amounts of calculation. This drew him to the ENIAC project, during the summer of 1944. There he joined the ongoing discussions on the design of this stored-program computer, the EDVAC. As part of that group, he wrote up a description titled First Draft of a Report on the EDVAC 1  based on the work of Eckert and Mauchly. It was unfinished when his colleague Herman Goldstine circulated it with only von Neumanns name on it, to the consternation of Eckert and Mauchly. 10  The paper was read by dozens of von Neumanns colleagues in America and Europe, and influenced the next round of computer designs. Jack Copeland considers that it is historically inappropriate, to refer to electronic stored-program digital computers as von Neumann machines. 11  His Los Alamos colleague Stan Frankel said of von Neumanns regard for Turings ideas .mw-parser-output .templatequoteoverflowhiddenmargin1em 0padding0 40px.mw-parser-output .templatequote .templatequoteciteline-height1.5emtext-alignleftpadding-left1.6emmargin-top0 I know that in or about 1943 or 44 von Neumann was well aware of the fundamental importance of Turings paper of 1936 Von Neumann introduced me to that paper and at his urging I studied it with care. Many people have acclaimed von Neumann as the father of the computer in a modern sense of the term but I am sure that he would never have made that mistake himself. He might well be called the midwife, perhaps, but he firmly emphasized to me, and to others I am sure, that the fundamental conception is owing to Turing in so far as not anticipated by Babbage Both Turing and von Neumann, of course, also made substantial contributions to the reduction to practice of these concepts but I would not regard these as comparable in importance with the in troduction and explication of the concept of a computer able to store in its memory its program of activities and of modifying that program in the course of these activities. 12  At the time that the First Draft report was circulated, Turing was producing a report entitled Proposed Electronic Calculator . It described in engineering and programming detail, his idea of a machine he called the Automatic Computing Engine ACE . 13  He presented this to the Executive Committee of the British National Physical Laboratory on February 19, 1946. Although Turing knew from his wartime experience at Bletchley Park that what he proposed was feasible, the secrecy surrounding Colossus , that was subsequently maintained for several decades, prevented him from saying so. Various successful implementations of the ACE design were produced. Both von Neumanns and Turings papers described stored-program computers, but von Neumanns earlier paper achieved greater circulation and the computer architecture it outlined became known as the von Neumann architecture. In the 1953 publication Faster than Thought A Symposium on Digital Computing Machines edited by B. V. Bowden, a section in the chapter on Computers in America reads as follows 14  The Machine of the Institute For Advanced Studies, Princeton In 1945, Professor J. von Neumann, who was then working at the Moore School of Engineering in Philadelphia, where the E.N.I.A.C. had been built, issued on behalf of a group of his co-workers, a report on the logical design of digital computers. The report contained a detailed proposal for the design of the machine that has since become known as the E.D.V.A.C. electronic discre te variable automatic computer. This machine has only recently been completed in America, but the von Neumann report inspired the construction of the E.D.S.A.C. electronic delay-storage automatic calculator in Cambridge see page 130. In 1947, Burks, Goldstine and von Neumann published another report that outlined the design of another type of machine a parallel machine this time that would be exceedingly fast, capable perhaps of 20,000 operations per second. They pointed out that the outstanding problem in constructing such a machine was the development of suitable memory with instantaneously accessible c ontents. At first they suggested using a special vacuum tube called the  Selectron which the Princeton Laboratories of RCA had invented. These tubes were expensive and difficult to make, so von Neumann subsequently decided to build a machine based on the Williams memory . This machinecompleted in June, 1952 in Princetonhas become popularly known as the Maniac. The design of this machine inspired at least half a dozen machines now being built in America, all known affectionately as Johniacs. In the same book, the first two paragraphs of a chapter on ACE read as follows 15  Automatic Computation at the National Physical Laboratory One of the most modern digital computers which embodies developments and improvements in the technique of automatic electronic computing was recently demonstrated at the National Physical Laboratory, Teddington, where it has been designed and built by a small team of mathematicians and electronics research engineers on the staff of the Laboratory, assisted by a number of produc tion engineers from the English Electric Company, Limited. The equipment so far erected at the Laboratory is only the pilot model of a much larger installation which will be known as the Automatic Computing Engine, but although comparatively small in bulk and containing only about 800 thermionic valves, as can be judged from Plates XII, XIII and XIV, it is an extremely rapid an d versatile calculating machine. The basic concepts and abstract principles of computation by a machine were formulated by Dr. A. M. Turing, F.R.S., in a paper 1 . read before the London Mathematical Society in 1936, but work on such machines in Britain was delayed by the war. In 1945, however, an examination of the problems was made at the National Physical Laboratory by Mr. J. R. Womersley, then superintendent of the Mathematics Division of the Laboratory. He was joined by Dr. Turing and a small staff of specialists, and, by 1947, the preliminary planning was sufficiently advanced to warrant the establishment of the special group already mentioned. In April, 1948, the latter became the Electronics Section of the Laboratory, under the charge of Mr. F. M. Colebrook. Early von Neumann-architecture computers  edit  The First Draft described a design that was used by many universities and corporations to construct their computers. 16  Among these various computers, only ILLIAC and ORDVAC had compatible instruction sets. ARC2  Birkbeck, University of London  officially came online on May 12, 1948. 17  Manchester Baby Victoria University of Manchester, England made its first successful run of a stored program on June 21, 1948. EDSAC University of Cambridge, England was the first practical stored-program electronic computer May 1949 Manchester Mark 1 University of Manchester, England Developed from the Baby June 1949 CSIRAC  Council for Scientific and Industrial Research  Australia November 1949 EDVAC  Ballistic Research Laboratory , Computing Laboratory at Aberdeen Proving Ground 1951 ORDVAC U-Illinois at Aberdeen Proving Ground, Maryland completed November 1951 18  IAS machine at Princeton University January 1952 MANIAC I at Los Alamos Scientific Laboratory March 1952 ILLIAC at the University of Illinois, September 1952 BESM-1 in Moscow 1952 AVIDAC at Argonne National Laboratory 1953 ORACLE at Oak Ridge National Laboratory June 1953 BESK in Stockholm 1953 JOHNNIAC at RAND Corporation January 1954 DASK in Denmark 1955 WEIZAC at the Weizmann Institute of Science in Rehovot , Israel 1955 PERM in Munich 1956 SILLIAC in Sydney 1956 Early stored-program computers  edit  The date information in the following chronology is difficult to put into proper order. Some dates are for first running a test program, some dates are the first time the computer was demonstrated or completed, and some dates are for the first delivery or installation. The IBM SSEC had the ability to treat instructions as data, and was publicly demonstrated on January 27, 1948. This ability was claimed in a US patent. 19  20  However it was partially electromechanical, not fully electronic. In practice, instructions were read from paper tape due to its limited memory. 21  The ARC2 developed by Andrew Booth and Kathleen Booth at Birkbeck, University of London officially came online on May 12, 1948. 17  It featured the first rotating drum storage device . 22  23  The Manchester Baby was the first fully electronic computer to run a stored program. It ran a factoring program for 52 minutes on June 21, 1948, after running a simple division program and a program to show that two numbers were relatively prime . The ENIAC was modified to run as a primitive read-only stored-program computer using the Function Tables for program ROM  and was demonstrated as such on September 16, 1948, running a program by Adele Goldstine for von Neumann. The BINAC ran some test programs in February, March, and April 1949, although was not completed until September 1949. The Manchester Mark 1 developed from the Baby project. An intermediate version of the Mark 1 was available to run programs in April 1949, but was not completed until October 1949. The EDSAC ran its first program on May 6, 1949. The EDVAC was delivered in August 1949, but it had problems that kept it from being put into regular operation until 1951. The CSIR Mk I ran its first program in November 1949. The SEAC was demonstrated in April 1950. The Pilot ACE ran its first program on May 10, 1950 and was demonstrated in December 1950. The SWAC was completed in July 1950. The Whirlwind was completed in December 1950 and was in actual use in April 1951. The first ERA Atlas later the commercial ERA 1101UNIVAC 1101 was installed in December 1950. Evolution  edit  Single system bus evolution of the architecture Through the decades of the 1960s and 1970s computers generally became both smaller and faster, which led to evolutions in their architecture. For example, memory-mapped IO lets input and output devices be treated the same as memory. 24  A single system bus could be used to provide a modular system with lower cost  clarification needed  . This is sometimes called a streamlining of the architecture. 25  In subsequent decades, simple microcontrollers would sometimes omit features of the model to lower cost and size. Larger computers added features for higher performance. Design limitations  edit  Von Neumann bottleneck  edit  The shared bus between the program memory and data memory leads to the von Neumann bottleneck , the limited throughput data transfer rate between the central processing unit CPU and memory compared to the amount of memory. Because the single bus can only access one of the two classes of memory at a time, throughput is lower than the rate at which the CPU can work. This seriously limits the effective processing speed when the CPU is required to perform minimal processing on large amounts of data. The CPU is continually forced to wait for needed data to move to or from memory. Since CPU speed and memory size have increased much faster than the throughput between them, the bottleneck has become more of a problem, a problem whose severity increases with every new generation of CPU. The von Neumann bottleneck was described by John Backus in his 1977 ACM Turing Award lecture. According to Backus Surely there must be a less primitive way of making big changes in the store than by pushing vast numbers of words back and forth through the von Neumann bottleneck. Not only is this tube a literal bottleneck for the data traffic of a problem, but, more importantly, it is an intellectual bottleneck that has kept us tied to word-at-a-time thinking instead of encouraging us to think in terms of the larger conceptual units of the task at hand. Thus programming is basically planning and detail ing the enormous traffic of words through the von Neumann bottleneck, and much of that traffic concerns not significant data itself, but where to find it. 26  27  Mitigations  edit  There are several known methods for mitigating the Von Neumann performance bottleneck. For example, the following all can improve performance  why   Providing a cache between the CPU and the main memory providing separate caches or separate access paths for data and instructions the so-called Modified Harvard architecture  using branch predictor algorithms and logic providing a limited CPU stack or other on-chip scratchpad memory to reduce memory access Implementing the CPU and the memory hierarchy as a system on chip , providing greater locality of reference and thus reducing latency and increasing throughput between processor registers and main memory The problem can also be sidestepped somewhat by using parallel computing , using for example the non-uniform memory access NUMA architecturethis approach is commonly employed by supercomputers. It is less clear whether the intellectual bottleneck that Backus criticized has changed much since 1977. Backuss proposed solution has not had a major influence.  citation needed  Modern functional programming and object-oriented programming are much less geared towards pushing vast numbers of words back and forth than earlier languages like FORTRAN were, but internally, that is still what computers spend much of their time doing, even highly parallel supercomputers. As of 1996, a database benchmark study found that three out of four CPU cycles were spent waiting for memory. Researchers expect that increasing the number of simultaneous instruction streams with multithreading or single-chip multiprocessing will make this bottleneck even worse. 28  In the context of multi-core processors , additional overhead is required to maintain cache coherence between processors and threads. Self-modifying code  edit  Aside from the von Neumann bottleneck, program modifications can be quite harmful, either by accident or design. In some simple stored-program computer designs, a malfunctioning program can damage itself, other programs, or the operating system , possibly leading to a computer crash . Memory protection and other forms of access control can usually protect against both accidental and malicious program modification. See also  edit  Computer science portal CARDboard Illustrative Aid to Computation Interconnect bottleneck Little man computer Random-access machine Turing machine Neuromorphic engineering Eckert architecture References  edit   a b c von Neumann, John 1945, First Draft of a Report on the EDVAC PDF , archived from the original PDF on March 14, 2013 , retrieved August 24, 2011 .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation . cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-po sitionright .1em center.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno -repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-o utput .cs1-registration,.mw-parser-output .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  Ganesan 2009  Markgraf, Joey D. 2007, The Von Neumann Bottleneck , archived from the original on December 12, 2013 Cite uses deprecated parameter deadurl  help   Copeland 2006 , p.  104  MFTL My Favorite Toy Language entry Jargon File 4.4.7 , retrieved July 11, 2008  Turing, Alan M. 1936, On Computable Numbers, with an Application to the Entscheidungsproblem, Proceedings of the London Mathematical Society , 2 published 1937, 42 , pp.  230265, doi  10.1112plmss2-42.1.230 and Turing, Alan M. 1938, On Computable Numbers, with an Application to the Entscheidungsproblem. A correction, Proceedings of the London Mathematical Society , 2 published 1937, 43 6, pp.  544546, doi  10.1112plmss2-43.6.544   Electronic Digital Computers , Nature , 162  487, September 25, 1948, doi  10.1038162487a0 , archived from the original on April 6, 2009 , retrieved April 10, 2009 Cite uses deprecated parameter deadurl  help   Lukoff, Herman 1979. From Dits to Bits A personal history of the electronic computer . Portland, Oregon, USA Robotics Press. ISBN   0-89661-002-0 . LCCN   79-90567 .  ENIAC project administrator Grist Brainerds December 1943 progress report for the first period of the ENIACs development implicitly proposed the stored program concept while simultaneously rejecting its implementation in the ENIAC by stating that in order to have the simplest project and not to complicate matters, the ENIAC would be constructed without any automatic regulation..  Copeland 2006 , p.  113  Copeland, Jack 2000, A Brief History of Computing ENIAC and EDVAC , retrieved January 27, 2010  Copeland, Jack 2000, A Brief History of Computing ENIAC and EDVAC , retrieved January 27, 2010 which cites Randell, Brian 1972, Meltzer, B. Michie, D. eds., On Alan Turing and the Origins of Digital Computers, Machine Intelligence , Edinburgh Edinburgh University Press , 7  10, ISBN   0-902383-26-4  Copeland 2006 , pp.  108111  Bowden 1953 , pp.  176,177  Bowden 1953 , p.  135  Electronic Computer Project . Institute for Advanced Study . Retrieved May 26, 2011 .  a b Campbell-Kelly, Martin April 1982. The Development of Computer Programming in Britain 1945 to 1955. IEEE Annals of the History of Computing . 4 2 121139. doi  10.1109MAHC.1982.10016 .  Robertson, James E. 1955, Illiac Design Techniques , report number UIUCDCS-R-1955-146, Digital Computer Laboratory, University of Illinois at Urbana-Champaign  Selective Sequence Electronic Calculator USPTO Web site  Selective Sequence Electronic Calculator Google Patents  Grosch, Herbert R. J. 1991, Computer Bit Slices From a Life , Third Millennium Books, ISBN   0-88733-085-1  Lavington, Simon, ed. 2012. Alan Turing and his Contemporaries Building the Worlds First Computers . London British Computer Society . p.  61. ISBN   9781906124908 .  Johnson, Roger April 2008. School of Computer Science  Information Systems A Short History PDF . Birkbeck College . University of London . Retrieved July 23, 2017 .  Bell, C. Gordon  Cady, R. McFarland, H. OLaughlin, J. Noonan, R. Wulf, W. 1970, A New Architecture for Mini-ComputersThe DEC PDP-11 PDF , Spring Joint Computer Conference , pp.  657675  Null, Linda Lobur, Julia 2010, The essentials of computer organization and architecture 3rd ed., Jones  Bartlett Learning, pp.  36, 199203, ISBN   978-1-4496-0006-8  Backus, John W. Can Programming Be Liberated from the von Neumann Style A Functional Style and Its Algebra of Programs. doi  10.1145359576.359579 . Cite journal requires journal  help   Dijkstra, Edsger W. E. W. Dijkstra Archive A review of the 1977 Turing Award Lecture . Retrieved July 11, 2008 .  Sites, Richard L. Patt, Yale. Architects Look to Processors of Future . Microprocessor report. 1996 Further reading  edit  .mw-parser-output .refbeginfont-size90margin-bottom0.5em.mw-parser-output .refbegin-hanging-indentsullist-style-typenonemargin-left0.mw-parser-output .refbegin-hanging-indentsulli,.mw-parser-output .refbegin-hanging-indentsdlddmargin-left0padding-left3.2emtext-indent-3.2emlist-stylenone.mw-parser-output .refbegin-100font-size100 Bowden, B. V., ed. 1953, Faster Than Thought A Symposium on Digital Computing Machines , London Sir Isaac Pitman and Sons Ltd. Rojas, Ral Hashagen, Ulf, eds. 2000, The First Computers History and Architectures , MIT Press , ISBN   0-262-18197-5 Davis, Martin 2000, The universal computer the road from Leibniz to Turing , New York W. W. Norton  Company Inc. , ISBN   0-393-04785-7 republished as Davis, Martin 2001, Engines of Logic Mathematicians and the Origin of the Computer , New York W. W. Norton  Company , ISBN   978-0-393-32229-3 Can Programming be Liberated from the von Neumann Style . Backus, John . 1977 ACM Turing Award Lecture. Communications of the ACM, August 1978, Volume 21, Number 8 Online PDF see details at httpswww.cs.tufts.edunrbackus-lecture.html Bell, C. Gordon Newell, Allen 1971, Computer Structures Readings and Examples , McGraw-Hill Book Company , New York. Massive 668 pages Copeland, Jack 2006, Colossus and the Rise of the Modern Computer, in Copeland, B. Jack ed., Colossus The Secrets of Bletchley Parks Codebreaking Computers , Oxford Oxford University Press , ISBN   978-0-19-284055-4 Ganesan, Deepak 2009, The von Neumann Model PDF , retrieved October 22, 2011 McCartney, Scott 1999. ENIAC The Triumphs and Tragedies of the Worlds First Computer . Walker  Co. ISBN   0-8027-1348-3 . Goldstine, Herman H. 1972. The Computer from Pascal to von Neumann . Princeton University Press . ISBN   0-691-08104-2 . Shurkin, Joel 1984. Engines of the Mind A history of the Computer . New York, London W. W. Norton  Company . ISBN   0-393-01804-0 . External links  edit  Wikimedia Commons has media related to Von Neumann architecture . Harvard vs von Neumann A tool that emulates the behavior of a von Neumann machine JOHNNY A simple Open Source simulator of a von Neumann machine for educational purposes v t e Processor technologies Models Turing machine Universal PostTuring Quantum Belt machine Stack machine Finite-state machine with datapath Hierarchical Queue automaton Register machines Counter Pointer Random-access Random-access stored program Architecture Von Neumann Harvard modified Dataflow Transport-triggered Cellular Endianness Memory access NUMA HUMA Loadstore Registermemory Cache hierarchy Memory hierarchy Virtual memory Secondary storage Heterogeneous Fabric Multiprocessing Cognitive Neuromorphic Instruction set architectures Types CISC RISC Application-specific EDGE TRIPS VLIW EPIC MISC OISC NISC ZISC comparison addressing modes x86 ARM MIPS Power ISA SPARC Itanium Unicore MicroBlaze RISC-V others Execution Instruction pipelining Pipeline stall Operand forwarding Classic RISC pipeline Hazards Data dependency Structural Control False sharing Out-of-order Tomasulo algorithm Reservation station Re-order buffer Register renaming Speculative Branch prediction Memory dependence prediction Parallelism Level Bit Bit-serial Word Instruction Pipelining Scalar Superscalar Task Thread Process Data Vector Memory Distributed Multithreading Temporal Simultaneous Hyperthreading Speculative Preemptive Cooperative Flynns taxonomy SISD SIMD SWAR SIMT MISD MIMD SPMD Processor performance Transistor count Instructions per cycle IPC Cycles per instruction CPI Instructions per second IPS Floating-point operations per second FLOPS Transactions per second TPS Synaptic updates per second SUPS Performance per watt PPW Cache performance metrics Computer performance by orders of magnitude Types Central processing unit CPU Graphics processing unit GPU GPGPU Vector Barrel Stream Coprocessor ASIC FPGA CPLD Multi-chip module MCM System in package SiP By application Microprocessor Microcontroller Mobile Notebook Ultra-low-voltage ASIP Systems on chip System on a chip SoC Multiprocessor MPSoC Programmable PSoC Network on a chip NoC Hardware accelerators AI accelerator Vision processing unit VPU Physics processing unit PPU Digital signal processor DSP Tensor processing unit TPU Secure cryptoprocessor Network processor Baseband processor Word size 1-bit 2-bit 4-bit 8-bit 16-bit 32-bit 48-bit 64-bit 128-bit 256-bit 512-bit others variable Core count Single-core Multi-core Manycore Heterogeneous architecture Components Core Cache CPU cache replacement policies coherence Bus Clock rate Clock signal FIFO Functional units Arithmetic logic unit ALU Address generation unit AGU Floating-point unit FPU Memory management unit MMU Loadstore unit Translation lookaside buffer TLB Integrated memory controller IMC Logic Combinational Sequential Glue Logic gate Quantum Array Registers Processor register Status register Stack register Register file Memory buffer Program counter Control unit Instruction unit Data buffer Write buffer Microcode ROM Counter Datapath Multiplexer Demultiplexer Adder Multiplier CPU Binary decoder Address decoder Sum addressed decoder Barrel shifter Circuitry Integrated circuit 3D Mixed-signal Power management Boolean Digital Analog Quantum Switch Power management PMU APM ACPI Dynamic frequency scaling Dynamic voltage scaling Clock gating Performance per watt PPW Related History of general-purpose CPUs Microprocessor chronology Processor design Digital electronics Hardware security module Semiconductor device fabrication Retrieved from  httpsen.wikipedia.orgwindex.phptitleVon_Neumann_architecture oldid912951362  Categories  Computer architecture Flynns taxonomy Reference models Classes of computers School of Computer Science, University of Manchester Open problems Computer-related introductions in 1945 John von Neumann Hidden categories CS1 errors deprecated parameters CS1 errors missing periodical Use American English from March 2019 All Wikipedia articles written in American English Articles with short description Use mdy dates from September 2012 Wikipedia articles needing clarification from November 2015 All articles with unsourced statements Articles with unsourced statements from December 2010 Commons category link from Wikidata