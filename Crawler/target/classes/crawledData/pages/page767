S-algol From Wikipedia, the free encyclopedia Jump to navigation Jump to search S-algol St Andrews Algol 1   vii is a computer programming language derivative of ALGOL 60 developed at the University of St Andrews in 1979 by Ron Morrison and Tony Davie. The language is a modification of ALGOL to contain orthogonal data types that Morrison created for his PhD thesis. Morrison would go on to become professor at the university and head of the department of computer science . The S-algol language was used for teaching at the university at an undergraduate level until 1999. It was also the language taught for several years in the 1980s at a local school in St. Andrews, Madras College . The computer science text Recursive Descent Compiling 2  describes a recursive descent compiler for S-algol, using S-algol as the implementation language. PS-algol is a persistent derivative of S-algol. It was developed around 1981 at the Universities of Edinburgh and St Andrews. It supports database capability by providing for longevity of data in the form of a persistent heap that survives termination of PS-algol programs. Contents 1 History and implementations 2 Language overview 3 Semantic principles 4 S-algol design 4.1 Data types 4.2 The store 4.3 Control structures 4.4 Abstractions 4.5 Declarations and parameters 4.6 Input output model 4.7 Concrete syntax 5 See also 6 References 7 External links History and implementations  edit  Ron Morrisons 1979 PhD thesis, On the Development of Algol , describes the design and implementation of the S-algol language. 3  The technical report defining the language, The S-algol Reference Manual 1979, 1988, thanks several people for their help, including David Turner for discussions on language design around 1975. 4   5 The 1981 computer science text Recursive Descent Compiling describes the compiler implementation and bootstrapping process, 2  and the 1982 book An Introduction to Programming with S-algol uses the language to teach computer programming. 1  The first S-algol implementation was on a PDP-1140 computer running the Unix operating system. 1   vii Due to the small 64 kilobyte address space available on the PDP-11, an interpreted bytecode implementation was chosen. 3   3738 A single-pass , recursive descent compiler written in S-algol translated S-algol source into S-code, a bytecode for a stack-based abstract machine tailored for S-algol. The S-code was then executed by an interpreter . The S-algol implementation had many similarities with work on earlier Pascal compilers. The technique of using a recursive descent compiler to produce code for an abstract machine was well known, with the Pascal P compiler being a famous example from the early 1970s. 2   137 The S-algol compiler was written using the stepwise refinement process 2   71 described by Urs Amman for the development of a Pascal compiler 5  and championed by the inventor of Pascal, Niklaus Wirth . 6  Reflecting the memory organization of the PDP-11 as 32K 16-bit words , the S-code instruction encoding was designed so that each bytecode consisted of a single word. 3   38 The initial bootstrap was performed by writing an S-algol compiler in Algol W on the IBM360 that produced S-code, and using it to compile the compiler written in S-algol to S-code. The resulting S-code file was copied to the PDP-11 and executed on an S-code interpreter written for the PDP-11, making it self-hosting . The self-hosted S-algol compiler executed approximately 7.7 million S-code instructions to compile itself, generating an output file of about ten thousand S-code instructions 16-bit words. 3   45 An S-code interpreter was written for the VAX computer running VMS , making the VAX the first S-algol port . S-algol was also ported to the Zilog Z80 microprocessor running CPM , including raster graphics facilities that had been added to the language. In 1983 S-algol was used as the basis for the PS-algol system, used for research in persistence . The PS-algol S-code interpreter was implemented in C , and the S-code language was extended to include raster graphics. The PS-algol implementation was the basis for S-algol ports to the Macintosh and Sun workstations , featuring a compiler rewritten in C and targeting the extended S-code. 4   5 S-algol was the basis for the PS-algol research in 1983, and a few years later PS-algol became the starting point for the Napier88 language and implementation. While all S-algol compilers produced S-code to be interpreted, a later Napier88 implementation experimented with generating code in C and compiling it with the gcc compiler to provide a native code implementation. 7  Language overview  edit  An S-algol program is a sequence of declarations and clauses. Language elements that are declared include constants, variables, procedures and structures. Constant and variable declarations must specify an initial value. The compiler infers the data type of the declared constant or variable from the type of the initial value, so the type is not stated explicitly. Data types include integer, real, boolean, string, pointer to a structure, and file, and vectors arrays of these types. Procedure declarations do specify the data types of their arguments and return value unless void. Structures also specify the data types of their fields. Clauses include expressions and control structures if, case, for, while and repeat while. The if and case control structures can have values and can be used freely in expressions as long as the type compatibility rules are met. 4  1   Comments are introduced by an exclamation point and continue until end of line.  The let keyword introduces declarations of constants and variables  Identifiers start with an alphabetic character followed by alphanumeric characters or the full stop .  An initial value must be given, and this determines the data type of declaration let width  10   sets the value of a variable, this is an int let animal  dog   type string let x  -7  let y  x  x   separates clauses, needed only if there are two or more clauses on a line let n.a  6.022e23   is used to set the value of a constant, this is a cfloat constant float  if and case can have values and be used in expressions let no.of.lives  if animal  cat  then 9 else 1  Sieve of Eratosthenes write Find primes up to n    let n  readi  constant values can be set during the program run let p  vector 2n of true  vector of bool with bounds 2 to n for i  2 to truncatesqrtn do  for indexes are constants so they use  rather than  if pi do  vector dereference uses parens like a procedure call for j  2  i to n by i do pj  false for i  2 to n do if pi do write i,  n   n in a literal string is a newline  structure record type for a binary tree of cstrings  the pntr data type can point to a structure of any type, type checking is done at runtime structure tree.nodecstring name  pntr left, right  inserts a new string into the binary tree head procedure insert.treecpntr head  cstring new -  pntr  the case clause ends with a mandatory default option, use default   if it is not needed case true of head  nil  tree.nodenew, nil, nil new  headname   headleft  insert.treeheadleft, new  head  new  headname   headright  insert.treeheadright, new  head  default  head procedure print.treecpntr head if head  nil do   is the not equals operator begin print.treeheadleft write headname,  n  print.treeheadright end let fruit  nil fruit  insert.treefruit, banana  fruit  insert.treefruit, kiwi  fruit  insert.treefruit, apple  fruit  insert.treefruit, peach  print.treefruit  print in sorted order  The end of the S-algol program is indicated by   Semantic principles  edit  As its name suggests, S-algol is a member of the ALGOL family of programming languages. Morrison identifies five characteristics of the ALGOL family 3   5 scope rules and block structure   Names can be introduced to define local quantities that are undefined outside the local environment , but different environments may use the same name unambiguously to represent different objects. 3   5 abstraction facility   Provision of a powerful abstraction facility to shorten and clarify programs. In the ALGOL family this is offered by procedures with parameters . 3   5 compile-time type checking   Types can be checked by a static analysis of the program. 3   5 infinite store   The programmer is not responsible for storage allocation and can create as many data objects as needed. 3   5 selective store updating   The program may selectively alter the store. In the ALGOL family this is effected by the assignment statement . 3   6 S-algol was designed to differ from previous members of the ALGOL family by being designed according to semantic principles to provide power through simplicity, and simplicity through greater generality. See Orthogonal . Morrison describes three semantic principles that guided the design of S-algol the principle of correspondence   The rules governing names should be uniform and apply everywhere. This primarily applies to correspondence between declarations and procedure parameters, including consideration of all parameter passing modes. This principle was examined by R. D. Tennent in conjunction with Pascal, 8  and has its roots in work by Peter Landin 9  and Christopher Strachey . 3   910 10  the principle of abstraction   It should be possible to abstract over all meaningful semantic categories in the language. Examples include the function, which is an abstraction over expressions , and the procedure, an abstraction over statements . Tennent and Morrison note that this is a difficult principle to apply because it is hard to identify the semantically meaningful constructs that should be abstracted. 3   10 the principle of data type completeness   All data types should have the same rights in the language. All data types should be allowed in general operations such as assignment or being passed as a parameter. 3   10 See first-class citizen . Morrison also identifies one more basic design consideration the conceptual store   The key design decisions concerning the store include how the store is used, its relationship to data types, implementation of pointers , and protection  constant locations that cant be updated. 3   1011 S-algol design  edit  Morrisons thesis explains how the design principles were applied in S-algol. Data types  edit  The basic data types in S-algol are integer, real, boolean, file, and string. Later pixel and picture types were added to support raster graphics . Integer , real , and boolean are types common to most programming languages. The file type is an IO stream that allows writing or reading data objects. The string type in many languages at that time was considered a compound type , but including it as a native type makes the basic operations of concatenation, substring selection, length, and the comparisons equals, less than, etc. easier to use. It is much more pleasant than the arrays of characters used in Pascal. 3   12 Vectors are provided with components of any type. For any data type T , T is the type of a vector with components of type T. The bounds of the vector are not part of its type but are determined dynamically, and multi-dimension arrays are implemented as vectors of vectors . 3   12 The structure data type comprises any fixed number of fields each of a fixed type. The class of a structure is not part of the type but can be determined dynamically. 3   12 The closure of basic types over vectors and structures provides an infinite number of data types. The language definition allows any type to be used anywhere a type is acceptable. This does not apply to infix operators , as they are syntactic sugar for common functions and are not part of the semantic model. 3   1213 The store  edit  Vectors and structures have full rights and can be assigned as passed as parameters, but copy on assignment and when passed can be inefficient for large objects. Vectors and structures are treated as pointers to the objects, and the pointers are assigned and passed as parameters. Pointers as general objects themselves as in Algol 68 and C are rejected for S-algol because of the concerns of C.A.R. Hoare about the null pointer 11  and the problems with dangling pointers . 3   13 S-algol provides true constant values , objects whose value cannot be updated. This idea is due to Strachey, but constants in many languages such as Pascal are manifest constants, processed at compile time and not implemented as protected locations. Also it must be possible to declare a constant of any data type, not just the scalar types. 3   13 Control structures  edit  S-algol is an expression-oriented language, and statements are expressions of type void . As a consequence, some control structures are expressions that yield values . There are several conditional constructs . The two-alternative version of the conditional is if condition  then clause  else clause  , where the clauses can be statements or expressions. If they are expressions, they must have the same type. The one-armed conditional if condition  do statement  has type void. 3   13 Use of do instead of else in the conditional statement avoids the dangling else syntactic ambiguity. 2   20 The case clause has a selector of any type which is matched using an equality test against expressions of the same type to find the selected clause. The case clause can be a statement or an expression, so the result clauses must all be statements type void or expressions of the same type. Matches are tested in order, so this resembles the guarded commands of Edsgar Dijkstra without the non-determinism . 3   14 The loop statements are mostly conventional. The for loop is similar to that of Hoare. 12  The control identifier is constant and cannot be modified inside the loop. Also conventional are the while condition  do statement  and repeat statement  while condition  loops. The repeat statement  while condition  do statement  construct provides the early exit or n-and-a-half 13  loop. 3   14 Abstractions  edit  S-algol abstracts expressions as functions and statements void expressions as procedures. Modules would provide the abstraction of declarations, but S-algol does not include modules because of the difficulties they pose with block-structured scope. The final syntactic category is sequencer, or control structure. Tennent used the term sequel for the abstraction over sequencers, these would be generalizations of goto and break . The best known abstraction in this category is call-with-current-continuation , but it would not be well understood until some years later. S-algol does not include goto or break, and does not include abstraction over sequencers. 3   14 Declarations and parameters  edit  Every data object in S-algol must be given a value when it is declared. This corresponds to call by value parameter passing and removes the possibility of using an uninitialised value. In fact call by value is the only parameter passing method in S-algol. Reference and result parameters are rejected, which is consistent with the S-algol ban on passing l-values . Structures and vectors are passed as pointers to the objects, but this is still call by value as the behavior is the same as the value used on the right side of assignments. 3   15 Every declaration has a parametric equivalent. All procedure parameter types must be specified. Any procedure passed as a parameter has its full type specified in contrast to Pascal and the same is true for a structure class. 3   15 Input output model  edit  S-algol provides the file data type for IO streams, and several variations of read and write are defined to operate on the basic types. It is expected that individual implementations will extend these simple facilities as needed. 3   15 Concrete syntax  edit  ALGOL languages have been criticized as being verbose. S-algol attempts to improve this by providing less restrictive syntax. 1   159 This is demonstrated primarily in the declaration syntax. Since variable declarations must always include an initial value, the type does not need to be explicitly specified. 3   17 Although it would be possible to infer procedure parameter and return types by examining where the procedure is called, S-algol does require parameter and return types to be specified. This is a practical decision, since it should be possible to understand a procedure without examining its calls. 3   17 Most ALGOLs require that all declarations come before the statements in a block. In S-algol declarations may be mixed with statements because everything must be declared before it is used and there is no goto that would permit jumping past a declaration. 3   17 See also  edit  Napier88 References  edit   a b c d e Cole, A.J. Morrison, R. 1982, An introduction to programming with S-algol , Cambridge University Press, ISBN   978-0-521-25001-6 .mw-parser-output cite.citationfont-styleinherit.mw-parser-output .citation qquotes.mw-parser-output .citation .cs1-lock-free abackgroundurlupload.wikimedia.orgwikipediacommonsthumb665Lock-green.svg9px-Lock-green.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation . cs1-lock-registration abackgroundurlupload.wikimedia.orgwikipediacommonsthumbdd6Lock-gray-alt-2.svg9px-Lock-gray-alt-2.svg.pngno-repeatbackground-positionright .1em center.mw-parser-output .citation .cs1-lock-subscription abackgroundurlupload.wikimedia.orgwikipediacommonsthumbaaaLock-red-alt-2.svg9px-Lock-red-alt-2.svg.pngno-repeatbackground-po sitionright .1em center.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registrationcolor555.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration spanborder-bottom1px dottedcursorhelp.mw-parser-output .cs1-ws-icon abackgroundurlupload.wikimedia.orgwikipediacommonsthumb44cWikisource-logo.svg12px-Wikisource-logo.svg.pngno -repeatbackground-positionright .1em center.mw-parser-output code.cs1-codecolorinheritbackgroundinheritborderinheritpaddinginherit.mw-parser-output .cs1-hidden-errordisplaynonefont-size100.mw-parser-output .cs1-visible-errorfont-size100.mw-parser-output .cs1-maintdisplaynonecolor33aa33margin-left0.3em.mw-parser-output .cs1-subscription,.mw-parser-o utput .cs1-registration,.mw-parser-output .cs1-formatfont-size95.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-leftpadding-left0.2em.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-rightpadding-right0.2em  a b c d e Davie, Antony J. T. Ronald Morrison 1981, Brian Meek ed., Recursive Descent Compiling , Ellis Horwood series in computers and their applications, Chichester, West Sussex Ellis Horwood, ISBN   978-0-470-27270-1  a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad Morrison, R 1979, On the Development of Algol PhD thesis, University of St. Andrews , pp.  170  a b c Morrison, Ron 1988 1979, The S-algol Language Reference Manual tech report CS791, Fife University of St Andrews, pp.  153  Amman, Urs 1972, The development of a compiler, Proc. Int. Symposium on Computing , North Holland, pp.  9399  Wirth, Niklaus April 1971, Program development by stepwise refinement, Communications of the ACM , 14 4 221227, doi  10.1145362575.362577  Bushell, SJ Dearle, A Brown, AL Vaughan, FA 1994, Using C as a Compiler Target Language for Native Code Generation in Persistent Systems pdf , in Atkinson, MP Maier, D Benzaken, V eds., Proc. 6th International Workshop on Persistent Object Systems POS6, Tarascon, France , Workshops in Computing, Springer-Verlag, pp.  164183  Tennent, R.D. 1977, Language design methods based on semantic principles, Acta Informatica , 8 2 97112, doi  10.1007bf00289243  Landin, P.J. March 1966, The next 700 programming languages, Communications of the ACM , 9 3 157164, doi  10.1145365230.365257  Strachey, C. 1966, Towards a formal semantics, Formal language description languages , North-Holland, pp.  198220  Hoare, C.A.R. 1975, Recursive data structures , International Journal of Computer and System Sciences , 4 2 105132, doi  10.1007bf00976239  Hoare, C.A.R. 1972, A note on the for statement, BIT , 12 3 334341, doi  10.1007bf01932305  Edsgar Dijkstra 1973. Personal communication to Donald Knuth , cited in Knuth, D. 1974, Structured Programming with go to Statements PDF , Computing Surveys , 6 4 261301, CiteSeerX   10.1.1.103.6084 , doi  10.1145356635.356640 , archived from the original PDF on 2013-10-23 Cite uses deprecated parameter deadurl  help  External links  edit  Algol 60 implementations and dialects , Computer History Museum Software Preservation Group Persistent S-algol Retrieved from  httpsen.wikipedia.orgwindex.phptitleS-algol oldid899248373  Categories  ALGOL 60 dialect Hidden categories CS1 errors deprecated parameters